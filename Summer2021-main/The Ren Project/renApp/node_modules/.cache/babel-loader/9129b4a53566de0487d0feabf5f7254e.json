{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport bech32 from \"bech32\";\nimport { getRenNetworkDetails } from \"@renproject/interfaces\";\nimport { assertType, fromHex, hash160, retryNTimes, strip0x, toBase64, utilsWithChainNetwork } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport { Networks, Opcode, Script } from \"bitcore-lib\";\nimport base58 from \"bs58\";\nimport { CombinedAPI } from \"./APIs/API\";\nimport { Blockchair, BlockchairNetwork } from \"./APIs/blockchair\";\nimport { Blockstream } from \"./APIs/blockstream\";\nimport { SoChain, SoChainNetwork } from \"./APIs/sochain\";\nimport { createAddress, pubKeyScript as calculatePubKeyScript } from \"./script\";\n\nconst transactionToDeposit = transaction => ({\n  transaction,\n  amount: transaction.amount.toString()\n});\n/**\n * A base Bitcoin chain class that is extended by each Bitcoin chain/fork.\n */\n\n\nexport class BitcoinBaseChain {\n  constructor(network) {\n    this.chain = BitcoinBaseChain.chain;\n    this.name = BitcoinBaseChain.chain;\n    this.legacyName = \"Btc\";\n    this.asset = \"BTC\"; // APIs\n\n    this.withDefaultAPIs = network => {\n      switch (network) {\n        case \"mainnet\":\n          // prettier-ignore\n          return this.withAPI(Blockstream()).withAPI(Blockchair()).withAPI(SoChain(), {\n            priority: 15\n          });\n\n        case \"testnet\":\n          // prettier-ignore\n          return this.withAPI(Blockstream({\n            testnet: true\n          })).withAPI(Blockchair(BlockchairNetwork.BITCOIN_TESTNET)).withAPI(SoChain(SoChainNetwork.BTCTEST), {\n            priority: 15\n          });\n\n        case \"regtest\":\n          // Will be supported when Electrum is added as an API.\n          throw new Error(`Regtest is currently not supported.`);\n      }\n    };\n\n    this.api = CombinedAPI();\n\n    this.withAPI = (api, {\n      priority = 0\n    } = {}) => {\n      this.api.withAPI(api, {\n        priority\n      });\n      return this;\n    };\n\n    this.utils = utilsWithChainNetwork(BitcoinBaseChain.utils, () => this.chainNetwork);\n    /**\n     * See [[LockChain.initialize]].\n     */\n\n    this.initialize = renNetwork => {\n      this.renNetwork = getRenNetworkDetails(renNetwork); // Prioritize the network passed in to the constructor.\n\n      this.chainNetwork = this.chainNetwork || (this.renNetwork.isTestnet ? \"testnet\" : \"mainnet\");\n      return this.withDefaultAPIs(this.chainNetwork);\n    };\n    /**\n     * See [[LockChain.assetIsNative]].\n     */\n\n\n    this.assetIsNative = asset => asset === this.asset;\n\n    this.assetIsSupported = this.assetIsNative;\n\n    this.assertAssetIsSupported = asset => {\n      if (!this.assetIsNative(asset)) {\n        throw new Error(`Asset ${asset} not supported on ${this.chain}.`);\n      }\n    };\n    /**\n     * See [[LockChain.assetDecimals]].\n     */\n\n\n    this.assetDecimals = asset => {\n      if (asset === this.asset) {\n        return 8;\n      }\n\n      throw new Error(`Asset ${asset} not supported on ${this.chain}.`);\n    };\n    /**\n     * See [[LockChain.getDeposits]].\n     */\n\n\n    this.getDeposits = (asset, address, progress, onDeposit) => __awaiter(this, void 0, void 0, function* () {\n      if (!this.chainNetwork) {\n        throw new Error(`${this.name} object not initialized`);\n      }\n\n      if (this.chainNetwork === \"regtest\") {\n        throw new Error(`Unable to fetch deposits on ${this.chainNetwork}`);\n      }\n\n      this.assertAssetIsSupported(asset);\n      let txs;\n\n      if (!progress) {\n        try {\n          txs = yield retryNTimes(() => this.api.fetchTXs(address), 2);\n        } catch (error) {// Ignore error and fallback to getUTXOs.\n        }\n      }\n\n      if (!txs) {\n        txs = yield this.api.fetchUTXOs(address);\n      }\n\n      yield Promise.all(txs.map(tx => __awaiter(this, void 0, void 0, function* () {\n        return onDeposit(transactionToDeposit(tx));\n      })));\n      return true;\n    });\n    /**\n     * See [[LockChain.transactionConfidence]].\n     */\n\n\n    this.transactionConfidence = transaction => __awaiter(this, void 0, void 0, function* () {\n      if (!this.chainNetwork) {\n        throw new Error(`${this.name} object not initialized`);\n      }\n\n      transaction = yield this.api.fetchUTXO(transaction.txHash, transaction.vOut);\n      return {\n        current: transaction.confirmations,\n        target: this.chainNetwork === \"mainnet\" ? 6 : 2\n      };\n    });\n    /**\n     * See [[LockChain.getGatewayAddress]].\n     */\n\n\n    this.getGatewayAddress = (asset, publicKey, gHash) => {\n      if (!this.chainNetwork) {\n        throw new Error(`${this.name} object not initialized`);\n      }\n\n      this.assertAssetIsSupported(asset);\n      const isTestnet = this.chainNetwork === \"testnet\";\n      return this.utils.createAddress(isTestnet, hash160(publicKey), gHash, this.utils.p2shPrefix[isTestnet ? \"testnet\" : \"mainnet\"]);\n    };\n    /**\n     * See [[LockChain.addressToBytes]].\n     */\n\n\n    this.addressToBytes = address => {\n      try {\n        return base58.decode(address);\n      } catch (error) {\n        try {\n          const [type, ...words] = bech32.decode(address).words;\n          return Buffer.concat([Buffer.from([type]), Buffer.from(bech32.fromWords(words))]);\n        } catch (internalError) {\n          throw new Error(`Unrecognized address format \"${address}\".`);\n        }\n      }\n    };\n    /** @deprecated. Renamed to addressToBytes. */\n\n\n    this.addressStringToBytes = this.addressToBytes;\n\n    this.addressToString = address => address;\n    /**\n     * See [[LockChain.transactionID]].\n     */\n\n\n    this.transactionID = transaction => transaction.txHash;\n\n    this.transactionIDFromRPCFormat = (txid, _txindex, reversed) => {\n      // RenVM returns TXIDs in the correct byte direction, so they should be\n      // reversed when converting to a string.\n      // See https://learnmeabitcoin.com/technical/txid#why\n      if (reversed) {\n        // Reverse bytes.\n        const bufferTxid = typeof txid === \"string\" ? Buffer.from(strip0x(txid), \"hex\") : // Create new buffer because `reverse` is in-place.\n        Buffer.from(txid);\n        return bufferTxid.reverse().toString(\"hex\");\n      } else {\n        return typeof txid === \"string\" ? txid : txid.toString(\"hex\");\n      }\n    };\n\n    this.transactionFromRPCFormat = (txid, txindex, reversed) => __awaiter(this, void 0, void 0, function* () {\n      const txidString = this.transactionIDFromRPCFormat(txid, txindex, reversed);\n      return this.api.fetchUTXO(txidString, parseInt(txindex, 10));\n    });\n    /**\n     * @deprecated Renamed to `transactionFromRPCFormat`.\n     * Will be removed in 3.0.0.\n     */\n\n\n    this.transactionFromID = this.transactionFromRPCFormat;\n\n    this.depositV1HashString = ({\n      transaction\n    }) => {\n      return `${toBase64(fromHex(transaction.txHash))}_${transaction.vOut}`;\n    };\n\n    this.transactionRPCFormat = (transaction, v2) => {\n      const {\n        txHash,\n        vOut\n      } = transaction;\n      assertType(\"string\", {\n        txHash\n      });\n      assertType(\"number\", {\n        vOut\n      });\n      return {\n        txid: v2 ? fromHex(transaction.txHash).reverse() : fromHex(transaction.txHash),\n        txindex: transaction.vOut.toFixed()\n      };\n    };\n\n    this.transactionRPCTxidFromID = (transactionID, v2) => v2 ? fromHex(transactionID).reverse() : fromHex(transactionID);\n    /**\n     * When burning, you can call `Bitcoin.Address(\"...\")` to make the address\n     * available to the burn params.\n     *\n     * @category Main\n     */\n\n\n    this.Address = address => {\n      // Type validation\n      assertType(\"string\", {\n        address\n      });\n\n      this.burnPayloadGetter = bytes => bytes ? this.addressToBytes(address).toString(\"hex\") : address;\n\n      return this;\n    };\n\n    this.burnPayload = burnPayloadConfig => {\n      return this.burnPayloadGetter ? this.burnPayloadGetter(burnPayloadConfig && burnPayloadConfig.bytes) : undefined;\n    };\n\n    this.toSats = value => new BigNumber(value).times(new BigNumber(10).exponentiatedBy(8)).decimalPlaces(0).toFixed();\n\n    this.fromSats = value => new BigNumber(value).dividedBy(new BigNumber(10).exponentiatedBy(8)).toFixed();\n\n    this.chainNetwork = network;\n  }\n\n}\nBitcoinBaseChain.chain = \"Bitcoin\"; // Asset\n\nBitcoinBaseChain.asset = \"BTC\"; // Utils\n\nBitcoinBaseChain.utils = {\n  p2shPrefix: {},\n  createAddress: createAddress(base58.encode, Networks, Opcode, Script),\n  calculatePubKeyScript: calculatePubKeyScript(Networks, Opcode, Script),\n  addressIsValid: (_address, _network = \"mainnet\") => true,\n  transactionIsValid: (_transaction, _network = \"mainnet\") => true,\n  addressExplorerLink: (_address, _network = \"mainnet\") => undefined,\n  transactionExplorerLink: (_tx, _network = \"mainnet\") => undefined,\n  resolveChainNetwork: network => {\n    if (network === \"mainnet\" || network === \"testnet\" || network === \"regtest\") {\n      return network;\n    }\n\n    const renNetwork = getRenNetworkDetails(network);\n    return renNetwork.isTestnet ? \"testnet\" : \"mainnet\";\n  }\n};\nconst _ = BitcoinBaseChain;","map":{"version":3,"sources":["../../src/base.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,MAAP,MAAmB,QAAnB;AACA,SACI,oBADJ,QAQO,wBARP;AASA,SACI,UADJ,EAEI,OAFJ,EAGI,OAHJ,EAII,WAJJ,EAKI,OALJ,EAMI,QANJ,EAOI,qBAPJ,QAQO,mBARP;AASA,OAAO,SAAP,MAAsB,cAAtB;AACA,SAAS,QAAT,EAAmB,MAAnB,EAA2B,MAA3B,QAAyC,aAAzC;AACA,OAAO,MAAP,MAAmB,MAAnB;AACA,SAAsC,WAAtC,QAA+D,YAA/D;AACA,SAAS,UAAT,EAAqB,iBAArB,QAA8C,mBAA9C;AACA,SAAS,WAAT,QAA4B,oBAA5B;AACA,SAAS,OAAT,EAAkB,cAAlB,QAAwC,gBAAxC;AAEA,SAAS,aAAT,EAAwB,YAAY,IAAI,qBAAxC,QAAqE,UAArE;;AAUA,MAAM,oBAAoB,GAAI,WAAD,KAAkC;AAC3D,EAAA,WAD2D;AAE3D,EAAA,MAAM,EAAE,WAAW,CAAC,MAAZ,CAAmB,QAAnB;AAFmD,CAAlC,CAA7B;AAKA;;AAEG;;;AACH,OAAM,MAAgB,gBAAhB,CAAgC;AA+GlC,EAAA,WAAA,CAAY,OAAZ,EAAgC;AA1GzB,SAAA,KAAA,GAAQ,gBAAgB,CAAC,KAAzB;AACA,SAAA,IAAA,GAAO,gBAAgB,CAAC,KAAxB;AAEA,SAAA,UAAA,GAAsC,KAAtC;AAMA,SAAA,KAAA,GAAQ,KAAR,CAiGyB,CA/FhC;;AACO,SAAA,eAAA,GAAmB,OAAD,IAA8B;AACnD,cAAQ,OAAR;AACI,aAAK,SAAL;AACI;AACA,iBAAO,KACF,OADE,CACM,WAAW,EADjB,EAEF,OAFE,CAEM,UAAU,EAFhB,EAGF,OAHE,CAGM,OAAO,EAHb,EAGiB;AAAE,YAAA,QAAQ,EAAE;AAAZ,WAHjB,CAAP;;AAIJ,aAAK,SAAL;AACI;AACA,iBAAO,KACF,OADE,CACM,WAAW,CAAC;AAAE,YAAA,OAAO,EAAE;AAAX,WAAD,CADjB,EAEF,OAFE,CAEM,UAAU,CAAC,iBAAiB,CAAC,eAAnB,CAFhB,EAGF,OAHE,CAGM,OAAO,CAAC,cAAc,CAAC,OAAhB,CAHb,EAGuC;AAAE,YAAA,QAAQ,EAAE;AAAZ,WAHvC,CAAP;;AAIJ,aAAK,SAAL;AACI;AACA,gBAAM,IAAI,KAAJ,CAAU,qCAAV,CAAN;AAfR;AAiBH,KAlBM;;AAmBA,SAAA,GAAA,GAAM,WAAW,EAAjB;;AACA,SAAA,OAAA,GAAU,CACb,GADa,EAEb;AAAE,MAAA,QAAQ,GAAG;AAAb,QAAmB,EAFN,KAGb;AACA,WAAK,GAAL,CAAS,OAAT,CAAiB,GAAjB,EAAsB;AAAE,QAAA;AAAF,OAAtB;AACA,aAAO,IAAP;AACH,KANM;;AAqEA,SAAA,KAAA,GAAQ,qBAAqB,CAChC,gBAAgB,CAAC,KADe,EAEhC,MAAM,KAAK,YAFqB,CAA7B;AASP;;AAEG;;AACI,SAAA,UAAA,GACH,UADgB,IAEhB;AACA,WAAK,UAAL,GAAkB,oBAAoB,CAAC,UAAD,CAAtC,CADA,CAEA;;AACA,WAAK,YAAL,GACI,KAAK,YAAL,KACC,KAAK,UAAL,CAAgB,SAAhB,GAA4B,SAA5B,GAAwC,SADzC,CADJ;AAGA,aAAO,KAAK,eAAL,CAAqB,KAAK,YAA1B,CAAP;AACH,KATM;AAWP;;AAEG;;;AACH,SAAA,aAAA,GAAiB,KAAD,IAA4B,KAAK,KAAK,KAAK,KAA3D;;AACA,SAAA,gBAAA,GAAmB,KAAK,aAAxB;;AAEgB,SAAA,sBAAA,GAA0B,KAAD,IAAkB;AACvD,UAAI,CAAC,KAAK,aAAL,CAAmB,KAAnB,CAAL,EAAgC;AAC5B,cAAM,IAAI,KAAJ,CAAU,SAAS,KAAK,qBAAqB,KAAK,KAAK,GAAvD,CAAN;AACH;AACJ,KAJe;AAMhB;;AAEG;;;AACH,SAAA,aAAA,GAAiB,KAAD,IAA0B;AACtC,UAAI,KAAK,KAAK,KAAK,KAAnB,EAA0B;AACtB,eAAO,CAAP;AACH;;AACD,YAAM,IAAI,KAAJ,CAAU,SAAS,KAAK,qBAAqB,KAAK,KAAK,GAAvD,CAAN;AACH,KALD;AAOA;;AAEG;;;AACH,SAAA,WAAA,GAAc,CACV,KADU,EAEV,OAFU,EAGV,QAHU,EAIV,SAJU,KAKQ,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AAClB,UAAI,CAAC,KAAK,YAAV,EAAwB;AACpB,cAAM,IAAI,KAAJ,CAAU,GAAG,KAAK,IAAI,yBAAtB,CAAN;AACH;;AACD,UAAI,KAAK,YAAL,KAAsB,SAA1B,EAAqC;AACjC,cAAM,IAAI,KAAJ,CAAU,+BAA+B,KAAK,YAAY,EAA1D,CAAN;AACH;;AACD,WAAK,sBAAL,CAA4B,KAA5B;AAEA,UAAI,GAAJ;;AAEA,UAAI,CAAC,QAAL,EAAe;AACX,YAAI;AACA,UAAA,GAAG,GAAG,MAAM,WAAW,CAAC,MAAM,KAAK,GAAL,CAAS,QAAT,CAAkB,OAAlB,CAAP,EAAmC,CAAnC,CAAvB;AACH,SAFD,CAEE,OAAO,KAAP,EAAc,CACZ;AACH;AACJ;;AAED,UAAI,CAAC,GAAL,EAAU;AACN,QAAA,GAAG,GAAG,MAAM,KAAK,GAAL,CAAS,UAAT,CAAoB,OAApB,CAAZ;AACH;;AAED,YAAM,OAAO,CAAC,GAAR,CACF,GAAG,CAAC,GAAJ,CAAe,EAAP,IAAa,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AAAC,eAAA,SAAS,CAAC,oBAAoB,CAAC,EAAD,CAArB,CAAT;AAAmC,OAApC,CAArB,CADE,CAAN;AAIA,aAAO,IAAP;AACH,KA5BqB,CALtB;AAmCA;;AAEG;;;AACH,SAAA,qBAAA,GACI,WADoB,IAE0B,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AAC9C,UAAI,CAAC,KAAK,YAAV,EAAwB;AACpB,cAAM,IAAI,KAAJ,CAAU,GAAG,KAAK,IAAI,yBAAtB,CAAN;AACH;;AACD,MAAA,WAAW,GAAG,MAAM,KAAK,GAAL,CAAS,SAAT,CAChB,WAAW,CAAC,MADI,EAEhB,WAAW,CAAC,IAFI,CAApB;AAIA,aAAO;AACH,QAAA,OAAO,EAAE,WAAW,CAAC,aADlB;AAEH,QAAA,MAAM,EAAE,KAAK,YAAL,KAAsB,SAAtB,GAAkC,CAAlC,GAAsC;AAF3C,OAAP;AAIH,KAZiD,CAFlD;AAgBA;;AAEG;;;AACH,SAAA,iBAAA,GAAoB,CAChB,KADgB,EAEhB,SAFgB,EAGhB,KAHgB,KAIkB;AAClC,UAAI,CAAC,KAAK,YAAV,EAAwB;AACpB,cAAM,IAAI,KAAJ,CAAU,GAAG,KAAK,IAAI,yBAAtB,CAAN;AACH;;AACD,WAAK,sBAAL,CAA4B,KAA5B;AACA,YAAM,SAAS,GAAG,KAAK,YAAL,KAAsB,SAAxC;AACA,aAAO,KAAK,KAAL,CAAW,aAAX,CACH,SADG,EAEH,OAAO,CAAC,SAAD,CAFJ,EAGH,KAHG,EAIH,KAAK,KAAL,CAAW,UAAX,CAAsB,SAAS,GAAG,SAAH,GAAe,SAA9C,CAJG,CAAP;AAMH,KAhBD;AAkBA;;AAEG;;;AACH,SAAA,cAAA,GAAkB,OAAD,IAAyC;AACtD,UAAI;AACA,eAAO,MAAM,CAAC,MAAP,CAAc,OAAd,CAAP;AACH,OAFD,CAEE,OAAO,KAAP,EAAc;AACZ,YAAI;AACA,gBAAM,CAAC,IAAD,EAAO,GAAG,KAAV,IAAmB,MAAM,CAAC,MAAP,CAAc,OAAd,EAAuB,KAAhD;AACA,iBAAO,MAAM,CAAC,MAAP,CAAc,CACjB,MAAM,CAAC,IAAP,CAAY,CAAC,IAAD,CAAZ,CADiB,EAEjB,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,SAAP,CAAiB,KAAjB,CAAZ,CAFiB,CAAd,CAAP;AAIH,SAND,CAME,OAAO,aAAP,EAAsB;AACpB,gBAAM,IAAI,KAAJ,CAAU,gCAAgC,OAAO,IAAjD,CAAN;AACH;AACJ;AACJ,KAdD;AAgBA;;;AACA,SAAA,oBAAA,GAAuB,KAAK,cAA5B;;AAEA,SAAA,eAAA,GAAmB,OAAD,IAAkC,OAApD;AAEA;;AAEG;;;AACH,SAAA,aAAA,GAAiB,WAAD,IAAiC,WAAW,CAAC,MAA7D;;AAEA,SAAA,0BAAA,GAA6B,CACzB,IADyB,EAEzB,QAFyB,EAGzB,QAHyB,KAIzB;AACA;AACA;AACA;AACA,UAAI,QAAJ,EAAc;AACV;AACA,cAAM,UAAU,GACZ,OAAO,IAAP,KAAgB,QAAhB,GACM,MAAM,CAAC,IAAP,CAAY,OAAO,CAAC,IAAD,CAAnB,EAA2B,KAA3B,CADN,GAEM;AACA,QAAA,MAAM,CAAC,IAAP,CAAY,IAAZ,CAJV;AAKA,eAAO,UAAU,CAAC,OAAX,GAAqB,QAArB,CAA8B,KAA9B,CAAP;AACH,OARD,MAQO;AACH,eAAO,OAAO,IAAP,KAAgB,QAAhB,GAA2B,IAA3B,GAAkC,IAAI,CAAC,QAAL,CAAc,KAAd,CAAzC;AACH;AACJ,KAnBD;;AAqBA,SAAA,wBAAA,GAA2B,CACvB,IADuB,EAEvB,OAFuB,EAGvB,QAHuB,KAIvB,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACA,YAAM,UAAU,GAAG,KAAK,0BAAL,CACf,IADe,EAEf,OAFe,EAGf,QAHe,CAAnB;AAKA,aAAO,KAAK,GAAL,CAAS,SAAT,CAAmB,UAAnB,EAA+B,QAAQ,CAAC,OAAD,EAAU,EAAV,CAAvC,CAAP;AACH,KAPG,CAJJ;AAYA;;;AAGG;;;AACH,SAAA,iBAAA,GAAoB,KAAK,wBAAzB;;AAEA,SAAA,mBAAA,GAAsB,CAAC;AAAE,MAAA;AAAF,KAAD,KAAwC;AAC1D,aAAO,GAAG,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,MAAb,CAAR,CAA6B,IAAI,WAAW,CAAC,IAAI,EAAnE;AACH,KAFD;;AAIA,SAAA,oBAAA,GAAuB,CAAC,WAAD,EAA8B,EAA9B,KAA8C;AACjE,YAAM;AAAE,QAAA,MAAF;AAAU,QAAA;AAAV,UAAmB,WAAzB;AAEA,MAAA,UAAU,CAAS,QAAT,EAAmB;AAAE,QAAA;AAAF,OAAnB,CAAV;AACA,MAAA,UAAU,CAAS,QAAT,EAAmB;AAAE,QAAA;AAAF,OAAnB,CAAV;AAEA,aAAO;AACH,QAAA,IAAI,EAAE,EAAE,GACF,OAAO,CAAC,WAAW,CAAC,MAAb,CAAP,CAA4B,OAA5B,EADE,GAEF,OAAO,CAAC,WAAW,CAAC,MAAb,CAHV;AAIH,QAAA,OAAO,EAAE,WAAW,CAAC,IAAZ,CAAiB,OAAjB;AAJN,OAAP;AAMH,KAZD;;AAcA,SAAA,wBAAA,GAA2B,CAAC,aAAD,EAAwB,EAAxB,KACvB,EAAE,GAAG,OAAO,CAAC,aAAD,CAAP,CAAuB,OAAvB,EAAH,GAAsC,OAAO,CAAC,aAAD,CADnD;AAOA;;;;;AAKG;;;AACH,SAAA,OAAA,GAAW,OAAD,IAA0B;AAChC;AACA,MAAA,UAAU,CAAS,QAAT,EAAmB;AAAE,QAAA;AAAF,OAAnB,CAAV;;AAEA,WAAK,iBAAL,GAA0B,KAAD,IACrB,KAAK,GAAG,KAAK,cAAL,CAAoB,OAApB,EAA6B,QAA7B,CAAsC,KAAtC,CAAH,GAAkD,OAD3D;;AAGA,aAAO,IAAP;AACH,KARD;;AAUA,SAAA,WAAA,GAAgB,iBAAD,IAA0C;AACrD,aAAO,KAAK,iBAAL,GACD,KAAK,iBAAL,CACI,iBAAiB,IAAI,iBAAiB,CAAC,KAD3C,CADC,GAID,SAJN;AAKH,KAND;;AAQA,SAAA,MAAA,GAAU,KAAD,IACL,IAAI,SAAJ,CAAc,KAAd,EACK,KADL,CACW,IAAI,SAAJ,CAAc,EAAd,EAAkB,eAAlB,CAAkC,CAAlC,CADX,EAEK,aAFL,CAEmB,CAFnB,EAGK,OAHL,EADJ;;AAMA,SAAA,QAAA,GAAY,KAAD,IACP,IAAI,SAAJ,CAAc,KAAd,EACK,SADL,CACe,IAAI,SAAJ,CAAc,EAAd,EAAkB,eAAlB,CAAkC,CAAlC,CADf,EAEK,OAFL,EADJ;;AAhPI,SAAK,YAAL,GAAoB,OAApB;AACH;;AAjHiC;AAIpB,gBAAA,CAAA,KAAA,GAAQ,SAAR,C,CAQd;;AACc,gBAAA,CAAA,KAAA,GAAQ,KAAR,C,CAgCd;;AACc,gBAAA,CAAA,KAAA,GAAQ;AAClB,EAAA,UAAU,EAAE,EADM;AAElB,EAAA,aAAa,EAAE,aAAa,CAAC,MAAM,CAAC,MAAR,EAAgB,QAAhB,EAA0B,MAA1B,EAAkC,MAAlC,CAFV;AAGlB,EAAA,qBAAqB,EAAE,qBAAqB,CAAC,QAAD,EAAW,MAAX,EAAmB,MAAnB,CAH1B;AAIlB,EAAA,cAAc,EAAE,CACZ,QADY,EAEZ,QAAA,GAImB,SANP,KAOF,IAXI;AAalB,EAAA,kBAAkB,EAAE,CAChB,YADgB,EAEhB,QAAA,GAImB,SANH,KAON,IApBI;AAsBlB,EAAA,mBAAmB,EAAE,CACjB,QADiB,EAEjB,QAAA,GAImB,SANF,KAOI,SA7BP;AA+BlB,EAAA,uBAAuB,EAAE,CACrB,GADqB,EAErB,QAAA,GAImB,SANE,KAOA,SAtCP;AAwClB,EAAA,mBAAmB,EACf,OADiB,IAML;AACZ,QACI,OAAO,KAAK,SAAZ,IACA,OAAO,KAAK,SADZ,IAEA,OAAO,KAAK,SAHhB,EAIE;AACE,aAAO,OAAP;AACH;;AAED,UAAM,UAAU,GAAG,oBAAoB,CAAC,OAAD,CAAvC;AACA,WAAO,UAAU,CAAC,SAAX,GAAuB,SAAvB,GAAmC,SAA1C;AACH;AAzDiB,CAAR;AAwTlB,MAAM,CAAC,GAAwD,gBAA/D","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport bech32 from \"bech32\";\nimport { getRenNetworkDetails, } from \"@renproject/interfaces\";\nimport { assertType, fromHex, hash160, retryNTimes, strip0x, toBase64, utilsWithChainNetwork, } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport { Networks, Opcode, Script } from \"bitcore-lib\";\nimport base58 from \"bs58\";\nimport { CombinedAPI } from \"./APIs/API\";\nimport { Blockchair, BlockchairNetwork } from \"./APIs/blockchair\";\nimport { Blockstream } from \"./APIs/blockstream\";\nimport { SoChain, SoChainNetwork } from \"./APIs/sochain\";\nimport { createAddress, pubKeyScript as calculatePubKeyScript } from \"./script\";\nconst transactionToDeposit = (transaction) => ({\n    transaction,\n    amount: transaction.amount.toString(),\n});\n/**\n * A base Bitcoin chain class that is extended by each Bitcoin chain/fork.\n */\nexport class BitcoinBaseChain {\n    constructor(network) {\n        this.chain = BitcoinBaseChain.chain;\n        this.name = BitcoinBaseChain.chain;\n        this.legacyName = \"Btc\";\n        this.asset = \"BTC\";\n        // APIs\n        this.withDefaultAPIs = (network) => {\n            switch (network) {\n                case \"mainnet\":\n                    // prettier-ignore\n                    return this\n                        .withAPI(Blockstream())\n                        .withAPI(Blockchair())\n                        .withAPI(SoChain(), { priority: 15 });\n                case \"testnet\":\n                    // prettier-ignore\n                    return this\n                        .withAPI(Blockstream({ testnet: true }))\n                        .withAPI(Blockchair(BlockchairNetwork.BITCOIN_TESTNET))\n                        .withAPI(SoChain(SoChainNetwork.BTCTEST), { priority: 15 });\n                case \"regtest\":\n                    // Will be supported when Electrum is added as an API.\n                    throw new Error(`Regtest is currently not supported.`);\n            }\n        };\n        this.api = CombinedAPI();\n        this.withAPI = (api, { priority = 0 } = {}) => {\n            this.api.withAPI(api, { priority });\n            return this;\n        };\n        this.utils = utilsWithChainNetwork(BitcoinBaseChain.utils, () => this.chainNetwork);\n        /**\n         * See [[LockChain.initialize]].\n         */\n        this.initialize = (renNetwork) => {\n            this.renNetwork = getRenNetworkDetails(renNetwork);\n            // Prioritize the network passed in to the constructor.\n            this.chainNetwork =\n                this.chainNetwork ||\n                    (this.renNetwork.isTestnet ? \"testnet\" : \"mainnet\");\n            return this.withDefaultAPIs(this.chainNetwork);\n        };\n        /**\n         * See [[LockChain.assetIsNative]].\n         */\n        this.assetIsNative = (asset) => asset === this.asset;\n        this.assetIsSupported = this.assetIsNative;\n        this.assertAssetIsSupported = (asset) => {\n            if (!this.assetIsNative(asset)) {\n                throw new Error(`Asset ${asset} not supported on ${this.chain}.`);\n            }\n        };\n        /**\n         * See [[LockChain.assetDecimals]].\n         */\n        this.assetDecimals = (asset) => {\n            if (asset === this.asset) {\n                return 8;\n            }\n            throw new Error(`Asset ${asset} not supported on ${this.chain}.`);\n        };\n        /**\n         * See [[LockChain.getDeposits]].\n         */\n        this.getDeposits = (asset, address, progress, onDeposit) => __awaiter(this, void 0, void 0, function* () {\n            if (!this.chainNetwork) {\n                throw new Error(`${this.name} object not initialized`);\n            }\n            if (this.chainNetwork === \"regtest\") {\n                throw new Error(`Unable to fetch deposits on ${this.chainNetwork}`);\n            }\n            this.assertAssetIsSupported(asset);\n            let txs;\n            if (!progress) {\n                try {\n                    txs = yield retryNTimes(() => this.api.fetchTXs(address), 2);\n                }\n                catch (error) {\n                    // Ignore error and fallback to getUTXOs.\n                }\n            }\n            if (!txs) {\n                txs = yield this.api.fetchUTXOs(address);\n            }\n            yield Promise.all(txs.map((tx) => __awaiter(this, void 0, void 0, function* () { return onDeposit(transactionToDeposit(tx)); })));\n            return true;\n        });\n        /**\n         * See [[LockChain.transactionConfidence]].\n         */\n        this.transactionConfidence = (transaction) => __awaiter(this, void 0, void 0, function* () {\n            if (!this.chainNetwork) {\n                throw new Error(`${this.name} object not initialized`);\n            }\n            transaction = yield this.api.fetchUTXO(transaction.txHash, transaction.vOut);\n            return {\n                current: transaction.confirmations,\n                target: this.chainNetwork === \"mainnet\" ? 6 : 2,\n            };\n        });\n        /**\n         * See [[LockChain.getGatewayAddress]].\n         */\n        this.getGatewayAddress = (asset, publicKey, gHash) => {\n            if (!this.chainNetwork) {\n                throw new Error(`${this.name} object not initialized`);\n            }\n            this.assertAssetIsSupported(asset);\n            const isTestnet = this.chainNetwork === \"testnet\";\n            return this.utils.createAddress(isTestnet, hash160(publicKey), gHash, this.utils.p2shPrefix[isTestnet ? \"testnet\" : \"mainnet\"]);\n        };\n        /**\n         * See [[LockChain.addressToBytes]].\n         */\n        this.addressToBytes = (address) => {\n            try {\n                return base58.decode(address);\n            }\n            catch (error) {\n                try {\n                    const [type, ...words] = bech32.decode(address).words;\n                    return Buffer.concat([\n                        Buffer.from([type]),\n                        Buffer.from(bech32.fromWords(words)),\n                    ]);\n                }\n                catch (internalError) {\n                    throw new Error(`Unrecognized address format \"${address}\".`);\n                }\n            }\n        };\n        /** @deprecated. Renamed to addressToBytes. */\n        this.addressStringToBytes = this.addressToBytes;\n        this.addressToString = (address) => address;\n        /**\n         * See [[LockChain.transactionID]].\n         */\n        this.transactionID = (transaction) => transaction.txHash;\n        this.transactionIDFromRPCFormat = (txid, _txindex, reversed) => {\n            // RenVM returns TXIDs in the correct byte direction, so they should be\n            // reversed when converting to a string.\n            // See https://learnmeabitcoin.com/technical/txid#why\n            if (reversed) {\n                // Reverse bytes.\n                const bufferTxid = typeof txid === \"string\"\n                    ? Buffer.from(strip0x(txid), \"hex\")\n                    : // Create new buffer because `reverse` is in-place.\n                        Buffer.from(txid);\n                return bufferTxid.reverse().toString(\"hex\");\n            }\n            else {\n                return typeof txid === \"string\" ? txid : txid.toString(\"hex\");\n            }\n        };\n        this.transactionFromRPCFormat = (txid, txindex, reversed) => __awaiter(this, void 0, void 0, function* () {\n            const txidString = this.transactionIDFromRPCFormat(txid, txindex, reversed);\n            return this.api.fetchUTXO(txidString, parseInt(txindex, 10));\n        });\n        /**\n         * @deprecated Renamed to `transactionFromRPCFormat`.\n         * Will be removed in 3.0.0.\n         */\n        this.transactionFromID = this.transactionFromRPCFormat;\n        this.depositV1HashString = ({ transaction }) => {\n            return `${toBase64(fromHex(transaction.txHash))}_${transaction.vOut}`;\n        };\n        this.transactionRPCFormat = (transaction, v2) => {\n            const { txHash, vOut } = transaction;\n            assertType(\"string\", { txHash });\n            assertType(\"number\", { vOut });\n            return {\n                txid: v2\n                    ? fromHex(transaction.txHash).reverse()\n                    : fromHex(transaction.txHash),\n                txindex: transaction.vOut.toFixed(),\n            };\n        };\n        this.transactionRPCTxidFromID = (transactionID, v2) => v2 ? fromHex(transactionID).reverse() : fromHex(transactionID);\n        /**\n         * When burning, you can call `Bitcoin.Address(\"...\")` to make the address\n         * available to the burn params.\n         *\n         * @category Main\n         */\n        this.Address = (address) => {\n            // Type validation\n            assertType(\"string\", { address });\n            this.burnPayloadGetter = (bytes) => bytes ? this.addressToBytes(address).toString(\"hex\") : address;\n            return this;\n        };\n        this.burnPayload = (burnPayloadConfig) => {\n            return this.burnPayloadGetter\n                ? this.burnPayloadGetter(burnPayloadConfig && burnPayloadConfig.bytes)\n                : undefined;\n        };\n        this.toSats = (value) => new BigNumber(value)\n            .times(new BigNumber(10).exponentiatedBy(8))\n            .decimalPlaces(0)\n            .toFixed();\n        this.fromSats = (value) => new BigNumber(value)\n            .dividedBy(new BigNumber(10).exponentiatedBy(8))\n            .toFixed();\n        this.chainNetwork = network;\n    }\n}\nBitcoinBaseChain.chain = \"Bitcoin\";\n// Asset\nBitcoinBaseChain.asset = \"BTC\";\n// Utils\nBitcoinBaseChain.utils = {\n    p2shPrefix: {},\n    createAddress: createAddress(base58.encode, Networks, Opcode, Script),\n    calculatePubKeyScript: calculatePubKeyScript(Networks, Opcode, Script),\n    addressIsValid: (_address, _network = \"mainnet\") => true,\n    transactionIsValid: (_transaction, _network = \"mainnet\") => true,\n    addressExplorerLink: (_address, _network = \"mainnet\") => undefined,\n    transactionExplorerLink: (_tx, _network = \"mainnet\") => undefined,\n    resolveChainNetwork: (network) => {\n        if (network === \"mainnet\" ||\n            network === \"testnet\" ||\n            network === \"regtest\") {\n            return network;\n        }\n        const renNetwork = getRenNetworkDetails(network);\n        return renNetwork.isTestnet ? \"testnet\" : \"mainnet\";\n    },\n};\nconst _ = BitcoinBaseChain;\n//# sourceMappingURL=base.js.map"]},"metadata":{},"sourceType":"module"}