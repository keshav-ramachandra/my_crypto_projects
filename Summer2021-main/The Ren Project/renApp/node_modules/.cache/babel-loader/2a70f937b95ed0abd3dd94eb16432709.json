{"ast":null,"code":"import { fromBase64 } from \"@renproject/utils\";\nimport BN from \"bn.js\";\nimport { PackPrimitive } from \"./pack\";\nexport const marshalPackType = type => {\n  switch (type) {\n    case \"nil\":\n      return 0;\n    // KindBool is the kind of all Bool values.\n\n    case PackPrimitive.Bool:\n      return 1;\n    // KindU8 is the kind of all U8 values.\n\n    case PackPrimitive.U8:\n      return 2;\n    // KindU16 is the kind of all U16 values.\n\n    case PackPrimitive.U16:\n      return 3;\n    // KindU32 is the kind of all U32 values.\n\n    case PackPrimitive.U32:\n      return 4;\n    // KindU64 is the kind of all U64 values.\n\n    case PackPrimitive.U64:\n      return 5;\n    // KindU128 is the kind of all U128 values.\n\n    case PackPrimitive.U128:\n      return 6;\n    // KindU256 is the kind of all U256 values.\n\n    case PackPrimitive.U256:\n      return 7;\n    // KindString is the kind of all utf8 strings.\n\n    case PackPrimitive.Str:\n      return 10;\n    // KindBytes is the kind of all dynamic byte arrays.\n\n    case PackPrimitive.Bytes:\n      return 11;\n    // KindBytes32 is the kind of all 32-byte arrays.\n\n    case PackPrimitive.Bytes32:\n      return 12;\n    // KindBytes65 is the kind of all 65-byte arrays.\n\n    case PackPrimitive.Bytes65:\n      return 13;\n    // KindStruct is the kind of all struct values. It is abstract, because it does\n    // not specify the fields in the struct.\n\n    case \"struct\":\n      return 20;\n    // KindList is the kind of all list values. It is abstract, because it does\n    // not specify the type of the elements in the list.\n\n    case \"list\":\n      return 21;\n  }\n\n  throw new Error(`Unknown type ${String(type)}.`);\n};\nexport const marshalUint = (value, length) => {\n  try {\n    return new BN(typeof value === \"number\" ? value : value.toString()).toArrayLike(Buffer, \"be\", length);\n  } catch (error) {\n    error.message = `Unable to marshal uint${length * 8} '${value}': ${String(error.message)}`;\n    throw error;\n  }\n};\n\nconst marshalU = length => value => marshalUint(value, length);\n\nexport const marshalU8 = marshalU(8 / 8);\nexport const marshalU16 = marshalU(16 / 8);\nexport const marshalU32 = marshalU(32 / 8);\nexport const marshalU64 = marshalU(64 / 8);\nexport const marshalU128 = marshalU(128 / 8);\nexport const marshalU256 = marshalU(256 / 8);\n\nconst withLength = value => Buffer.concat([marshalU32(value.length), value]);\n\nexport const marshalString = value => {\n  return withLength(Buffer.from(value));\n};\nexport const marshalPackStructType = type => {\n  const length = marshalU32(type.struct.length);\n  return Buffer.concat([length, ...type.struct.map(field => {\n    const keys = Object.keys(field);\n\n    if (keys.length === 0) {\n      throw new Error(`Invalid struct field with no entries.`);\n    }\n\n    if (keys.length > 1) {\n      throw new Error(`Invalid struct field with multiple entries.`);\n    }\n\n    const key = Object.keys(field)[0];\n    const fieldType = field[key];\n    return Buffer.concat([marshalString(key), marshalPackTypeDefinition(fieldType)]);\n  })]);\n};\nexport const marshalPackTypeDefinition = type => {\n  if (typeof type === \"object\") {\n    return Buffer.concat([Buffer.from([marshalPackType(\"struct\")]), marshalPackStructType(type)]);\n  } else if (typeof type === \"string\") {\n    return Buffer.from([marshalPackType(type)]);\n  }\n\n  throw new Error(`Unable to marshal type ${String(type)}.`);\n};\nexport const marshalPackPrimitive = (type, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue) => {\n  switch (type) {\n    // Booleans\n    case PackPrimitive.Bool:\n      return marshalU8(value ? 1 : 0);\n    // Integers\n\n    case PackPrimitive.U8:\n      return marshalU8(value);\n\n    case PackPrimitive.U16:\n      return marshalU16(value);\n\n    case PackPrimitive.U32:\n      return marshalU32(value);\n\n    case PackPrimitive.U64:\n      return marshalU64(value);\n\n    case PackPrimitive.U128:\n      return marshalU128(value);\n\n    case PackPrimitive.U256:\n      return marshalU256(value);\n    // Strings\n\n    case PackPrimitive.Str:\n      {\n        return marshalString(value);\n      }\n    // Bytes\n\n    case PackPrimitive.Bytes:\n      {\n        return withLength(Buffer.isBuffer(value) ? Buffer.from(value) : // Supports base64 url format\n        fromBase64(value));\n      }\n\n    case PackPrimitive.Bytes32:\n    case PackPrimitive.Bytes65:\n      return Buffer.isBuffer(value) ? Buffer.from(value) : // Supports base64 url format\n      fromBase64(value);\n  }\n}; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport const marshalPackStruct = (type, value) => {\n  return Buffer.concat(type.struct.map(member => {\n    const keys = Object.keys(member);\n\n    if (keys.length === 0) {\n      throw new Error(`Invalid struct member with no entries.`);\n    }\n\n    if (keys.length > 1) {\n      throw new Error(`Invalid struct member with multiple entries.`);\n    }\n\n    const key = Object.keys(member)[0];\n    const memberType = member[key];\n\n    try {\n      return marshalPackValue(memberType, value[key]);\n    } catch (error) {\n      error.message = `Unable to marshal struct field ${key}: ${String(error.message)}`;\n      throw error;\n    }\n  }));\n};\nexport const marshalPackValue = (type, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue) => {\n  if (typeof type === \"object\") {\n    return marshalPackStruct(type, value);\n  } else if (typeof type === \"string\") {\n    if (type === \"nil\") return Buffer.from([]);\n    return marshalPackPrimitive(type, value);\n  }\n\n  throw new Error(`Unknown value type ${String(type)}${!type ? ` for value ${String(value)}` : \"\"}`);\n};\nexport const marshalTypedPackValue = ({\n  t,\n  v\n}) => {\n  const marshalledType = marshalPackTypeDefinition(t);\n  const marshalledValue = marshalPackValue(t, v);\n  return Buffer.concat([marshalledType, marshalledValue]);\n};","map":{"version":3,"sources":["../../../../src/v2/pack/marshal.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { fromBase64 } from \"@renproject/utils\";\nimport BN from \"bn.js\";\nimport { PackPrimitive, } from \"./pack\";\nexport const marshalPackType = (type) => {\n    switch (type) {\n        case \"nil\":\n            return 0;\n        // KindBool is the kind of all Bool values.\n        case PackPrimitive.Bool:\n            return 1;\n        // KindU8 is the kind of all U8 values.\n        case PackPrimitive.U8:\n            return 2;\n        // KindU16 is the kind of all U16 values.\n        case PackPrimitive.U16:\n            return 3;\n        // KindU32 is the kind of all U32 values.\n        case PackPrimitive.U32:\n            return 4;\n        // KindU64 is the kind of all U64 values.\n        case PackPrimitive.U64:\n            return 5;\n        // KindU128 is the kind of all U128 values.\n        case PackPrimitive.U128:\n            return 6;\n        // KindU256 is the kind of all U256 values.\n        case PackPrimitive.U256:\n            return 7;\n        // KindString is the kind of all utf8 strings.\n        case PackPrimitive.Str:\n            return 10;\n        // KindBytes is the kind of all dynamic byte arrays.\n        case PackPrimitive.Bytes:\n            return 11;\n        // KindBytes32 is the kind of all 32-byte arrays.\n        case PackPrimitive.Bytes32:\n            return 12;\n        // KindBytes65 is the kind of all 65-byte arrays.\n        case PackPrimitive.Bytes65:\n            return 13;\n        // KindStruct is the kind of all struct values. It is abstract, because it does\n        // not specify the fields in the struct.\n        case \"struct\":\n            return 20;\n        // KindList is the kind of all list values. It is abstract, because it does\n        // not specify the type of the elements in the list.\n        case \"list\":\n            return 21;\n    }\n    throw new Error(`Unknown type ${String(type)}.`);\n};\nexport const marshalUint = (value, length) => {\n    try {\n        return new BN(typeof value === \"number\" ? value : value.toString()).toArrayLike(Buffer, \"be\", length);\n    }\n    catch (error) {\n        error.message = `Unable to marshal uint${length * 8} '${value}': ${String(error.message)}`;\n        throw error;\n    }\n};\nconst marshalU = (length) => (value) => marshalUint(value, length);\nexport const marshalU8 = marshalU(8 / 8);\nexport const marshalU16 = marshalU(16 / 8);\nexport const marshalU32 = marshalU(32 / 8);\nexport const marshalU64 = marshalU(64 / 8);\nexport const marshalU128 = marshalU(128 / 8);\nexport const marshalU256 = marshalU(256 / 8);\nconst withLength = (value) => Buffer.concat([marshalU32(value.length), value]);\nexport const marshalString = (value) => {\n    return withLength(Buffer.from(value));\n};\nexport const marshalPackStructType = (type) => {\n    const length = marshalU32(type.struct.length);\n    return Buffer.concat([\n        length,\n        ...type.struct.map((field) => {\n            const keys = Object.keys(field);\n            if (keys.length === 0) {\n                throw new Error(`Invalid struct field with no entries.`);\n            }\n            if (keys.length > 1) {\n                throw new Error(`Invalid struct field with multiple entries.`);\n            }\n            const key = Object.keys(field)[0];\n            const fieldType = field[key];\n            return Buffer.concat([\n                marshalString(key),\n                marshalPackTypeDefinition(fieldType),\n            ]);\n        }),\n    ]);\n};\nexport const marshalPackTypeDefinition = (type) => {\n    if (typeof type === \"object\") {\n        return Buffer.concat([\n            Buffer.from([marshalPackType(\"struct\")]),\n            marshalPackStructType(type),\n        ]);\n    }\n    else if (typeof type === \"string\") {\n        return Buffer.from([marshalPackType(type)]);\n    }\n    throw new Error(`Unable to marshal type ${String(type)}.`);\n};\nexport const marshalPackPrimitive = (type, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue) => {\n    switch (type) {\n        // Booleans\n        case PackPrimitive.Bool:\n            return marshalU8(value ? 1 : 0);\n        // Integers\n        case PackPrimitive.U8:\n            return marshalU8(value);\n        case PackPrimitive.U16:\n            return marshalU16(value);\n        case PackPrimitive.U32:\n            return marshalU32(value);\n        case PackPrimitive.U64:\n            return marshalU64(value);\n        case PackPrimitive.U128:\n            return marshalU128(value);\n        case PackPrimitive.U256:\n            return marshalU256(value);\n        // Strings\n        case PackPrimitive.Str: {\n            return marshalString(value);\n        }\n        // Bytes\n        case PackPrimitive.Bytes: {\n            return withLength(Buffer.isBuffer(value)\n                ? Buffer.from(value)\n                : // Supports base64 url format\n                    fromBase64(value));\n        }\n        case PackPrimitive.Bytes32:\n        case PackPrimitive.Bytes65:\n            return Buffer.isBuffer(value)\n                ? Buffer.from(value)\n                : // Supports base64 url format\n                    fromBase64(value);\n    }\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const marshalPackStruct = (type, value) => {\n    return Buffer.concat(type.struct.map((member) => {\n        const keys = Object.keys(member);\n        if (keys.length === 0) {\n            throw new Error(`Invalid struct member with no entries.`);\n        }\n        if (keys.length > 1) {\n            throw new Error(`Invalid struct member with multiple entries.`);\n        }\n        const key = Object.keys(member)[0];\n        const memberType = member[key];\n        try {\n            return marshalPackValue(memberType, value[key]);\n        }\n        catch (error) {\n            error.message = `Unable to marshal struct field ${key}: ${String(error.message)}`;\n            throw error;\n        }\n    }));\n};\nexport const marshalPackValue = (type, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue) => {\n    if (typeof type === \"object\") {\n        return marshalPackStruct(type, value);\n    }\n    else if (typeof type === \"string\") {\n        if (type === \"nil\")\n            return Buffer.from([]);\n        return marshalPackPrimitive(type, value);\n    }\n    throw new Error(`Unknown value type ${String(type)}${!type ? ` for value ${String(value)}` : \"\"}`);\n};\nexport const marshalTypedPackValue = ({ t, v }) => {\n    const marshalledType = marshalPackTypeDefinition(t);\n    const marshalledValue = marshalPackValue(t, v);\n    return Buffer.concat([marshalledType, marshalledValue]);\n};\n//# sourceMappingURL=marshal.js.map"]},"metadata":{},"sourceType":"module"}