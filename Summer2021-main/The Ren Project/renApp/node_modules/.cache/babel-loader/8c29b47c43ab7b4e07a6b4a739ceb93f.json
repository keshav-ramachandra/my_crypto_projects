{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport axios from 'axios';\nexport function removeEmptyHeaders(headers) {\n  var newHeaders = {};\n  Object.keys(headers).forEach(function (key) {\n    if (headers[key]) newHeaders[key] = headers[key];\n  });\n  return newHeaders;\n}\nexport function configureHeaders() {\n  var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var token = arguments.length > 1 ? arguments[1] : undefined;\n  var reqHeaders = Object.assign({}, headers, {\n    Accept: '*/*'\n  });\n\n  if (token) {\n    reqHeaders.Authorization = \"Bearer \".concat(token);\n  }\n\n  return removeEmptyHeaders(reqHeaders);\n}\nexport function throwIfErrors(response) {\n  if (response.error) {\n    if (response.error.message) throw new Error(response.error.message);else throw new Error('Unknown jsonrpc error');\n  } else {\n    return response;\n  }\n}\nexport function deleteHeaders(opts) {\n  delete opts.headers;\n  return opts;\n}\n\nvar LotusRpcEngine = /*#__PURE__*/function () {\n  function LotusRpcEngine(config) {\n    var _config$axiosOpts;\n\n    _classCallCheck(this, LotusRpcEngine);\n\n    _defineProperty(this, \"apiAddress\", void 0);\n\n    _defineProperty(this, \"token\", void 0);\n\n    _defineProperty(this, \"axiosOpts\", void 0);\n\n    _defineProperty(this, \"headers\", void 0);\n\n    if (!config) throw new Error('Must pass a config object to the LotusRpcEngine constructor.');\n    this.apiAddress = config.apiAddress || 'http://127.0.0.1:1234/rpc/v0';\n    this.token = config.token;\n    this.headers = configureHeaders(config === null || config === void 0 ? void 0 : (_config$axiosOpts = config.axiosOpts) === null || _config$axiosOpts === void 0 ? void 0 : _config$axiosOpts.headers, config.token);\n    this.axiosOpts = deleteHeaders(config.axiosOpts || {});\n  }\n\n  _createClass(LotusRpcEngine, [{\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(method) {\n        var _len,\n            params,\n            _key,\n            _yield$axios$post,\n            data,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                for (_len = _args.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                  params[_key - 1] = _args[_key];\n                }\n\n                _context.next = 3;\n                return axios.post(this.apiAddress, {\n                  jsonrpc: '2.0',\n                  method: \"Filecoin.\".concat(method),\n                  params: params,\n                  id: 1\n                }, _objectSpread({\n                  headers: this.headers\n                }, this.axiosOpts));\n\n              case 3:\n                _yield$axios$post = _context.sent;\n                data = _yield$axios$post.data;\n                throwIfErrors(data);\n                return _context.abrupt(\"return\", data.result);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function request(_x) {\n        return _request.apply(this, arguments);\n      }\n\n      return request;\n    }()\n  }]);\n\n  return LotusRpcEngine;\n}();\n\nexport { LotusRpcEngine as default };","map":{"version":3,"sources":["../src/index.ts"],"names":["newHeaders","Object","headers","token","reqHeaders","Accept","removeEmptyHeaders","response","opts","LotusRpcEngine","config","configureHeaders","deleteHeaders","method","params","data","jsonrpc","id","throwIfErrors","result"],"mappings":"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","sourcesContent":["import axios, { AxiosRequestConfig } from 'axios'\n\ntype Headers = Record<string, string | null | undefined>\n\nexport function removeEmptyHeaders(headers: Headers): Headers {\n  const newHeaders: Headers = {}\n  Object.keys(headers).forEach((key) => {\n    if (headers[key]) newHeaders[key] = headers[key]\n  })\n  return newHeaders\n}\n\nexport function configureHeaders(\n  headers: Headers = {},\n  token?: string,\n): Headers {\n  const reqHeaders: Headers = Object.assign({}, headers, { Accept: '*/*' })\n  if (token) {\n    reqHeaders.Authorization = `Bearer ${token}`\n  }\n  return removeEmptyHeaders(reqHeaders)\n}\n\nexport function throwIfErrors(response: any): any {\n  if (response.error) {\n    if (response.error.message) throw new Error(response.error.message)\n    else throw new Error('Unknown jsonrpc error')\n  } else {\n    return response\n  }\n}\n\nexport function deleteHeaders(opts: AxiosRequestConfig): AxiosRequestConfig {\n  delete opts.headers\n  return opts\n}\n\nexport type LotusRpcEngineConfig = {\n  apiAddress?: string\n  token?: string\n  axiosOpts?: AxiosRequestConfig\n}\n\nexport default class LotusRpcEngine {\n  readonly apiAddress: string\n  readonly token?: string\n  readonly axiosOpts: AxiosRequestConfig\n  readonly headers: Headers\n\n  constructor(config?: LotusRpcEngineConfig) {\n    if (!config)\n      throw new Error(\n        'Must pass a config object to the LotusRpcEngine constructor.',\n      )\n    this.apiAddress = config.apiAddress || 'http://127.0.0.1:1234/rpc/v0'\n    this.token = config.token\n    this.headers = configureHeaders(config?.axiosOpts?.headers, config.token)\n    this.axiosOpts = deleteHeaders(config.axiosOpts || {})\n  }\n\n  async request<A = any>(method: string, ...params: any[]): Promise<A> {\n    const { data } = await axios.post(\n      this.apiAddress,\n      {\n        jsonrpc: '2.0',\n        method: `Filecoin.${method}`,\n        params,\n        id: 1,\n      },\n      {\n        headers: this.headers,\n        ...this.axiosOpts,\n      },\n    )\n    throwIfErrors(data)\n    return data.result\n  }\n}\n"]},"metadata":{},"sourceType":"module"}