{"ast":null,"code":"/* eslint-disable security/detect-object-injection */\nimport BigNumber from \"bignumber.js\";\nexport const assert = (assertion, sentence) => {\n  if (!assertion) {\n    throw new Error(`Failed assertion${sentence ? `: ${sentence}` : \"\"}`);\n  }\n\n  return true;\n};\n/**\n * The following is a set of rudimentary type validation functions.\n *\n * The main function is `assertType`, which accepts a type and a dictionary of\n * values.\n *\n * The type must be a string that matches the following pattern:\n *\n * ```\n * TYPE:\n *   | TYPE '|' TYPE\n *   | Array<TYPE>\n *   | TYPE[]\n *   | PRIMITIVE_TYPE\n *\n * PRIMITIVE_TYPE:\n *   | \"string\"\n *   | \"number\"\n *   | \"bigint\"\n *   | \"boolean\"\n *   | \"symbol\"\n *   | \"undefined\"\n *   | \"object\"\n *   | \"function\"\n *   | \"null\"\n *   | \"any\"\n *   | \"Buffer\"\n *   | \"BigNumber\"\n * ```\n *\n * Types are matched by a regex so '|' can't be used at multiple levels, e.g.\n * `string | Array<string | number>`.\n */\n\nexport const assertType = (type, objects) => {\n  if (isArrayType(type)) {\n    return assertArray(type, objects);\n  }\n\n  if (isUnionType(type)) {\n    return assertTypeUnion(type, objects);\n  }\n\n  return assertTypeCheck(is(type), objects, type);\n};\n\nconst typeOf = v => v === null ? \"null\" : BigNumber.isBigNumber(v) ? \"BigNumber\" : Buffer.isBuffer(v) ? \"Buffer\" : typeof v;\n\nconst assertTypeCheck = (type, objects, typeDescription) => {\n  for (const key of Object.keys(objects)) {\n    // eslint-disable-next-line security/detect-object-injection\n    const value = objects[key];\n\n    if (!type(value, key)) {\n      const readableType = Array.isArray(value) ? \"any[]\" : typeOf(value);\n      throw new Error(`Expected ${key} to be of type '${typeDescription}', instead got '${readableType}'.`);\n    }\n  }\n\n  return true;\n};\n\nconst is = type => v => type === \"any\" ? true : typeOf(v) === type;\n\nconst isUnionType = unionType => {\n  const types = unionType.split(\" | \");\n  return types.length > 1 ? types : false;\n};\n\nconst isArrayType = arrayType => {\n  // Check with simple string operations to avoid running slow RegExs if there\n  // isn't a match.\n  const isArray = arrayType.slice(0, 6) === \"Array<\" && arrayType.slice(-1) === \">\";\n\n  if (isArray) {\n    const arrayMatch = /^Array<(.*)>$/.exec(arrayType);\n\n    if (arrayMatch) {\n      const [, type] = arrayMatch;\n      return type;\n    }\n  }\n\n  const isBracketArray = arrayType.indexOf(\" \") === -1 && arrayType.slice(-2) === \"[]\";\n\n  if (isBracketArray) {\n    const bracketMatch = /^([^ ]*)\\[\\]$/.exec(arrayType);\n\n    if (bracketMatch) {\n      const [, type] = bracketMatch;\n      return type;\n    }\n  }\n\n  return false;\n};\n\nconst assertTypeUnion = (unionType, objects) => {\n  const types = unionType.split(\" | \");\n  return assertTypeCheck((v, key) => types.reduce((acc, type) => {\n    if (acc) {\n      return acc;\n    }\n\n    if (isArrayType(type)) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        assertArray(type, {\n          [key]: v\n        });\n        return true;\n      } catch (error) {\n        return false;\n      }\n    }\n\n    return is(type)(v);\n  }, false), objects, unionType);\n};\n\nconst assertArray = (arrayType, objects) => {\n  const type = isArrayType(arrayType);\n\n  if (!type) {\n    /* istanbul ignore next */\n\n    /* also checked when assertArray is called */\n    throw new Error(`Invalid array type ${arrayType}`);\n  }\n\n  for (const key of Object.keys(objects)) {\n    const value = objects[key];\n    assertTypeCheck(v => Array.isArray(v), {\n      value\n    }, \"any[]\");\n\n    for (let i = 0; i < value.length; i++) {\n      assertType(type, {\n        [`${key}[${i}]`]: value[i]\n      });\n    }\n  }\n\n  return true;\n};\n\nexport const assertObject = (fieldTypes, objects) => {\n  for (const key of Object.keys(objects)) {\n    const value = objects[key];\n\n    for (const field of Object.keys(fieldTypes)) {\n      if (typeof fieldTypes[field] === \"object\") {\n        assertObject(fieldTypes[field], {\n          [`${key}[\"${field}\"]`]: value[field]\n        });\n      } else if (typeof fieldTypes[field] === \"string\") {\n        assertType(fieldTypes[field], {\n          [`${key}[\"${field}\"]`]: value[field]\n        });\n      } else {\n        throw new Error(`Invalid object type definition ${typeof fieldTypes[field]}`);\n      }\n    }\n  }\n\n  return true;\n};","map":{"version":3,"sources":["../../src/assert.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* eslint-disable security/detect-object-injection */\nimport BigNumber from \"bignumber.js\";\nexport const assert = (assertion, sentence) => {\n    if (!assertion) {\n        throw new Error(`Failed assertion${sentence ? `: ${sentence}` : \"\"}`);\n    }\n    return true;\n};\n/**\n * The following is a set of rudimentary type validation functions.\n *\n * The main function is `assertType`, which accepts a type and a dictionary of\n * values.\n *\n * The type must be a string that matches the following pattern:\n *\n * ```\n * TYPE:\n *   | TYPE '|' TYPE\n *   | Array<TYPE>\n *   | TYPE[]\n *   | PRIMITIVE_TYPE\n *\n * PRIMITIVE_TYPE:\n *   | \"string\"\n *   | \"number\"\n *   | \"bigint\"\n *   | \"boolean\"\n *   | \"symbol\"\n *   | \"undefined\"\n *   | \"object\"\n *   | \"function\"\n *   | \"null\"\n *   | \"any\"\n *   | \"Buffer\"\n *   | \"BigNumber\"\n * ```\n *\n * Types are matched by a regex so '|' can't be used at multiple levels, e.g.\n * `string | Array<string | number>`.\n */\nexport const assertType = (type, objects) => {\n    if (isArrayType(type)) {\n        return assertArray(type, objects);\n    }\n    if (isUnionType(type)) {\n        return assertTypeUnion(type, objects);\n    }\n    return assertTypeCheck(is(type), objects, type);\n};\nconst typeOf = (v) => v === null\n    ? \"null\"\n    : BigNumber.isBigNumber(v)\n        ? \"BigNumber\"\n        : Buffer.isBuffer(v)\n            ? \"Buffer\"\n            : typeof v;\nconst assertTypeCheck = (type, objects, typeDescription) => {\n    for (const key of Object.keys(objects)) {\n        // eslint-disable-next-line security/detect-object-injection\n        const value = objects[key];\n        if (!type(value, key)) {\n            const readableType = Array.isArray(value) ? \"any[]\" : typeOf(value);\n            throw new Error(`Expected ${key} to be of type '${typeDescription}', instead got '${readableType}'.`);\n        }\n    }\n    return true;\n};\nconst is = (type) => (v) => type === \"any\" ? true : typeOf(v) === type;\nconst isUnionType = (unionType) => {\n    const types = unionType.split(\" | \");\n    return types.length > 1 ? types : false;\n};\nconst isArrayType = (arrayType) => {\n    // Check with simple string operations to avoid running slow RegExs if there\n    // isn't a match.\n    const isArray = arrayType.slice(0, 6) === \"Array<\" && arrayType.slice(-1) === \">\";\n    if (isArray) {\n        const arrayMatch = /^Array<(.*)>$/.exec(arrayType);\n        if (arrayMatch) {\n            const [, type] = arrayMatch;\n            return type;\n        }\n    }\n    const isBracketArray = arrayType.indexOf(\" \") === -1 && arrayType.slice(-2) === \"[]\";\n    if (isBracketArray) {\n        const bracketMatch = /^([^ ]*)\\[\\]$/.exec(arrayType);\n        if (bracketMatch) {\n            const [, type] = bracketMatch;\n            return type;\n        }\n    }\n    return false;\n};\nconst assertTypeUnion = (unionType, objects) => {\n    const types = unionType.split(\" | \");\n    return assertTypeCheck((v, key) => types.reduce((acc, type) => {\n        if (acc) {\n            return acc;\n        }\n        if (isArrayType(type)) {\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                assertArray(type, { [key]: v });\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        }\n        return is(type)(v);\n    }, false), objects, unionType);\n};\nconst assertArray = (arrayType, objects) => {\n    const type = isArrayType(arrayType);\n    if (!type) {\n        /* istanbul ignore next */ /* also checked when assertArray is called */\n        throw new Error(`Invalid array type ${arrayType}`);\n    }\n    for (const key of Object.keys(objects)) {\n        const value = objects[key];\n        assertTypeCheck((v) => Array.isArray(v), { value }, \"any[]\");\n        for (let i = 0; i < value.length; i++) {\n            assertType(type, { [`${key}[${i}]`]: value[i] });\n        }\n    }\n    return true;\n};\nexport const assertObject = (fieldTypes, objects) => {\n    for (const key of Object.keys(objects)) {\n        const value = objects[key];\n        for (const field of Object.keys(fieldTypes)) {\n            if (typeof fieldTypes[field] === \"object\") {\n                assertObject(fieldTypes[field], {\n                    [`${key}[\"${field}\"]`]: value[field],\n                });\n            }\n            else if (typeof fieldTypes[field] === \"string\") {\n                assertType(fieldTypes[field], {\n                    [`${key}[\"${field}\"]`]: value[field],\n                });\n            }\n            else {\n                throw new Error(`Invalid object type definition ${typeof fieldTypes[field]}`);\n            }\n        }\n    }\n    return true;\n};\n//# sourceMappingURL=assert.js.map"]},"metadata":{},"sourceType":"module"}