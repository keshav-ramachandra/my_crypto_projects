{"ast":null,"code":"const Bn = require('bn.js');\n\nconst Pipe = require('buffer-pipe');\n\nmodule.exports = {\n  encode,\n  decode,\n  write,\n  read,\n  readBn\n};\n\nfunction read(stream) {\n  return readBn(stream).toString();\n}\n\nfunction readBn(stream) {\n  const num = new Bn(0);\n  let shift = 0;\n  let byt;\n\n  while (true) {\n    byt = stream.read(1)[0];\n    num.ior(new Bn(byt & 0x7f).shln(shift));\n    shift += 7;\n\n    if (byt >> 7 === 0) {\n      break;\n    }\n  } // sign extend if negitive\n\n\n  if (byt & 0x40) {\n    num.setn(shift);\n  }\n\n  return num.fromTwos(shift);\n}\n\nfunction write(number, stream) {\n  let num = new Bn(number);\n  const isNeg = num.isNeg();\n\n  if (isNeg) {\n    // add 8 bits for padding\n    num = num.toTwos(num.bitLength() + 8);\n  }\n\n  while (true) {\n    const i = num.maskn(7).toNumber();\n    num.ishrn(7);\n\n    if (isNegOne(num) && (i & 0x40) !== 0 || num.isZero() && (i & 0x40) === 0) {\n      stream.write([i]);\n      break;\n    } else {\n      stream.write([i | 0x80]);\n    }\n  }\n\n  function isNegOne(num) {\n    return isNeg && num.toString(2).indexOf('0') < 0;\n  }\n}\n/**\n * LEB128 encodeds an interger\n * @param {String|Number} num\n * @return {Buffer}\n */\n\n\nfunction encode(num) {\n  const stream = new Pipe();\n  write(num, stream);\n  return stream.buffer;\n}\n/**\n * decodes a LEB128 encoded interger\n * @param {Buffer} buffer\n * @return {String}\n */\n\n\nfunction decode(buffer) {\n  const stream = new Pipe(buffer);\n  return read(stream);\n}","map":{"version":3,"sources":["/home/kesha/Downloads/ren-main/renApp/node_modules/leb128/signed.js"],"names":["Bn","require","Pipe","module","exports","encode","decode","write","read","readBn","stream","toString","num","shift","byt","ior","shln","setn","fromTwos","number","isNeg","toTwos","bitLength","i","maskn","toNumber","ishrn","isNegOne","isZero","indexOf","buffer"],"mappings":"AAAA,MAAMA,EAAE,GAAGC,OAAO,CAAC,OAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,aAAD,CAApB;;AAEAE,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,MADe;AAEfC,EAAAA,MAFe;AAGfC,EAAAA,KAHe;AAIfC,EAAAA,IAJe;AAKfC,EAAAA;AALe,CAAjB;;AAQA,SAASD,IAAT,CAAeE,MAAf,EAAuB;AACrB,SAAOD,MAAM,CAACC,MAAD,CAAN,CAAeC,QAAf,EAAP;AACD;;AAED,SAASF,MAAT,CAAiBC,MAAjB,EAAyB;AACvB,QAAME,GAAG,GAAG,IAAIZ,EAAJ,CAAO,CAAP,CAAZ;AACA,MAAIa,KAAK,GAAG,CAAZ;AACA,MAAIC,GAAJ;;AACA,SAAO,IAAP,EAAa;AACXA,IAAAA,GAAG,GAAGJ,MAAM,CAACF,IAAP,CAAY,CAAZ,EAAe,CAAf,CAAN;AACAI,IAAAA,GAAG,CAACG,GAAJ,CAAQ,IAAIf,EAAJ,CAAOc,GAAG,GAAG,IAAb,EAAmBE,IAAnB,CAAwBH,KAAxB,CAAR;AACAA,IAAAA,KAAK,IAAI,CAAT;;AACA,QAAIC,GAAG,IAAI,CAAP,KAAa,CAAjB,EAAoB;AAClB;AACD;AACF,GAXsB,CAYvB;;;AACA,MAAIA,GAAG,GAAG,IAAV,EAAgB;AACdF,IAAAA,GAAG,CAACK,IAAJ,CAASJ,KAAT;AACD;;AACD,SAAOD,GAAG,CAACM,QAAJ,CAAaL,KAAb,CAAP;AACD;;AAED,SAASN,KAAT,CAAgBY,MAAhB,EAAwBT,MAAxB,EAAgC;AAC9B,MAAIE,GAAG,GAAG,IAAIZ,EAAJ,CAAOmB,MAAP,CAAV;AACA,QAAMC,KAAK,GAAGR,GAAG,CAACQ,KAAJ,EAAd;;AACA,MAAIA,KAAJ,EAAW;AACT;AACAR,IAAAA,GAAG,GAAGA,GAAG,CAACS,MAAJ,CAAWT,GAAG,CAACU,SAAJ,KAAkB,CAA7B,CAAN;AACD;;AACD,SAAO,IAAP,EAAa;AACX,UAAMC,CAAC,GAAGX,GAAG,CAACY,KAAJ,CAAU,CAAV,EAAaC,QAAb,EAAV;AACAb,IAAAA,GAAG,CAACc,KAAJ,CAAU,CAAV;;AACA,QAAKC,QAAQ,CAACf,GAAD,CAAR,IAAiB,CAACW,CAAC,GAAG,IAAL,MAAe,CAAjC,IACDX,GAAG,CAACgB,MAAJ,MAAgB,CAACL,CAAC,GAAG,IAAL,MAAe,CADlC,EACsC;AACpCb,MAAAA,MAAM,CAACH,KAAP,CAAa,CAACgB,CAAD,CAAb;AACA;AACD,KAJD,MAIO;AACLb,MAAAA,MAAM,CAACH,KAAP,CAAa,CAACgB,CAAC,GAAG,IAAL,CAAb;AACD;AACF;;AAED,WAASI,QAAT,CAAmBf,GAAnB,EAAwB;AACtB,WAAOQ,KAAK,IAAIR,GAAG,CAACD,QAAJ,CAAa,CAAb,EAAgBkB,OAAhB,CAAwB,GAAxB,IAA+B,CAA/C;AACD;AACF;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASxB,MAAT,CAAiBO,GAAjB,EAAsB;AACpB,QAAMF,MAAM,GAAG,IAAIR,IAAJ,EAAf;AACAK,EAAAA,KAAK,CAACK,GAAD,EAAMF,MAAN,CAAL;AACA,SAAOA,MAAM,CAACoB,MAAd;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASxB,MAAT,CAAiBwB,MAAjB,EAAyB;AACvB,QAAMpB,MAAM,GAAG,IAAIR,IAAJ,CAAS4B,MAAT,CAAf;AACA,SAAOtB,IAAI,CAACE,MAAD,CAAX;AACD","sourcesContent":["const Bn = require('bn.js')\nconst Pipe = require('buffer-pipe')\n\nmodule.exports = {\n  encode,\n  decode,\n  write,\n  read,\n  readBn\n}\n\nfunction read (stream) {\n  return readBn(stream).toString()\n}\n\nfunction readBn (stream) {\n  const num = new Bn(0)\n  let shift = 0\n  let byt\n  while (true) {\n    byt = stream.read(1)[0]\n    num.ior(new Bn(byt & 0x7f).shln(shift))\n    shift += 7\n    if (byt >> 7 === 0) {\n      break\n    }\n  }\n  // sign extend if negitive\n  if (byt & 0x40) {\n    num.setn(shift)\n  }\n  return num.fromTwos(shift)\n}\n\nfunction write (number, stream) {\n  let num = new Bn(number)\n  const isNeg = num.isNeg()\n  if (isNeg) {\n    // add 8 bits for padding\n    num = num.toTwos(num.bitLength() + 8)\n  }\n  while (true) {\n    const i = num.maskn(7).toNumber()\n    num.ishrn(7)\n    if ((isNegOne(num) && (i & 0x40) !== 0) ||\n      (num.isZero() && (i & 0x40) === 0)) {\n      stream.write([i])\n      break\n    } else {\n      stream.write([i | 0x80])\n    }\n  }\n\n  function isNegOne (num) {\n    return isNeg && num.toString(2).indexOf('0') < 0\n  }\n}\n\n/**\n * LEB128 encodeds an interger\n * @param {String|Number} num\n * @return {Buffer}\n */\nfunction encode (num) {\n  const stream = new Pipe()\n  write(num, stream)\n  return stream.buffer\n}\n\n/**\n * decodes a LEB128 encoded interger\n * @param {Buffer} buffer\n * @return {String}\n */\nfunction decode (buffer) {\n  const stream = new Pipe(buffer)\n  return read(stream)\n}\n"]},"metadata":{},"sourceType":"script"}