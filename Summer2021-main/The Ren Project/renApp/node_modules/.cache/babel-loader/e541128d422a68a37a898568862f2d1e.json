{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RenVMProvider = exports.resolveV2Contract = void 0;\n\nconst interfaces_1 = require(\"@renproject/interfaces\");\n\nconst provider_1 = require(\"@renproject/provider\");\n\nconst utils_1 = require(\"@renproject/utils\");\n\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n\nconst methods_1 = require(\"./methods\");\n\nconst pack_1 = require(\"./pack/pack\");\n\nconst transaction_1 = require(\"./transaction\");\n\nconst unmarshal_1 = require(\"./unmarshal\");\n\nconst resolveV2Contract = ({\n  asset,\n  from,\n  to\n}) => {\n  if (from.assetIsNative && from.assetIsNative(asset)) {\n    return `${asset}/to${to.name}`;\n  }\n\n  if (to.assetIsNative && to.assetIsNative(asset)) {\n    return `${asset}/from${from.name}`;\n  }\n\n  return `${asset}/from${from.name}To${to.name}`;\n};\n\nexports.resolveV2Contract = resolveV2Contract;\n\nclass RenVMProvider {\n  constructor(network, provider, logger = interfaces_1.NullLogger) {\n    this.version = () => 2;\n\n    this.selector = params => {\n      return exports.resolveV2Contract(params);\n    };\n\n    this.queryBlock = async (blockHeight, retry) => this.sendMessage(methods_1.RPCMethod.QueryBlock, {\n      blockHeight\n    }, retry);\n\n    this.queryBlocks = async (blockHeight, n, retry) => this.sendMessage(methods_1.RPCMethod.QueryBlocks, {\n      blockHeight,\n      n\n    }, retry);\n\n    this.submitGateway = async (gateway, tx, retry) => this.sendMessage(methods_1.RPCMethod.SubmitGateway, {\n      gateway,\n      tx\n    }, retry);\n\n    this.submitTx = async (tx, retry) => this.sendMessage(methods_1.RPCMethod.SubmitTx, {\n      tx\n    }, retry);\n\n    this.queryTx = async (txHash, retry) => this.sendMessage(methods_1.RPCMethod.QueryTx, {\n      txHash\n    }, retry);\n\n    this.queryTxs = async (tags, page, pageSize, txStatus, retry) => this.sendMessage(methods_1.RPCMethod.QueryTxs, {\n      tags,\n      page: (page || 0).toString(),\n      pageSize: (pageSize || 0).toString(),\n      txStatus\n    }, retry);\n\n    this.queryConfig = async retry => this.sendMessage(methods_1.RPCMethod.QueryConfig, {}, retry);\n\n    this.queryState = async retry => this.sendMessage(methods_1.RPCMethod.QueryState, {}, retry);\n\n    this.buildGateway = ({\n      selector,\n      gHash,\n      gPubKey,\n      nHash,\n      nonce,\n      payload,\n      pHash,\n      to,\n      transactionVersion\n    }) => {\n      utils_1.assertType(\"Buffer\", {\n        gHash,\n        gPubKey,\n        nHash,\n        nonce,\n        payload,\n        pHash\n      });\n      utils_1.assertType(\"string\", {\n        to\n      });\n      const version = utils_1.isDefined(transactionVersion) ? String(transactionVersion) : \"1\";\n      const txIn = {\n        t: transaction_1.submitGatewayType(),\n        v: {\n          ghash: utils_1.toURLBase64(gHash),\n          gpubkey: utils_1.toURLBase64(gPubKey),\n          nhash: utils_1.toURLBase64(nHash),\n          nonce: utils_1.toURLBase64(nonce),\n          payload: utils_1.toURLBase64(payload),\n          phash: utils_1.toURLBase64(pHash),\n          to\n        }\n      };\n      return {\n        selector: selector,\n        version,\n        // TODO: Fix types\n        in: txIn\n      };\n    };\n\n    this.buildTransaction = ({\n      selector,\n      gHash,\n      gPubKey,\n      nHash,\n      nonce,\n      output,\n      amount,\n      payload,\n      pHash,\n      to,\n      transactionVersion\n    }) => {\n      utils_1.assertType(\"Buffer\", {\n        gHash,\n        gPubKey,\n        nHash,\n        nonce,\n        payload,\n        pHash,\n        txid: output.txid\n      });\n      utils_1.assertType(\"string\", {\n        to,\n        amount,\n        txindex: output.txindex\n      });\n      const version = utils_1.isDefined(transactionVersion) ? String(transactionVersion) : \"1\";\n      const txIn = {\n        t: transaction_1.mintParamsType(),\n        v: {\n          txid: utils_1.toURLBase64(output.txid),\n          txindex: output.txindex,\n          ghash: utils_1.toURLBase64(gHash),\n          gpubkey: utils_1.toURLBase64(gPubKey),\n          nhash: utils_1.toURLBase64(nHash),\n          nonce: utils_1.toURLBase64(nonce),\n          payload: utils_1.toURLBase64(payload),\n          phash: utils_1.toURLBase64(pHash),\n          to,\n          amount\n        }\n      };\n      return {\n        hash: utils_1.toURLBase64(transaction_1.hashTransaction(version, selector, txIn)),\n        selector: selector,\n        version,\n        // TODO: Fix types\n        in: txIn\n      };\n    };\n\n    this.mintTxHash = params => {\n      return utils_1.fromBase64(this.buildTransaction(params).hash);\n    };\n\n    this.submitMint = async (params, retries) => {\n      const tx = this.buildTransaction(params);\n      await this.submitTx(tx, retries);\n      return utils_1.fromBase64(tx.hash);\n    };\n\n    this.submitGatewayDetails = async (gateway, params, retries) => {\n      const tx = this.buildGateway(params);\n      await this.submitGateway(gateway, tx, retries);\n      return gateway;\n    };\n\n    this.burnTxHash = this.mintTxHash;\n    this.submitBurn = this.submitMint;\n    /**\n     * Queries the result of a RenVM transaction and unmarshals the result into\n     * a [[LockAndMintTransaction]] or [[BurnAndReleaseTransaction]].\n     *\n     * @param renVMTxHash The transaction hash as a Buffer.\n     */\n\n    this.queryMintOrBurn = async (_selector, renVMTxHash, retries) => {\n      try {\n        const response = await this.queryTx(utils_1.toURLBase64(renVMTxHash), retries); // Unmarshal transaction.\n        // TODO: Improve mint/burn detection. Currently checks if the format\n        // is `ASSET/toChain` or `ASSET/fromChainToChain`. It may return\n        // a false positive if the chain name contains `To`.\n\n        const isMint = /((\\/to)|(To))/.exec(response.tx.selector);\n\n        if (isMint) {\n          return unmarshal_1.unmarshalMintTx(response);\n        } else {\n          return unmarshal_1.unmarshalBurnTx(response);\n        }\n      } catch (error) {\n        throw error;\n      }\n    };\n    /**\n     * Fetches the result of a RenVM transaction on a repeated basis until the\n     * transaction's status is `\"done\"`.\n     *\n     * @param utxoTxHash The transaction hash as a Buffer.\n     * @param onStatus A callback called each time the status of the transaction\n     * is refreshed - even if it hasn't changed.\n     * @param _cancelRequested A function that returns `true` to cancel the\n     * loop.\n     */\n\n\n    this.waitForTX = async (selector, utxoTxHash, onStatus, _cancelRequested, timeout) => {\n      utils_1.assertType(\"Buffer\", {\n        utxoTxHash\n      });\n      let rawResponse;\n\n      while (true) {\n        if (_cancelRequested && _cancelRequested()) {\n          throw new Error(`waitForTX cancelled.`);\n        }\n\n        try {\n          const result = await this.queryMintOrBurn(selector, utxoTxHash);\n\n          if (result && result.txStatus === interfaces_1.TxStatus.TxStatusDone) {\n            rawResponse = result;\n            break;\n          } else if (onStatus && result && result.txStatus) {\n            onStatus(result.txStatus);\n          }\n        } catch (error) {\n          if (/(not found)|(not available)/.exec(String((error || {}).message))) {// ignore\n          } else {\n            this.logger.error(String(error)); // TODO: throw unexpected errors\n          }\n        }\n\n        await utils_1.sleep(utils_1.isDefined(timeout) ? timeout : 15 * utils_1.SECONDS);\n      }\n\n      return rawResponse;\n    };\n    /**\n     * selectPublicKey fetches the public key for the RenVM shard handling\n     * the provided contract.\n     *\n     * @param chain The chain for which the public key should be fetched.\n     * @returns The public key hash (20 bytes) as a string.\n     */\n\n\n    this.selectPublicKey = async (_selector, chain) => {\n      // Call the ren_queryShards RPC.\n      const response = await this.queryState(5);\n      return utils_1.fromBase64(response.state[chain].pubKey);\n    }; // In the future, this will be asynchronous. It returns a promise for\n    // compatibility.\n    // eslint-disable-next-line @typescript-eslint/require-await\n\n\n    this.getNetwork = async _selector => {\n      return this.network;\n    };\n\n    this.getConfirmationTarget = async (_selector, chain) => {\n      const renVMConfig = await this.sendMessage(methods_1.RPCMethod.QueryConfig, {});\n      return parseInt(renVMConfig.confirmations[chain.name], 10);\n    };\n\n    this.estimateTransactionFee = async (asset, _lockChain, hostChain) => {\n      const renVMState = await this.sendMessage(methods_1.RPCMethod.QueryBlockState, {});\n      const blockState = pack_1.unmarshalTypedPackValue(renVMState.state);\n\n      if (!blockState[asset]) {\n        throw new Error(`No fee details found for ${asset}`);\n      }\n\n      const {\n        gasLimit,\n        gasCap\n      } = blockState[asset];\n      const fee = new bignumber_js_1.default(gasLimit).times(new bignumber_js_1.default(gasCap));\n      const mintAndBurnFees = blockState[asset].fees.chains.filter(chainFees => chainFees.chain === hostChain.name)[0];\n      return {\n        lock: fee,\n        release: fee,\n        mint: mintAndBurnFees && mintAndBurnFees.mintFee ? mintAndBurnFees.mintFee.toNumber() : 15,\n        burn: mintAndBurnFees && mintAndBurnFees.burnFee ? mintAndBurnFees.burnFee.toNumber() : 15\n      };\n    };\n\n    if (!provider || typeof provider === \"string\") {\n      const rpcUrl = provider || (interfaces_1.getRenNetworkDetails(network) || {}).lightnode;\n\n      try {\n        provider = new provider_1.HttpProvider(rpcUrl, logger);\n      } catch (error) {\n        if (/Invalid node URL/.exec(String(error && error.message))) {\n          throw new Error(`Invalid network or provider URL: \"${(interfaces_1.getRenNetworkDetails(network) || {}).name || String(network)}\"`);\n        }\n\n        throw error;\n      }\n    }\n\n    this.network = network;\n    this.logger = logger;\n    this.provider = provider;\n    this.sendMessage = this.provider.sendMessage;\n  }\n\n}\n\nexports.RenVMProvider = RenVMProvider;","map":{"version":3,"sources":["../../../src/v2/renVMProvider.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,YAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAaA,MAAA,UAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAQA,MAAA,cAAA,GAAA,eAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AAGA,MAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAaA,MAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAOA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAEO,MAAM,iBAAiB,GAAG,CAAC;AAC9B,EAAA,KAD8B;AAE9B,EAAA,IAF8B;AAG9B,EAAA;AAH8B,CAAD,KAUpB;AACT,MACK,IAAkB,CAAC,aAAnB,IACA,IAAkB,CAAC,aAAnB,CAAiC,KAAjC,CAFL,EAGE;AACE,WAAO,GAAG,KAAK,MAAM,EAAE,CAAC,IAAI,EAA5B;AACH;;AACD,MACK,EAAgB,CAAC,aAAjB,IACA,EAAgB,CAAC,aAAjB,CAA+B,KAA/B,CAFL,EAGE;AACE,WAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,IAAI,EAAhC;AACH;;AACD,SAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,IAAI,EAA5C;AACH,CAxBM;;AAAM,OAAA,CAAA,iBAAA,GAAiB,iBAAjB;;AA0Bb,MAAa,aAAb,CAA0B;AAWtB,EAAA,WAAA,CACI,OADJ,EAEI,QAFJ,EAGI,MAAA,GAAiB,YAAA,CAAA,UAHrB,EAG+B;AAXxB,SAAA,OAAA,GAAU,MAAM,CAAhB;;AAwCA,SAAA,QAAA,GAAY,MAAD,IAML;AACT,aAAO,OAAA,CAAA,iBAAA,CAAkB,MAAlB,CAAP;AACH,KARM;;AAUA,SAAA,UAAA,GAAa,OAChB,WADgB,EAEhB,KAFgB,KAIhB,KAAK,WAAL,CACI,SAAA,CAAA,SAAA,CAAU,UADd,EAEI;AAAE,MAAA;AAAF,KAFJ,EAGI,KAHJ,CAJG;;AAUA,SAAA,WAAA,GAAc,OACjB,WADiB,EAEjB,CAFiB,EAGjB,KAHiB,KAKjB,KAAK,WAAL,CACI,SAAA,CAAA,SAAA,CAAU,WADd,EAEI;AAAE,MAAA,WAAF;AAAe,MAAA;AAAf,KAFJ,EAGI,KAHJ,CALG;;AAWA,SAAA,aAAA,GAAgB,OACnB,OADmB,EAEnB,EAFmB,EAGnB,KAHmB,KAKnB,KAAK,WAAL,CACI,SAAA,CAAA,SAAA,CAAU,aADd,EAEI;AAAE,MAAA,OAAF;AAAW,MAAA;AAAX,KAFJ,EAGI,KAHJ,CALG;;AAWA,SAAA,QAAA,GAAW,OACd,EADc,EAEd,KAFc,KAId,KAAK,WAAL,CACI,SAAA,CAAA,SAAA,CAAU,QADd,EAEI;AAAE,MAAA;AAAF,KAFJ,EAGI,KAHJ,CAJG;;AAUA,SAAA,OAAA,GAAU,OAAO,MAAP,EAAwC,KAAxC,KACb,KAAK,WAAL,CACI,SAAA,CAAA,SAAA,CAAU,OADd,EAEI;AAAE,MAAA;AAAF,KAFJ,EAGI,KAHJ,CADG;;AAOA,SAAA,QAAA,GAAW,OACd,IADc,EAEd,IAFc,EAGd,QAHc,EAId,QAJc,EAKd,KALc,KAOd,KAAK,WAAL,CACI,SAAA,CAAA,SAAA,CAAU,QADd,EAEI;AACI,MAAA,IADJ;AAEI,MAAA,IAAI,EAAE,CAAC,IAAI,IAAI,CAAT,EAAY,QAAZ,EAFV;AAGI,MAAA,QAAQ,EAAE,CAAC,QAAQ,IAAI,CAAb,EAAgB,QAAhB,EAHd;AAII,MAAA;AAJJ,KAFJ,EAQI,KARJ,CAPG;;AAkBA,SAAA,WAAA,GAAc,MAAO,KAAP,IACjB,KAAK,WAAL,CACI,SAAA,CAAA,SAAA,CAAU,WADd,EAEI,EAFJ,EAGI,KAHJ,CADG;;AAOA,SAAA,UAAA,GAAa,MAAO,KAAP,IAChB,KAAK,WAAL,CAAuC,SAAA,CAAA,SAAA,CAAU,UAAjD,EAA6D,EAA7D,EAAiE,KAAjE,CADG;;AAGA,SAAA,YAAA,GAAe,CAAC;AACnB,MAAA,QADmB;AAEnB,MAAA,KAFmB;AAGnB,MAAA,OAHmB;AAInB,MAAA,KAJmB;AAKnB,MAAA,KALmB;AAMnB,MAAA,OANmB;AAOnB,MAAA,KAPmB;AAQnB,MAAA,EARmB;AASnB,MAAA;AATmB,KAAD,KAoBG;AACrB,MAAA,OAAA,CAAA,UAAA,CAAmB,QAAnB,EAA6B;AACzB,QAAA,KADyB;AAEzB,QAAA,OAFyB;AAGzB,QAAA,KAHyB;AAIzB,QAAA,KAJyB;AAKzB,QAAA,OALyB;AAMzB,QAAA;AANyB,OAA7B;AAQA,MAAA,OAAA,CAAA,UAAA,CAAmB,QAAnB,EAA6B;AAAE,QAAA;AAAF,OAA7B;AACA,YAAM,OAAO,GAAG,OAAA,CAAA,SAAA,CAAU,kBAAV,IACV,MAAM,CAAC,kBAAD,CADI,GAEV,GAFN;AAGA,YAAM,IAAI,GAAG;AACT,QAAA,CAAC,EAAE,aAAA,CAAA,iBAAA,EADM;AAET,QAAA,CAAC,EAAE;AACC,UAAA,KAAK,EAAE,OAAA,CAAA,WAAA,CAAY,KAAZ,CADR;AAEC,UAAA,OAAO,EAAE,OAAA,CAAA,WAAA,CAAY,OAAZ,CAFV;AAGC,UAAA,KAAK,EAAE,OAAA,CAAA,WAAA,CAAY,KAAZ,CAHR;AAIC,UAAA,KAAK,EAAE,OAAA,CAAA,WAAA,CAAY,KAAZ,CAJR;AAKC,UAAA,OAAO,EAAE,OAAA,CAAA,WAAA,CAAY,OAAZ,CALV;AAMC,UAAA,KAAK,EAAE,OAAA,CAAA,WAAA,CAAY,KAAZ,CANR;AAOC,UAAA;AAPD;AAFM,OAAb;AAYA,aAAO;AACH,QAAA,QAAQ,EAAE,QADP;AAEH,QAAA,OAFG;AAGH;AACA,QAAA,EAAE,EAAE;AAJD,OAAP;AAMH,KAnDM;;AAqDA,SAAA,gBAAA,GAAmB,CAAC;AACvB,MAAA,QADuB;AAEvB,MAAA,KAFuB;AAGvB,MAAA,OAHuB;AAIvB,MAAA,KAJuB;AAKvB,MAAA,KALuB;AAMvB,MAAA,MANuB;AAOvB,MAAA,MAPuB;AAQvB,MAAA,OARuB;AASvB,MAAA,KATuB;AAUvB,MAAA,EAVuB;AAWvB,MAAA;AAXuB,KAAD,KAwBC;AACvB,MAAA,OAAA,CAAA,UAAA,CAAmB,QAAnB,EAA6B;AACzB,QAAA,KADyB;AAEzB,QAAA,OAFyB;AAGzB,QAAA,KAHyB;AAIzB,QAAA,KAJyB;AAKzB,QAAA,OALyB;AAMzB,QAAA,KANyB;AAOzB,QAAA,IAAI,EAAE,MAAM,CAAC;AAPY,OAA7B;AASA,MAAA,OAAA,CAAA,UAAA,CAAmB,QAAnB,EAA6B;AAAE,QAAA,EAAF;AAAM,QAAA,MAAN;AAAc,QAAA,OAAO,EAAE,MAAM,CAAC;AAA9B,OAA7B;AACA,YAAM,OAAO,GAAG,OAAA,CAAA,SAAA,CAAU,kBAAV,IACV,MAAM,CAAC,kBAAD,CADI,GAEV,GAFN;AAGA,YAAM,IAAI,GAAG;AACT,QAAA,CAAC,EAAE,aAAA,CAAA,cAAA,EADM;AAET,QAAA,CAAC,EAAE;AACC,UAAA,IAAI,EAAE,OAAA,CAAA,WAAA,CAAY,MAAM,CAAC,IAAnB,CADP;AAEC,UAAA,OAAO,EAAE,MAAM,CAAC,OAFjB;AAGC,UAAA,KAAK,EAAE,OAAA,CAAA,WAAA,CAAY,KAAZ,CAHR;AAIC,UAAA,OAAO,EAAE,OAAA,CAAA,WAAA,CAAY,OAAZ,CAJV;AAKC,UAAA,KAAK,EAAE,OAAA,CAAA,WAAA,CAAY,KAAZ,CALR;AAMC,UAAA,KAAK,EAAE,OAAA,CAAA,WAAA,CAAY,KAAZ,CANR;AAOC,UAAA,OAAO,EAAE,OAAA,CAAA,WAAA,CAAY,OAAZ,CAPV;AAQC,UAAA,KAAK,EAAE,OAAA,CAAA,WAAA,CAAY,KAAZ,CARR;AASC,UAAA,EATD;AAUC,UAAA;AAVD;AAFM,OAAb;AAeA,aAAO;AACH,QAAA,IAAI,EAAE,OAAA,CAAA,WAAA,CAAY,aAAA,CAAA,eAAA,CAAgB,OAAhB,EAAyB,QAAzB,EAAmC,IAAnC,CAAZ,CADH;AAEH,QAAA,QAAQ,EAAE,QAFP;AAGH,QAAA,OAHG;AAIH;AACA,QAAA,EAAE,EAAE;AALD,OAAP;AAOH,KA5DM;;AA8DA,SAAA,UAAA,GAAc,MAAD,IAYP;AACT,aAAO,OAAA,CAAA,UAAA,CAAW,KAAK,gBAAL,CAAsB,MAAtB,EAA8B,IAAzC,CAAP;AACH,KAdM;;AAgBA,SAAA,UAAA,GAAa,OAChB,MADgB,EAchB,OAdgB,KAeC;AACjB,YAAM,EAAE,GAAG,KAAK,gBAAL,CAAsB,MAAtB,CAAX;AACA,YAAM,KAAK,QAAL,CAAc,EAAd,EAAkB,OAAlB,CAAN;AACA,aAAO,OAAA,CAAA,UAAA,CAAW,EAAE,CAAC,IAAd,CAAP;AACH,KAnBM;;AAqBA,SAAA,oBAAA,GAAuB,OAC1B,OAD0B,EAE1B,MAF0B,EAa1B,OAb0B,KAcT;AACjB,YAAM,EAAE,GAAG,KAAK,YAAL,CAAkB,MAAlB,CAAX;AACA,YAAM,KAAK,aAAL,CAAmB,OAAnB,EAA4B,EAA5B,EAAgC,OAAhC,CAAN;AACA,aAAO,OAAP;AACH,KAlBM;;AAoBA,SAAA,UAAA,GAAa,KAAK,UAAlB;AACA,SAAA,UAAA,GAAa,KAAK,UAAlB;AAEP;;;;;AAKG;;AACa,SAAA,eAAA,GAAkB,OAG9B,SAH8B,EAI9B,WAJ8B,EAK9B,OAL8B,KAMlB;AACZ,UAAI;AACA,cAAM,QAAQ,GAAG,MAAM,KAAK,OAAL,CACnB,OAAA,CAAA,WAAA,CAAY,WAAZ,CADmB,EAEnB,OAFmB,CAAvB,CADA,CAMA;AACA;AACA;AACA;;AACA,cAAM,MAAM,GAAG,gBAAgB,IAAhB,CAAqB,QAAQ,CAAC,EAAT,CAAY,QAAjC,CAAf;;AAEA,YAAI,MAAJ,EAAY;AACR,iBAAO,WAAA,CAAA,eAAA,CAAgB,QAAhB,CAAP;AACH,SAFD,MAEO;AACH,iBAAO,WAAA,CAAA,eAAA,CAAgB,QAAhB,CAAP;AACH;AACJ,OAjBD,CAiBE,OAAO,KAAP,EAAc;AACZ,cAAM,KAAN;AACH;AACJ,KA3Be;AA6BhB;;;;;;;;;AASG;;;AACa,SAAA,SAAA,GAAY,OAGxB,QAHwB,EAIxB,UAJwB,EAKxB,QALwB,EAMxB,gBANwB,EAOxB,OAPwB,KAQZ;AACZ,MAAA,OAAA,CAAA,UAAA,CAAmB,QAAnB,EAA6B;AAAE,QAAA;AAAF,OAA7B;AACA,UAAI,WAAJ;;AACA,aAAO,IAAP,EAAa;AACT,YAAI,gBAAgB,IAAI,gBAAgB,EAAxC,EAA4C;AACxC,gBAAM,IAAI,KAAJ,CAAU,sBAAV,CAAN;AACH;;AAED,YAAI;AACA,gBAAM,MAAM,GAAG,MAAM,KAAK,eAAL,CACjB,QADiB,EAEjB,UAFiB,CAArB;;AAIA,cAAI,MAAM,IAAI,MAAM,CAAC,QAAP,KAAoB,YAAA,CAAA,QAAA,CAAS,YAA3C,EAAyD;AACrD,YAAA,WAAW,GAAG,MAAd;AACA;AACH,WAHD,MAGO,IAAI,QAAQ,IAAI,MAAZ,IAAsB,MAAM,CAAC,QAAjC,EAA2C;AAC9C,YAAA,QAAQ,CAAC,MAAM,CAAC,QAAR,CAAR;AACH;AACJ,SAXD,CAWE,OAAO,KAAP,EAAc;AACZ,cACI,8BAA8B,IAA9B,CACI,MAAM,CAAC,CAAC,KAAK,IAAI,EAAV,EAAc,OAAf,CADV,CADJ,EAIE,CACE;AACH,WAND,MAMO;AACH,iBAAK,MAAL,CAAY,KAAZ,CAAkB,MAAM,CAAC,KAAD,CAAxB,EADG,CAEH;AACH;AACJ;;AACD,cAAM,OAAA,CAAA,KAAA,CAAM,OAAA,CAAA,SAAA,CAAU,OAAV,IAAqB,OAArB,GAA+B,KAAK,OAAA,CAAA,OAA1C,CAAN;AACH;;AACD,aAAO,WAAP;AACH,KA1Ce;AA4ChB;;;;;;AAMG;;;AACa,SAAA,eAAA,GAAkB,OAC9B,SAD8B,EAE9B,KAF8B,KAGb;AACjB;AACA,YAAM,QAAQ,GAAG,MAAM,KAAK,UAAL,CAAgB,CAAhB,CAAvB;AACA,aAAO,OAAA,CAAA,UAAA,CAAW,QAAQ,CAAC,KAAT,CAAe,KAAf,EAAsB,MAAjC,CAAP;AACH,KAPe,CAnYe,CA4Y/B;AACA;AACA;;;AACO,SAAA,UAAA,GAAa,MAAO,SAAP,IAAiD;AACjE,aAAO,KAAK,OAAZ;AACH,KAFM;;AAIA,SAAA,qBAAA,GAAwB,OAC3B,SAD2B,EAE3B,KAF2B,KAG3B;AACA,YAAM,WAAW,GAAG,MAAM,KAAK,WAAL,CAAiB,SAAA,CAAA,SAAA,CAAU,WAA3B,EAAwC,EAAxC,CAA1B;AACA,aAAO,QAAQ,CAAC,WAAW,CAAC,aAAZ,CAA0B,KAAK,CAAC,IAAhC,CAAD,EAAwC,EAAxC,CAAf;AACH,KANM;;AAQA,SAAA,sBAAA,GAAyB,OAC5B,KAD4B,EAE5B,UAF4B,EAG5B,SAH4B,KAS3B;AACD,YAAM,UAAU,GAAG,MAAM,KAAK,WAAL,CACrB,SAAA,CAAA,SAAA,CAAU,eADW,EAErB,EAFqB,CAAzB;AAKA,YAAM,UAAU,GAAe,MAAA,CAAA,uBAAA,CAC3B,UAAU,CAAC,KADgB,CAA/B;;AAIA,UAAI,CAAC,UAAU,CAAC,KAAD,CAAf,EAAwB;AACpB,cAAM,IAAI,KAAJ,CAAU,4BAA4B,KAAK,EAA3C,CAAN;AACH;;AAED,YAAM;AAAE,QAAA,QAAF;AAAY,QAAA;AAAZ,UAAuB,UAAU,CAAC,KAAD,CAAvC;AACA,YAAM,GAAG,GAAG,IAAI,cAAA,CAAA,OAAJ,CAAc,QAAd,EAAwB,KAAxB,CAA8B,IAAI,cAAA,CAAA,OAAJ,CAAc,MAAd,CAA9B,CAAZ;AAEA,YAAM,eAAe,GAAG,UAAU,CAAC,KAAD,CAAV,CAAkB,IAAlB,CAAuB,MAAvB,CAA8B,MAA9B,CACnB,SAAD,IAAe,SAAS,CAAC,KAAV,KAAoB,SAAS,CAAC,IADzB,EAEtB,CAFsB,CAAxB;AAIA,aAAO;AACH,QAAA,IAAI,EAAE,GADH;AAEH,QAAA,OAAO,EAAE,GAFN;AAIH,QAAA,IAAI,EACA,eAAe,IAAI,eAAe,CAAC,OAAnC,GACM,eAAe,CAAC,OAAhB,CAAwB,QAAxB,EADN,GAEM,EAPP;AAQH,QAAA,IAAI,EACA,eAAe,IAAI,eAAe,CAAC,OAAnC,GACM,eAAe,CAAC,OAAhB,CAAwB,QAAxB,EADN,GAEM;AAXP,OAAP;AAaH,KA3CM;;AAzZH,QAAI,CAAC,QAAD,IAAa,OAAO,QAAP,KAAoB,QAArC,EAA+C;AAC3C,YAAM,MAAM,GACR,QAAQ,IAAI,CAAC,YAAA,CAAA,oBAAA,CAAqB,OAArB,KAAiC,EAAlC,EAAsC,SADtD;;AAEA,UAAI;AACA,QAAA,QAAQ,GAAG,IAAI,UAAA,CAAA,YAAJ,CACP,MADO,EAEP,MAFO,CAAX;AAIH,OALD,CAKE,OAAO,KAAP,EAAc;AACZ,YAAI,mBAAmB,IAAnB,CAAwB,MAAM,CAAC,KAAK,IAAI,KAAK,CAAC,OAAhB,CAA9B,CAAJ,EAA6D;AACzD,gBAAM,IAAI,KAAJ,CACF,qCACI,CAAC,YAAA,CAAA,oBAAA,CAAqB,OAArB,KAAiC,EAAlC,EAAsC,IAAtC,IACA,MAAM,CAAC,OAAD,CACV,GAJE,CAAN;AAMH;;AACD,cAAM,KAAN;AACH;AACJ;;AAED,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,MAAL,GAAc,MAAd;AACA,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,WAAL,GAAmB,KAAK,QAAL,CAAc,WAAjC;AACH;;AAzCqB;;AAA1B,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RenVMProvider = exports.resolveV2Contract = void 0;\nconst interfaces_1 = require(\"@renproject/interfaces\");\nconst provider_1 = require(\"@renproject/provider\");\nconst utils_1 = require(\"@renproject/utils\");\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst methods_1 = require(\"./methods\");\nconst pack_1 = require(\"./pack/pack\");\nconst transaction_1 = require(\"./transaction\");\nconst unmarshal_1 = require(\"./unmarshal\");\nconst resolveV2Contract = ({ asset, from, to, }) => {\n    if (from.assetIsNative &&\n        from.assetIsNative(asset)) {\n        return `${asset}/to${to.name}`;\n    }\n    if (to.assetIsNative &&\n        to.assetIsNative(asset)) {\n        return `${asset}/from${from.name}`;\n    }\n    return `${asset}/from${from.name}To${to.name}`;\n};\nexports.resolveV2Contract = resolveV2Contract;\nclass RenVMProvider {\n    constructor(network, provider, logger = interfaces_1.NullLogger) {\n        this.version = () => 2;\n        this.selector = (params) => {\n            return exports.resolveV2Contract(params);\n        };\n        this.queryBlock = async (blockHeight, retry) => this.sendMessage(methods_1.RPCMethod.QueryBlock, { blockHeight }, retry);\n        this.queryBlocks = async (blockHeight, n, retry) => this.sendMessage(methods_1.RPCMethod.QueryBlocks, { blockHeight, n }, retry);\n        this.submitGateway = async (gateway, tx, retry) => this.sendMessage(methods_1.RPCMethod.SubmitGateway, { gateway, tx }, retry);\n        this.submitTx = async (tx, retry) => this.sendMessage(methods_1.RPCMethod.SubmitTx, { tx }, retry);\n        this.queryTx = async (txHash, retry) => this.sendMessage(methods_1.RPCMethod.QueryTx, { txHash }, retry);\n        this.queryTxs = async (tags, page, pageSize, txStatus, retry) => this.sendMessage(methods_1.RPCMethod.QueryTxs, {\n            tags,\n            page: (page || 0).toString(),\n            pageSize: (pageSize || 0).toString(),\n            txStatus,\n        }, retry);\n        this.queryConfig = async (retry) => this.sendMessage(methods_1.RPCMethod.QueryConfig, {}, retry);\n        this.queryState = async (retry) => this.sendMessage(methods_1.RPCMethod.QueryState, {}, retry);\n        this.buildGateway = ({ selector, gHash, gPubKey, nHash, nonce, payload, pHash, to, transactionVersion, }) => {\n            utils_1.assertType(\"Buffer\", {\n                gHash,\n                gPubKey,\n                nHash,\n                nonce,\n                payload,\n                pHash,\n            });\n            utils_1.assertType(\"string\", { to });\n            const version = utils_1.isDefined(transactionVersion)\n                ? String(transactionVersion)\n                : \"1\";\n            const txIn = {\n                t: transaction_1.submitGatewayType(),\n                v: {\n                    ghash: utils_1.toURLBase64(gHash),\n                    gpubkey: utils_1.toURLBase64(gPubKey),\n                    nhash: utils_1.toURLBase64(nHash),\n                    nonce: utils_1.toURLBase64(nonce),\n                    payload: utils_1.toURLBase64(payload),\n                    phash: utils_1.toURLBase64(pHash),\n                    to,\n                },\n            };\n            return {\n                selector: selector,\n                version,\n                // TODO: Fix types\n                in: txIn,\n            };\n        };\n        this.buildTransaction = ({ selector, gHash, gPubKey, nHash, nonce, output, amount, payload, pHash, to, transactionVersion, }) => {\n            utils_1.assertType(\"Buffer\", {\n                gHash,\n                gPubKey,\n                nHash,\n                nonce,\n                payload,\n                pHash,\n                txid: output.txid,\n            });\n            utils_1.assertType(\"string\", { to, amount, txindex: output.txindex });\n            const version = utils_1.isDefined(transactionVersion)\n                ? String(transactionVersion)\n                : \"1\";\n            const txIn = {\n                t: transaction_1.mintParamsType(),\n                v: {\n                    txid: utils_1.toURLBase64(output.txid),\n                    txindex: output.txindex,\n                    ghash: utils_1.toURLBase64(gHash),\n                    gpubkey: utils_1.toURLBase64(gPubKey),\n                    nhash: utils_1.toURLBase64(nHash),\n                    nonce: utils_1.toURLBase64(nonce),\n                    payload: utils_1.toURLBase64(payload),\n                    phash: utils_1.toURLBase64(pHash),\n                    to,\n                    amount,\n                },\n            };\n            return {\n                hash: utils_1.toURLBase64(transaction_1.hashTransaction(version, selector, txIn)),\n                selector: selector,\n                version,\n                // TODO: Fix types\n                in: txIn,\n            };\n        };\n        this.mintTxHash = (params) => {\n            return utils_1.fromBase64(this.buildTransaction(params).hash);\n        };\n        this.submitMint = async (params, retries) => {\n            const tx = this.buildTransaction(params);\n            await this.submitTx(tx, retries);\n            return utils_1.fromBase64(tx.hash);\n        };\n        this.submitGatewayDetails = async (gateway, params, retries) => {\n            const tx = this.buildGateway(params);\n            await this.submitGateway(gateway, tx, retries);\n            return gateway;\n        };\n        this.burnTxHash = this.mintTxHash;\n        this.submitBurn = this.submitMint;\n        /**\n         * Queries the result of a RenVM transaction and unmarshals the result into\n         * a [[LockAndMintTransaction]] or [[BurnAndReleaseTransaction]].\n         *\n         * @param renVMTxHash The transaction hash as a Buffer.\n         */\n        this.queryMintOrBurn = async (_selector, renVMTxHash, retries) => {\n            try {\n                const response = await this.queryTx(utils_1.toURLBase64(renVMTxHash), retries);\n                // Unmarshal transaction.\n                // TODO: Improve mint/burn detection. Currently checks if the format\n                // is `ASSET/toChain` or `ASSET/fromChainToChain`. It may return\n                // a false positive if the chain name contains `To`.\n                const isMint = /((\\/to)|(To))/.exec(response.tx.selector);\n                if (isMint) {\n                    return unmarshal_1.unmarshalMintTx(response);\n                }\n                else {\n                    return unmarshal_1.unmarshalBurnTx(response);\n                }\n            }\n            catch (error) {\n                throw error;\n            }\n        };\n        /**\n         * Fetches the result of a RenVM transaction on a repeated basis until the\n         * transaction's status is `\"done\"`.\n         *\n         * @param utxoTxHash The transaction hash as a Buffer.\n         * @param onStatus A callback called each time the status of the transaction\n         * is refreshed - even if it hasn't changed.\n         * @param _cancelRequested A function that returns `true` to cancel the\n         * loop.\n         */\n        this.waitForTX = async (selector, utxoTxHash, onStatus, _cancelRequested, timeout) => {\n            utils_1.assertType(\"Buffer\", { utxoTxHash });\n            let rawResponse;\n            while (true) {\n                if (_cancelRequested && _cancelRequested()) {\n                    throw new Error(`waitForTX cancelled.`);\n                }\n                try {\n                    const result = await this.queryMintOrBurn(selector, utxoTxHash);\n                    if (result && result.txStatus === interfaces_1.TxStatus.TxStatusDone) {\n                        rawResponse = result;\n                        break;\n                    }\n                    else if (onStatus && result && result.txStatus) {\n                        onStatus(result.txStatus);\n                    }\n                }\n                catch (error) {\n                    if (/(not found)|(not available)/.exec(String((error || {}).message))) {\n                        // ignore\n                    }\n                    else {\n                        this.logger.error(String(error));\n                        // TODO: throw unexpected errors\n                    }\n                }\n                await utils_1.sleep(utils_1.isDefined(timeout) ? timeout : 15 * utils_1.SECONDS);\n            }\n            return rawResponse;\n        };\n        /**\n         * selectPublicKey fetches the public key for the RenVM shard handling\n         * the provided contract.\n         *\n         * @param chain The chain for which the public key should be fetched.\n         * @returns The public key hash (20 bytes) as a string.\n         */\n        this.selectPublicKey = async (_selector, chain) => {\n            // Call the ren_queryShards RPC.\n            const response = await this.queryState(5);\n            return utils_1.fromBase64(response.state[chain].pubKey);\n        };\n        // In the future, this will be asynchronous. It returns a promise for\n        // compatibility.\n        // eslint-disable-next-line @typescript-eslint/require-await\n        this.getNetwork = async (_selector) => {\n            return this.network;\n        };\n        this.getConfirmationTarget = async (_selector, chain) => {\n            const renVMConfig = await this.sendMessage(methods_1.RPCMethod.QueryConfig, {});\n            return parseInt(renVMConfig.confirmations[chain.name], 10);\n        };\n        this.estimateTransactionFee = async (asset, _lockChain, hostChain) => {\n            const renVMState = await this.sendMessage(methods_1.RPCMethod.QueryBlockState, {});\n            const blockState = pack_1.unmarshalTypedPackValue(renVMState.state);\n            if (!blockState[asset]) {\n                throw new Error(`No fee details found for ${asset}`);\n            }\n            const { gasLimit, gasCap } = blockState[asset];\n            const fee = new bignumber_js_1.default(gasLimit).times(new bignumber_js_1.default(gasCap));\n            const mintAndBurnFees = blockState[asset].fees.chains.filter((chainFees) => chainFees.chain === hostChain.name)[0];\n            return {\n                lock: fee,\n                release: fee,\n                mint: mintAndBurnFees && mintAndBurnFees.mintFee\n                    ? mintAndBurnFees.mintFee.toNumber()\n                    : 15,\n                burn: mintAndBurnFees && mintAndBurnFees.burnFee\n                    ? mintAndBurnFees.burnFee.toNumber()\n                    : 15,\n            };\n        };\n        if (!provider || typeof provider === \"string\") {\n            const rpcUrl = provider || (interfaces_1.getRenNetworkDetails(network) || {}).lightnode;\n            try {\n                provider = new provider_1.HttpProvider(rpcUrl, logger);\n            }\n            catch (error) {\n                if (/Invalid node URL/.exec(String(error && error.message))) {\n                    throw new Error(`Invalid network or provider URL: \"${(interfaces_1.getRenNetworkDetails(network) || {}).name ||\n                        String(network)}\"`);\n                }\n                throw error;\n            }\n        }\n        this.network = network;\n        this.logger = logger;\n        this.provider = provider;\n        this.sendMessage = this.provider.sendMessage;\n    }\n}\nexports.RenVMProvider = RenVMProvider;\n//# sourceMappingURL=renVMProvider.js.map"]},"metadata":{},"sourceType":"script"}