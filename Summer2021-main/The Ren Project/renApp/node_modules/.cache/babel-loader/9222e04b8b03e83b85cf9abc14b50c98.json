{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { NullLogger } from \"@renproject/interfaces\";\nimport { assert, assertType, extractError, fromHex, isDefined, isHex, Ox, payloadToABI, payloadToMintABI, SECONDS, sleep } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport BN from \"bn.js\"; // import BlocknativeSdk from \"bnc-sdk\";\n// import {\n//     EthereumTransactionData,\n//     EthereumTransactionLog,\n// } from \"bnc-sdk/dist/types/src/interfaces\";\n\nimport { isValidAddress, isValidChecksumAddress } from \"ethereumjs-util\";\nimport { keccak256 as web3Keccak256 } from \"web3-utils\";\nexport const ignorePromiEventError = error => {\n  try {\n    return !!(error && error.message && (/Invalid block number/.exec(error.message) || /Timeout exceeded during the transaction confirmation process./.exec(error.message)));\n  } catch (innerError) {\n    return false;\n  }\n};\n/**\n * Forward the events emitted by a Web3 PromiEvent to another PromiEvent.\n */\n\nexport const forwardWeb3Events = (src, dest) => {\n  // eslint-disable-next-line no-void\n  void src.on(\"transactionHash\", eventReceipt => {\n    dest.emit(\"transactionHash\", eventReceipt);\n    dest.emit(\"eth_transactionHash\", eventReceipt);\n  }); // eslint-disable-next-line no-void\n\n  void src.on(\"receipt\", eventReceipt => {\n    dest.emit(\"receipt\", eventReceipt);\n    dest.emit(\"eth_receipt\", eventReceipt);\n  }); // eslint-disable-next-line no-void\n\n  void src.on(\"confirmation\", (confNumber, eventReceipt) => {\n    dest.emit(\"confirmation\", confNumber, eventReceipt);\n    dest.emit(\"eth_confirmation\", confNumber, eventReceipt);\n  }); // Don't forward - instead these should be listened for and thrown.\n  // // eslint-disable-next-line no-void\n  // void src.on(\"error\", (error: Error) => {\n  //     dest.emit(\"error\", error);\n  // });\n};\n/**\n * eventTopics contains the Ethereum event identifiers (the first log topic) for\n * Gateway contract events.\n */\n\nexport const eventTopics = {\n  /**\n   * ```js\n   * event LogBurn(\n   *     bytes _to,\n   *     uint256 _amount,\n   *     uint256 indexed _n,\n   *     bytes indexed _indexedTo\n   *  );\n   * ```\n   */\n  LogBurn: web3Keccak256(\"LogBurn(bytes,uint256,uint256,bytes)\"),\n\n  /**\n   * ```js\n   * event LogMint(\n   *     address indexed _to,\n   *     uint256 _amount,\n   *     uint256 indexed _n,\n   *     bytes32 indexed _signedMessageHash\n   * );\n   * ```\n   */\n  LogMint: web3Keccak256(\"LogMint(address,uint256,uint256,bytes32)\")\n};\n/**\n * Waits for the receipt of a transaction to be available, retrying every 3\n * seconds until it is.\n *\n * @param web3 A web3 instance.\n * @param txHash The hash of the transaction being read.\n */\n\nexport const waitForReceipt = (web3, txHash, logger, timeout) => __awaiter(void 0, void 0, void 0, function* () {\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\n    assertType(\"string\", {\n      txHash\n    }); // let blocknative;\n    // try {\n    //     // Initialize Blocknative SDK.\n    //     blocknative = new BlocknativeSdk({\n    //         dappId: \"6b3d07f1-b158-4cf1-99ec-919b11fe3654\", // Public RenJS key.\n    //         networkId: await web3.eth.net.getId(),\n    //     });\n    //     const { emitter } = blocknative.transaction(txHash);\n    //     emitter.on(\"txSpeedUp\", (state) => {\n    //         if (\n    //             (state as EthereumTransactionData | EthereumTransactionLog)\n    //                 .hash\n    //         ) {\n    //             txHash = Ox(\n    //                 (state as\n    //                     | EthereumTransactionData\n    //                     | EthereumTransactionLog).hash,\n    //             );\n    //         }\n    //     });\n    //     emitter.on(\"txCancel\", () => {\n    //         reject(new Error(\"Ethereum transaction was cancelled.\"));\n    //     });\n    // } catch (error) {\n    //     // Ignore blocknative error.\n    // }\n    // Wait for confirmation\n\n    let receipt;\n\n    while (!receipt || !receipt.blockHash) {\n      if (logger) {\n        logger.debug(`Fetching transaction receipt: ${txHash}`);\n      }\n\n      receipt = yield web3.eth.getTransactionReceipt(txHash);\n\n      if (receipt && receipt.blockHash) {\n        break;\n      }\n\n      yield sleep(isDefined(timeout) ? timeout : 15 * SECONDS);\n    } // try {\n    //     // Destroy blocknative SDK.\n    //     if (blocknative) {\n    //         blocknative.unsubscribe(txHash);\n    //         blocknative.destroy();\n    //     }\n    // } catch (error) {\n    //     // Ignore blocknative error.\n    // }\n    // Status might be undefined - so check against `false` explicitly.\n\n\n    if (receipt.status === false) {\n      reject(new Error(`Transaction was reverted. { \"transactionHash\": \"${txHash}\" }`));\n      return;\n    }\n\n    resolve(receipt);\n    return;\n  }));\n});\nexport const parseBurnEvent = (web3, event) => {\n  assert(event.topics[0] === eventTopics.LogBurn);\n  const {\n    _to,\n    _amount,\n    _n\n  } = web3.eth.abi.decodeLog([{\n    indexed: false,\n    name: \"_to\",\n    type: \"bytes\"\n  }, {\n    indexed: false,\n    name: \"_amount\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    name: \"_n\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    name: \"_indexedTo\",\n    type: \"bytes\"\n  }], event.data, event.topics.slice(1));\n  return {\n    transaction: event.transactionHash,\n    amount: new BigNumber(_amount.toString()),\n    to: fromHex(_to).toString(),\n    nonce: new BigNumber(_n.toString())\n  };\n};\nexport const extractBurnDetails = (web3, txHash, logger, timeout) => __awaiter(void 0, void 0, void 0, function* () {\n  assertType(\"string\", {\n    txHash\n  });\n  const receipt = yield waitForReceipt(web3, txHash, logger, timeout);\n\n  if (!receipt.logs) {\n    throw Error(\"No events found in transaction\");\n  }\n\n  const burnDetails = receipt.logs.filter(event => event.topics[0] === eventTopics.LogBurn).map(event => parseBurnEvent(web3, event));\n\n  if (burnDetails.length > 1) {// WARNING: More than one burn found.\n  }\n\n  if (burnDetails.length) {\n    return burnDetails[0];\n  }\n\n  throw Error(\"No reference ID found in logs\");\n});\nexport const getGatewayAddress = (network, web3, asset) => __awaiter(void 0, void 0, void 0, function* () {\n  try {\n    const getGatewayBySymbol = {\n      constant: true,\n      inputs: [{\n        internalType: \"string\",\n        name: \"_tokenSymbol\",\n        type: \"string\"\n      }],\n      name: \"getGatewayBySymbol\",\n      outputs: [{\n        internalType: \"contract IGateway\",\n        name: \"\",\n        type: \"address\"\n      }],\n      payable: false,\n      stateMutability: \"view\",\n      type: \"function\"\n    };\n    const registry = new web3.eth.Contract([getGatewayBySymbol], network.addresses.GatewayRegistry);\n    const registryAddress = yield registry.methods.getGatewayBySymbol(asset).call();\n\n    if (!registryAddress) {\n      throw new Error(`Empty address returned.`);\n    }\n\n    return registryAddress;\n  } catch (error) {\n    (error || {}).message = `Error looking up ${asset} gateway address${error.message ? `: ${String(error.message)}` : \".\"}`;\n    throw error;\n  }\n});\nexport const findBurnByNonce = (network, web3, asset, nonce) => __awaiter(void 0, void 0, void 0, function* () {\n  const gatewayAddress = yield getGatewayAddress(network, web3, asset);\n  const nonceBuffer = Buffer.isBuffer(nonce) ? Buffer.from(nonce) : new BN(nonce).toArrayLike(Buffer, \"be\", 32);\n  const burnEvents = yield web3.eth.getPastLogs({\n    address: gatewayAddress,\n    fromBlock: \"1\",\n    toBlock: \"latest\",\n    topics: [eventTopics.LogBurn, Ox(nonceBuffer)]\n  });\n\n  if (!burnEvents.length) {\n    throw Error(`Burn not found for nonce ${Ox(nonceBuffer)}`);\n  }\n\n  if (burnEvents.length > 1) {// WARNING: More than one burn with the same nonce.\n  }\n\n  return parseBurnEvent(web3, burnEvents[0]);\n});\nexport const defaultAccountError = \"No accounts found in Web3 wallet.\";\nexport const withDefaultAccount = (web3, config) => __awaiter(void 0, void 0, void 0, function* () {\n  if (!config.from) {\n    if (web3.eth.defaultAccount) {\n      config.from = web3.eth.defaultAccount;\n    } else {\n      const accounts = yield web3.eth.getAccounts();\n\n      if (accounts.length === 0) {\n        throw new Error(defaultAccountError);\n      }\n\n      config.from = accounts[0];\n    }\n  }\n\n  return config;\n});\n/**\n * Bind a promiEvent to an Ethereum transaction hash, sending confirmation\n * events. Web3 may export a similar function, which should be used instead if\n * it exists.\n *\n * @param web3 A Web3 instance for watching for confirmations.\n * @param txHash The Ethereum transaction has as a hex string.\n * @param promiEvent The existing promiEvent to forward events to.\n */\n\nexport const manualPromiEvent = (web3, txHash, promiEvent) => __awaiter(void 0, void 0, void 0, function* () {\n  assertType(\"string\", {\n    txHash\n  });\n  const receipt = yield web3.eth.getTransactionReceipt(txHash);\n  promiEvent.emit(\"transactionHash\", txHash);\n\n  const emitConfirmation = () => __awaiter(void 0, void 0, void 0, function* () {\n    const currentBlock = yield web3.eth.getBlockNumber();\n    promiEvent.emit(\"confirmation\", Math.max(0, currentBlock - receipt.blockNumber), // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    receipt);\n  }); // The following section should be revised to properly\n  // register the event emitter to the transaction's\n  // confirmations, so that on(\"confirmation\") works\n  // as expected. This code branch only occurs if a\n  // completed transfer is passed to RenJS again, which\n  // should not usually happen.\n  // Emit confirmation now and in 1s, since a common use\n  // case may be to have the following code, which doesn't\n  // work if we emit the txHash and confirmations\n  // with no time in between:\n  //\n  // ```js\n  // const txHash = await new Promise((resolve, reject) => lockAndMint.on(\"transactionHash\", resolve).catch(reject));\n  // lockAndMint.on(\"confirmation\", () => { /* do something */ });\n  // ```\n\n\n  yield emitConfirmation();\n  setTimeout(() => {\n    emitConfirmation().catch(console.error);\n  }, 1000);\n  return receipt;\n});\nexport const getTokenAddress = (network, web3, asset) => __awaiter(void 0, void 0, void 0, function* () {\n  try {\n    const getTokenBySymbolABI = {\n      constant: true,\n      inputs: [{\n        internalType: \"string\",\n        name: \"_tokenSymbol\",\n        type: \"string\"\n      }],\n      name: \"getTokenBySymbol\",\n      outputs: [{\n        internalType: \"contract IERC20\",\n        name: \"\",\n        type: \"address\"\n      }],\n      payable: false,\n      stateMutability: \"view\",\n      type: \"function\"\n    };\n    const registry = new web3.eth.Contract([getTokenBySymbolABI], network.addresses.GatewayRegistry);\n    const tokenAddress = yield registry.methods.getTokenBySymbol(asset).call();\n\n    if (!tokenAddress) {\n      throw new Error(`Empty address returned.`);\n    }\n\n    return tokenAddress;\n  } catch (error) {\n    (error || {}).message = `Error looking up ${asset} token address on ${network.chainLabel}${error.message ? `: ${String(error.message)}` : \".\"}`;\n    throw error;\n  }\n});\nexport const findTransactionBySigHash = (network, web3, asset, nHash, sigHash, blockLimit) => __awaiter(void 0, void 0, void 0, function* () {\n  let status;\n\n  try {\n    const gatewayAddress = yield getGatewayAddress(network, web3, asset);\n    const statusABI = {\n      constant: true,\n      inputs: [{\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\"\n      }],\n      name: \"status\",\n      outputs: [{\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }],\n      payable: false,\n      stateMutability: \"view\",\n      type: \"function\"\n    };\n    const gatewayContract = new web3.eth.Contract([statusABI], gatewayAddress);\n    let fromBlock = 1;\n    let toBlock = \"latest\";\n\n    if (blockLimit) {\n      toBlock = new BigNumber((yield web3.eth.getBlockNumber()).toString()).toNumber();\n      fromBlock = toBlock - blockLimit + 1;\n    }\n\n    const newMintEvents = yield web3.eth.getPastLogs({\n      address: gatewayAddress,\n      fromBlock,\n      toBlock,\n      topics: [eventTopics.LogMint, null, null, Ox(nHash)]\n    });\n\n    if (newMintEvents.length) {\n      return newMintEvents[0].transactionHash;\n    }\n\n    if (sigHash) {\n      // We can skip the `status` check and call `getPastLogs` directly - for now both are called in case\n      // the contract\n      status = yield gatewayContract.methods.status(Ox(sigHash)).call();\n\n      if (!status) {\n        return undefined;\n      }\n\n      const oldMintEvents = yield web3.eth.getPastLogs({\n        address: gatewayAddress,\n        fromBlock,\n        toBlock,\n        topics: [eventTopics.LogMint, null, null, Ox(sigHash)]\n      });\n\n      if (oldMintEvents.length) {\n        return oldMintEvents[0].transactionHash;\n      }\n    }\n  } catch (error) {\n    console.warn(error); // Continue with transaction\n  }\n\n  if (status) {\n    // The sigHash has already been used, but no transaction was found.\n    // Possible due to a restriction on the number logs that can be fetched,\n    // which is the case on BSC.\n    return \"\";\n  }\n\n  return;\n});\nexport const submitToEthereum = (web3, contractCalls, mintTx, eventEmitter, // config?: { [key: string]: unknown },\nlogger = NullLogger) => __awaiter(void 0, void 0, void 0, function* () {\n  if (!mintTx.out) {\n    throw new Error(`No result available from RenVM transaction.`);\n  }\n\n  if (mintTx.out.revert !== undefined) {\n    throw new Error(`Unable to submit reverted RenVM transaction.`);\n  }\n\n  if (!mintTx.out.signature) {\n    throw new Error(`No signature available from RenVM transaction.`);\n  }\n\n  let tx;\n\n  for (let i = 0; i < contractCalls.length; i++) {\n    const contractCall = contractCalls[i];\n    const last = i === contractCalls.length - 1;\n    const {\n      contractParams,\n      contractFn,\n      sendTo\n    } = contractCall;\n    const callParams = last ? [...(contractParams || []).map(value => value.value), Ox(new BigNumber(mintTx.out.amount).toString(16)), Ox(mintTx.out.nhash), Ox(mintTx.out.signature)] : (contractParams || []).map(value => value.value);\n    const ABI = last ? payloadToMintABI(contractFn, contractParams || []) : payloadToABI(contractFn, contractParams || []);\n    const contract = new web3.eth.Contract(ABI, sendTo);\n    const txConfig = typeof contractCall === \"object\" ? contractCall.txConfig : {};\n    const config = yield withDefaultAccount(web3, Object.assign(Object.assign({}, txConfig), {\n      value: txConfig && txConfig.value ? txConfig.value.toString() : undefined,\n      gasPrice: txConfig && txConfig.gasPrice ? txConfig.gasPrice.toString() : undefined\n    }));\n    logger.debug(\"Calling Ethereum contract\", contractFn, sendTo, ...callParams, config);\n    tx = contract.methods[contractFn](...callParams).send(config);\n\n    if (last && tx !== undefined) {\n      forwardWeb3Events(tx, eventEmitter);\n    }\n  }\n\n  return yield new Promise((innerResolve, reject) => {\n    if (tx === undefined) {\n      throw new Error(`Must provide contract call.`);\n    }\n\n    tx.once(\"confirmation\", (_confirmations, receipt) => {\n      innerResolve(receipt.transactionHash);\n    }).catch(error => {\n      try {\n        if (ignorePromiEventError(error)) {\n          logger.error(extractError(error));\n          return;\n        }\n      } catch (_error) {\n        /* Ignore _error */\n      }\n\n      reject(error);\n    });\n  });\n});\nexport const addressIsValid = address => {\n  if (/^.+\\.eth$/.exec(address)) {\n    return true;\n  }\n\n  if (/^0x[a-f0-9]{40}$/.exec(address)) {\n    return isValidAddress(address);\n  }\n\n  if (/^0x[a-fA-F0-9]{40}$/.exec(address)) {\n    return isValidChecksumAddress(address);\n  }\n\n  return false;\n};\nexport const transactionIsValid = transaction => transaction !== null && isHex(transaction, {\n  length: 32,\n  prefix: true\n});","map":{"version":3,"sources":["../../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { NullLogger, } from \"@renproject/interfaces\";\nimport { assert, assertType, extractError, fromHex, isDefined, isHex, Ox, payloadToABI, payloadToMintABI, SECONDS, sleep, } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport BN from \"bn.js\";\n// import BlocknativeSdk from \"bnc-sdk\";\n// import {\n//     EthereumTransactionData,\n//     EthereumTransactionLog,\n// } from \"bnc-sdk/dist/types/src/interfaces\";\nimport { isValidAddress, isValidChecksumAddress } from \"ethereumjs-util\";\nimport { keccak256 as web3Keccak256 } from \"web3-utils\";\nexport const ignorePromiEventError = (error) => {\n    try {\n        return !!(error &&\n            error.message &&\n            (/Invalid block number/.exec(error.message) ||\n                /Timeout exceeded during the transaction confirmation process./.exec(error.message)));\n    }\n    catch (innerError) {\n        return false;\n    }\n};\n/**\n * Forward the events emitted by a Web3 PromiEvent to another PromiEvent.\n */\nexport const forwardWeb3Events = (src, dest) => {\n    // eslint-disable-next-line no-void\n    void src.on(\"transactionHash\", (eventReceipt) => {\n        dest.emit(\"transactionHash\", eventReceipt);\n        dest.emit(\"eth_transactionHash\", eventReceipt);\n    });\n    // eslint-disable-next-line no-void\n    void src.on(\"receipt\", (eventReceipt) => {\n        dest.emit(\"receipt\", eventReceipt);\n        dest.emit(\"eth_receipt\", eventReceipt);\n    });\n    // eslint-disable-next-line no-void\n    void src.on(\"confirmation\", (confNumber, eventReceipt) => {\n        dest.emit(\"confirmation\", confNumber, eventReceipt);\n        dest.emit(\"eth_confirmation\", confNumber, eventReceipt);\n    });\n    // Don't forward - instead these should be listened for and thrown.\n    // // eslint-disable-next-line no-void\n    // void src.on(\"error\", (error: Error) => {\n    //     dest.emit(\"error\", error);\n    // });\n};\n/**\n * eventTopics contains the Ethereum event identifiers (the first log topic) for\n * Gateway contract events.\n */\nexport const eventTopics = {\n    /**\n     * ```js\n     * event LogBurn(\n     *     bytes _to,\n     *     uint256 _amount,\n     *     uint256 indexed _n,\n     *     bytes indexed _indexedTo\n     *  );\n     * ```\n     */\n    LogBurn: web3Keccak256(\"LogBurn(bytes,uint256,uint256,bytes)\"),\n    /**\n     * ```js\n     * event LogMint(\n     *     address indexed _to,\n     *     uint256 _amount,\n     *     uint256 indexed _n,\n     *     bytes32 indexed _signedMessageHash\n     * );\n     * ```\n     */\n    LogMint: web3Keccak256(\"LogMint(address,uint256,uint256,bytes32)\"),\n};\n/**\n * Waits for the receipt of a transaction to be available, retrying every 3\n * seconds until it is.\n *\n * @param web3 A web3 instance.\n * @param txHash The hash of the transaction being read.\n */\nexport const waitForReceipt = (web3, txHash, logger, timeout) => __awaiter(void 0, void 0, void 0, function* () {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\n        assertType(\"string\", { txHash });\n        // let blocknative;\n        // try {\n        //     // Initialize Blocknative SDK.\n        //     blocknative = new BlocknativeSdk({\n        //         dappId: \"6b3d07f1-b158-4cf1-99ec-919b11fe3654\", // Public RenJS key.\n        //         networkId: await web3.eth.net.getId(),\n        //     });\n        //     const { emitter } = blocknative.transaction(txHash);\n        //     emitter.on(\"txSpeedUp\", (state) => {\n        //         if (\n        //             (state as EthereumTransactionData | EthereumTransactionLog)\n        //                 .hash\n        //         ) {\n        //             txHash = Ox(\n        //                 (state as\n        //                     | EthereumTransactionData\n        //                     | EthereumTransactionLog).hash,\n        //             );\n        //         }\n        //     });\n        //     emitter.on(\"txCancel\", () => {\n        //         reject(new Error(\"Ethereum transaction was cancelled.\"));\n        //     });\n        // } catch (error) {\n        //     // Ignore blocknative error.\n        // }\n        // Wait for confirmation\n        let receipt;\n        while (!receipt || !receipt.blockHash) {\n            if (logger) {\n                logger.debug(`Fetching transaction receipt: ${txHash}`);\n            }\n            receipt = yield web3.eth.getTransactionReceipt(txHash);\n            if (receipt && receipt.blockHash) {\n                break;\n            }\n            yield sleep(isDefined(timeout) ? timeout : 15 * SECONDS);\n        }\n        // try {\n        //     // Destroy blocknative SDK.\n        //     if (blocknative) {\n        //         blocknative.unsubscribe(txHash);\n        //         blocknative.destroy();\n        //     }\n        // } catch (error) {\n        //     // Ignore blocknative error.\n        // }\n        // Status might be undefined - so check against `false` explicitly.\n        if (receipt.status === false) {\n            reject(new Error(`Transaction was reverted. { \"transactionHash\": \"${txHash}\" }`));\n            return;\n        }\n        resolve(receipt);\n        return;\n    }));\n});\nexport const parseBurnEvent = (web3, event) => {\n    assert(event.topics[0] === eventTopics.LogBurn);\n    const { _to, _amount, _n } = web3.eth.abi.decodeLog([\n        {\n            indexed: false,\n            name: \"_to\",\n            type: \"bytes\",\n        },\n        {\n            indexed: false,\n            name: \"_amount\",\n            type: \"uint256\",\n        },\n        {\n            indexed: true,\n            name: \"_n\",\n            type: \"uint256\",\n        },\n        {\n            indexed: true,\n            name: \"_indexedTo\",\n            type: \"bytes\",\n        },\n    ], event.data, event.topics.slice(1));\n    return {\n        transaction: event.transactionHash,\n        amount: new BigNumber(_amount.toString()),\n        to: fromHex(_to).toString(),\n        nonce: new BigNumber(_n.toString()),\n    };\n};\nexport const extractBurnDetails = (web3, txHash, logger, timeout) => __awaiter(void 0, void 0, void 0, function* () {\n    assertType(\"string\", { txHash });\n    const receipt = yield waitForReceipt(web3, txHash, logger, timeout);\n    if (!receipt.logs) {\n        throw Error(\"No events found in transaction\");\n    }\n    const burnDetails = receipt.logs\n        .filter((event) => event.topics[0] === eventTopics.LogBurn)\n        .map((event) => parseBurnEvent(web3, event));\n    if (burnDetails.length > 1) {\n        // WARNING: More than one burn found.\n    }\n    if (burnDetails.length) {\n        return burnDetails[0];\n    }\n    throw Error(\"No reference ID found in logs\");\n});\nexport const getGatewayAddress = (network, web3, asset) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const getGatewayBySymbol = {\n            constant: true,\n            inputs: [\n                {\n                    internalType: \"string\",\n                    name: \"_tokenSymbol\",\n                    type: \"string\",\n                },\n            ],\n            name: \"getGatewayBySymbol\",\n            outputs: [\n                {\n                    internalType: \"contract IGateway\",\n                    name: \"\",\n                    type: \"address\",\n                },\n            ],\n            payable: false,\n            stateMutability: \"view\",\n            type: \"function\",\n        };\n        const registry = new web3.eth.Contract([getGatewayBySymbol], network.addresses.GatewayRegistry);\n        const registryAddress = yield registry.methods\n            .getGatewayBySymbol(asset)\n            .call();\n        if (!registryAddress) {\n            throw new Error(`Empty address returned.`);\n        }\n        return registryAddress;\n    }\n    catch (error) {\n        (error || {}).message = `Error looking up ${asset} gateway address${error.message ? `: ${String(error.message)}` : \".\"}`;\n        throw error;\n    }\n});\nexport const findBurnByNonce = (network, web3, asset, nonce) => __awaiter(void 0, void 0, void 0, function* () {\n    const gatewayAddress = yield getGatewayAddress(network, web3, asset);\n    const nonceBuffer = Buffer.isBuffer(nonce)\n        ? Buffer.from(nonce)\n        : new BN(nonce).toArrayLike(Buffer, \"be\", 32);\n    const burnEvents = yield web3.eth.getPastLogs({\n        address: gatewayAddress,\n        fromBlock: \"1\",\n        toBlock: \"latest\",\n        topics: [eventTopics.LogBurn, Ox(nonceBuffer)],\n    });\n    if (!burnEvents.length) {\n        throw Error(`Burn not found for nonce ${Ox(nonceBuffer)}`);\n    }\n    if (burnEvents.length > 1) {\n        // WARNING: More than one burn with the same nonce.\n    }\n    return parseBurnEvent(web3, burnEvents[0]);\n});\nexport const defaultAccountError = \"No accounts found in Web3 wallet.\";\nexport const withDefaultAccount = (web3, config) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!config.from) {\n        if (web3.eth.defaultAccount) {\n            config.from = web3.eth.defaultAccount;\n        }\n        else {\n            const accounts = yield web3.eth.getAccounts();\n            if (accounts.length === 0) {\n                throw new Error(defaultAccountError);\n            }\n            config.from = accounts[0];\n        }\n    }\n    return config;\n});\n/**\n * Bind a promiEvent to an Ethereum transaction hash, sending confirmation\n * events. Web3 may export a similar function, which should be used instead if\n * it exists.\n *\n * @param web3 A Web3 instance for watching for confirmations.\n * @param txHash The Ethereum transaction has as a hex string.\n * @param promiEvent The existing promiEvent to forward events to.\n */\nexport const manualPromiEvent = (web3, txHash, promiEvent) => __awaiter(void 0, void 0, void 0, function* () {\n    assertType(\"string\", { txHash });\n    const receipt = yield web3.eth.getTransactionReceipt(txHash);\n    promiEvent.emit(\"transactionHash\", txHash);\n    const emitConfirmation = () => __awaiter(void 0, void 0, void 0, function* () {\n        const currentBlock = yield web3.eth.getBlockNumber();\n        promiEvent.emit(\"confirmation\", Math.max(0, currentBlock - receipt.blockNumber), \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        receipt);\n    });\n    // The following section should be revised to properly\n    // register the event emitter to the transaction's\n    // confirmations, so that on(\"confirmation\") works\n    // as expected. This code branch only occurs if a\n    // completed transfer is passed to RenJS again, which\n    // should not usually happen.\n    // Emit confirmation now and in 1s, since a common use\n    // case may be to have the following code, which doesn't\n    // work if we emit the txHash and confirmations\n    // with no time in between:\n    //\n    // ```js\n    // const txHash = await new Promise((resolve, reject) => lockAndMint.on(\"transactionHash\", resolve).catch(reject));\n    // lockAndMint.on(\"confirmation\", () => { /* do something */ });\n    // ```\n    yield emitConfirmation();\n    setTimeout(() => {\n        emitConfirmation().catch(console.error);\n    }, 1000);\n    return receipt;\n});\nexport const getTokenAddress = (network, web3, asset) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const getTokenBySymbolABI = {\n            constant: true,\n            inputs: [\n                {\n                    internalType: \"string\",\n                    name: \"_tokenSymbol\",\n                    type: \"string\",\n                },\n            ],\n            name: \"getTokenBySymbol\",\n            outputs: [\n                {\n                    internalType: \"contract IERC20\",\n                    name: \"\",\n                    type: \"address\",\n                },\n            ],\n            payable: false,\n            stateMutability: \"view\",\n            type: \"function\",\n        };\n        const registry = new web3.eth.Contract([getTokenBySymbolABI], network.addresses.GatewayRegistry);\n        const tokenAddress = yield registry.methods\n            .getTokenBySymbol(asset)\n            .call();\n        if (!tokenAddress) {\n            throw new Error(`Empty address returned.`);\n        }\n        return tokenAddress;\n    }\n    catch (error) {\n        (error || {}).message = `Error looking up ${asset} token address on ${network.chainLabel}${error.message ? `: ${String(error.message)}` : \".\"}`;\n        throw error;\n    }\n});\nexport const findTransactionBySigHash = (network, web3, asset, nHash, sigHash, blockLimit) => __awaiter(void 0, void 0, void 0, function* () {\n    let status;\n    try {\n        const gatewayAddress = yield getGatewayAddress(network, web3, asset);\n        const statusABI = {\n            constant: true,\n            inputs: [\n                {\n                    internalType: \"bytes32\",\n                    name: \"\",\n                    type: \"bytes32\",\n                },\n            ],\n            name: \"status\",\n            outputs: [\n                {\n                    internalType: \"bool\",\n                    name: \"\",\n                    type: \"bool\",\n                },\n            ],\n            payable: false,\n            stateMutability: \"view\",\n            type: \"function\",\n        };\n        const gatewayContract = new web3.eth.Contract([statusABI], gatewayAddress);\n        let fromBlock = 1;\n        let toBlock = \"latest\";\n        if (blockLimit) {\n            toBlock = new BigNumber((yield web3.eth.getBlockNumber()).toString()).toNumber();\n            fromBlock = toBlock - blockLimit + 1;\n        }\n        const newMintEvents = yield web3.eth.getPastLogs({\n            address: gatewayAddress,\n            fromBlock,\n            toBlock,\n            topics: [eventTopics.LogMint, null, null, Ox(nHash)],\n        });\n        if (newMintEvents.length) {\n            return newMintEvents[0].transactionHash;\n        }\n        if (sigHash) {\n            // We can skip the `status` check and call `getPastLogs` directly - for now both are called in case\n            // the contract\n            status = yield gatewayContract.methods.status(Ox(sigHash)).call();\n            if (!status) {\n                return undefined;\n            }\n            const oldMintEvents = yield web3.eth.getPastLogs({\n                address: gatewayAddress,\n                fromBlock,\n                toBlock,\n                topics: [\n                    eventTopics.LogMint,\n                    null,\n                    null,\n                    Ox(sigHash),\n                ],\n            });\n            if (oldMintEvents.length) {\n                return oldMintEvents[0].transactionHash;\n            }\n        }\n    }\n    catch (error) {\n        console.warn(error);\n        // Continue with transaction\n    }\n    if (status) {\n        // The sigHash has already been used, but no transaction was found.\n        // Possible due to a restriction on the number logs that can be fetched,\n        // which is the case on BSC.\n        return \"\";\n    }\n    return;\n});\nexport const submitToEthereum = (web3, contractCalls, mintTx, eventEmitter, \n// config?: { [key: string]: unknown },\nlogger = NullLogger) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!mintTx.out) {\n        throw new Error(`No result available from RenVM transaction.`);\n    }\n    if (mintTx.out.revert !== undefined) {\n        throw new Error(`Unable to submit reverted RenVM transaction.`);\n    }\n    if (!mintTx.out.signature) {\n        throw new Error(`No signature available from RenVM transaction.`);\n    }\n    let tx;\n    for (let i = 0; i < contractCalls.length; i++) {\n        const contractCall = contractCalls[i];\n        const last = i === contractCalls.length - 1;\n        const { contractParams, contractFn, sendTo } = contractCall;\n        const callParams = last\n            ? [\n                ...(contractParams || []).map((value) => value.value),\n                Ox(new BigNumber(mintTx.out.amount).toString(16)),\n                Ox(mintTx.out.nhash),\n                Ox(mintTx.out.signature),\n            ]\n            : (contractParams || []).map((value) => value.value);\n        const ABI = last\n            ? payloadToMintABI(contractFn, contractParams || [])\n            : payloadToABI(contractFn, contractParams || []);\n        const contract = new web3.eth.Contract(ABI, sendTo);\n        const txConfig = typeof contractCall === \"object\"\n            ? contractCall.txConfig\n            : {};\n        const config = yield withDefaultAccount(web3, Object.assign(Object.assign({}, txConfig), {\n            value: txConfig && txConfig.value\n                ? txConfig.value.toString()\n                : undefined,\n            gasPrice: txConfig && txConfig.gasPrice\n                ? txConfig.gasPrice.toString()\n                : undefined,\n        }));\n        logger.debug(\"Calling Ethereum contract\", contractFn, sendTo, ...callParams, config);\n        tx = contract.methods[contractFn](...callParams).send(config);\n        if (last && tx !== undefined) {\n            forwardWeb3Events(tx, eventEmitter);\n        }\n    }\n    return yield new Promise((innerResolve, reject) => {\n        if (tx === undefined) {\n            throw new Error(`Must provide contract call.`);\n        }\n        tx.once(\"confirmation\", (_confirmations, receipt) => {\n            innerResolve(receipt.transactionHash);\n        }).catch((error) => {\n            try {\n                if (ignorePromiEventError(error)) {\n                    logger.error(extractError(error));\n                    return;\n                }\n            }\n            catch (_error) {\n                /* Ignore _error */\n            }\n            reject(error);\n        });\n    });\n});\nexport const addressIsValid = (address) => {\n    if (/^.+\\.eth$/.exec(address)) {\n        return true;\n    }\n    if (/^0x[a-f0-9]{40}$/.exec(address)) {\n        return isValidAddress(address);\n    }\n    if (/^0x[a-fA-F0-9]{40}$/.exec(address)) {\n        return isValidChecksumAddress(address);\n    }\n    return false;\n};\nexport const transactionIsValid = (transaction) => transaction !== null && isHex(transaction, { length: 32, prefix: true });\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}