{"ast":null,"code":"import { LogLevel, NullLogger } from \"@renproject/interfaces\";\nimport BigNumber from \"bignumber.js\";\nimport { assertType } from \"./assert\";\nimport { fromHex, Ox } from \"./common\";\nimport { generateSighash } from \"./renVMHashes\";\nexport const signatureToBuffer = sig => Buffer.concat([sig.r, sig.s, Buffer.from([sig.v])]);\n\nconst switchV = v => v === 27 ? 28 : 27; // 28 - (v - 27);\n\n\nconst to32Bytes = bn => fromHex((\"0\".repeat(64) + bn.toString(16)).slice(-64));\n\nexport const secp256k1n = new BigNumber(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", 16);\nexport const fixSignatureSimple = (r, s, v) => {\n  assertType(\"Buffer\", {\n    r,\n    s\n  });\n  let sBN = new BigNumber(Ox(s), 16);\n  let vFixed = (v || 0) % 27 + 27; // For a given key, there are two valid signatures for each signed message.\n  // We always take the one with the lower `s`.\n  // secp256k1n/2 = 57896044618658097711785492504343953926418782139537452191302581570759080747168.5\n\n  if (sBN.gt(secp256k1n.div(2))) {\n    // Take s = -s % secp256k1n\n    sBN = secp256k1n.minus(sBN); // Switch v\n\n    vFixed = switchV(vFixed);\n  }\n\n  return {\n    r,\n    s: to32Bytes(sBN),\n    v: vFixed\n  };\n};\nexport const fixSignature = (r, s, v, sigHash, pHash, amount, to, tokenIdentifier, nHash, v2, logger = NullLogger) => {\n  // Type validation\n  assertType(\"string\", {\n    amount,\n    to,\n    tokenIdentifier\n  });\n  assertType(\"Buffer\", {\n    r,\n    s,\n    sigHash,\n    pHash,\n    nHash\n  });\n\n  if (typeof logger.level !== \"number\" || logger.level >= LogLevel.Warn) {\n    const expectedSighash = generateSighash(pHash, amount, to, tokenIdentifier, nHash, v2, logger);\n\n    if (Ox(sigHash) !== Ox(expectedSighash)) {\n      logger.warn(`Warning: unexpected signature hash returned from RenVM. Expected ${Ox(expectedSighash)}, got ${Ox(sigHash)}.`);\n    }\n  } // TODO: Fix code below to check against proper mintAuthority\n  // // Currently, the wrong `v` value may be returned from RenVM. We recover the\n  // // address to see if we need to switch `v`. This can be removed once RenVM\n  // // has been updated.\n  // const recovered = {\n  //     [v]: pubToAddress(ecrecover(\n  //         fromHex(response.autogen.sighash)),\n  //         v,\n  //         fromHex(r),\n  //         s.toArrayLike(Buffer, \"be\", 32),\n  //     )),\n  //     [switchV(v)]: pubToAddress(ecrecover(\n  //         fromHex(response.autogen.sighash),\n  //         switchV(v),\n  //         fromHex(r),\n  //         s.toArrayLike(Buffer, \"be\", 32),\n  //     )),\n  // };\n  // const expected = fromHex(.network.renVM.mintAuthority);\n  // if (recovered[v].equals(expected)) {\n  //     // Do nothing\n  // } else if (recovered[switchV(v)].equals(expected)) {\n  //     console.info(\"[info][ren-js] switching v value\");\n  //     v = switchV(v);\n  // } else {\n  //     throw new Error(`Invalid signature - unable to recover mint authority from signature (Expected ${Ox(expected)}, got ${Ox(recovered[v])})`);\n  // }\n\n\n  return fixSignatureSimple(r, s, v);\n};","map":{"version":3,"sources":["../../src/signatureUtils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { LogLevel, NullLogger } from \"@renproject/interfaces\";\nimport BigNumber from \"bignumber.js\";\nimport { assertType } from \"./assert\";\nimport { fromHex, Ox } from \"./common\";\nimport { generateSighash } from \"./renVMHashes\";\nexport const signatureToBuffer = (sig) => Buffer.concat([sig.r, sig.s, Buffer.from([sig.v])]);\nconst switchV = (v) => (v === 27 ? 28 : 27); // 28 - (v - 27);\nconst to32Bytes = (bn) => fromHex((\"0\".repeat(64) + bn.toString(16)).slice(-64));\nexport const secp256k1n = new BigNumber(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", 16);\nexport const fixSignatureSimple = (r, s, v) => {\n    assertType(\"Buffer\", { r, s });\n    let sBN = new BigNumber(Ox(s), 16);\n    let vFixed = ((v || 0) % 27) + 27;\n    // For a given key, there are two valid signatures for each signed message.\n    // We always take the one with the lower `s`.\n    // secp256k1n/2 = 57896044618658097711785492504343953926418782139537452191302581570759080747168.5\n    if (sBN.gt(secp256k1n.div(2))) {\n        // Take s = -s % secp256k1n\n        sBN = secp256k1n.minus(sBN);\n        // Switch v\n        vFixed = switchV(vFixed);\n    }\n    return {\n        r,\n        s: to32Bytes(sBN),\n        v: vFixed,\n    };\n};\nexport const fixSignature = (r, s, v, sigHash, pHash, amount, to, tokenIdentifier, nHash, v2, logger = NullLogger) => {\n    // Type validation\n    assertType(\"string\", { amount, to, tokenIdentifier });\n    assertType(\"Buffer\", { r, s, sigHash, pHash, nHash });\n    if (typeof logger.level !== \"number\" || logger.level >= LogLevel.Warn) {\n        const expectedSighash = generateSighash(pHash, amount, to, tokenIdentifier, nHash, v2, logger);\n        if (Ox(sigHash) !== Ox(expectedSighash)) {\n            logger.warn(`Warning: unexpected signature hash returned from RenVM. Expected ${Ox(expectedSighash)}, got ${Ox(sigHash)}.`);\n        }\n    }\n    // TODO: Fix code below to check against proper mintAuthority\n    // // Currently, the wrong `v` value may be returned from RenVM. We recover the\n    // // address to see if we need to switch `v`. This can be removed once RenVM\n    // // has been updated.\n    // const recovered = {\n    //     [v]: pubToAddress(ecrecover(\n    //         fromHex(response.autogen.sighash)),\n    //         v,\n    //         fromHex(r),\n    //         s.toArrayLike(Buffer, \"be\", 32),\n    //     )),\n    //     [switchV(v)]: pubToAddress(ecrecover(\n    //         fromHex(response.autogen.sighash),\n    //         switchV(v),\n    //         fromHex(r),\n    //         s.toArrayLike(Buffer, \"be\", 32),\n    //     )),\n    // };\n    // const expected = fromHex(.network.renVM.mintAuthority);\n    // if (recovered[v].equals(expected)) {\n    //     // Do nothing\n    // } else if (recovered[switchV(v)].equals(expected)) {\n    //     console.info(\"[info][ren-js] switching v value\");\n    //     v = switchV(v);\n    // } else {\n    //     throw new Error(`Invalid signature - unable to recover mint authority from signature (Expected ${Ox(expected)}, got ${Ox(recovered[v])})`);\n    // }\n    return fixSignatureSimple(r, s, v);\n};\n//# sourceMappingURL=signatureUtils.js.map"]},"metadata":{},"sourceType":"module"}