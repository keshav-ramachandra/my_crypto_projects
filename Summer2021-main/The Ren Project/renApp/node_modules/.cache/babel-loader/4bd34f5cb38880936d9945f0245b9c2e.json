{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport * as uint8arrays from 'uint8arrays';\n/* tslint:disable:no-bitwise */\n// From js-multibase (https://github.com/multiformats/js-multibase)\n\nfunction _decode(input, alphabet) {\n  input = input.replace(new RegExp('=', 'g'), '');\n  var _input = input,\n      length = _input.length;\n  var bits = 0;\n  var value = 0;\n  var index = 0;\n  var output = new Uint8Array(length * 5 / 8 | 0);\n\n  for (var i = 0; i < length; i++) {\n    value = value << 5 | alphabet.indexOf(input[i]);\n    bits += 5;\n\n    if (bits >= 8) {\n      output[index++] = value >>> bits - 8 & 255;\n      bits -= 8;\n    }\n  }\n\n  return output;\n}\n\nfunction _encode(buffer, alphabet) {\n  var length = buffer.byteLength;\n  var view = new Uint8Array(buffer);\n  var padding = alphabet.indexOf('=') === alphabet.length - 1;\n\n  if (padding) {\n    alphabet = alphabet.substring(0, alphabet.length - 2);\n  }\n\n  var bits = 0;\n  var value = 0;\n  var output = '';\n\n  for (var i = 0; i < length; i++) {\n    value = value << 8 | view[i];\n    bits += 8;\n\n    while (bits >= 5) {\n      output += alphabet[value >>> bits - 5 & 31];\n      bits -= 5;\n    }\n  }\n\n  if (bits > 0) {\n    output += alphabet[value << 5 - bits & 31];\n  }\n\n  if (padding) {\n    while (output.length % 8 !== 0) {\n      output += '=';\n    }\n  }\n\n  return output;\n}\n\nexport function base32(alphabet) {\n  return {\n    encode: function encode(input) {\n      if (typeof input === 'string') {\n        return _encode(uint8arrays.fromString(input), alphabet);\n      }\n\n      return _encode(input, alphabet);\n    },\n    decode: function decode(input) {\n      var _iterator = _createForOfIteratorHelper(input),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var char = _step.value;\n\n          if (alphabet.indexOf(char) < 0) {\n            throw new Error('invalid base32 character');\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return _decode(input, alphabet);\n    }\n  };\n}","map":{"version":3,"sources":["../src/base32.ts"],"names":["input","length","bits","value","index","output","i","alphabet","buffer","view","padding","encode","uint8arrays","decode","char"],"mappings":"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","sourcesContent":["import * as uint8arrays from 'uint8arrays'\n\n/* tslint:disable:no-bitwise */\n// From js-multibase (https://github.com/multiformats/js-multibase)\n\nfunction decode(input: string, alphabet: string): Uint8Array {\n  input = input.replace(new RegExp('=', 'g'), '')\n  const { length } = input\n\n  let bits = 0\n  let value = 0\n\n  let index = 0\n  const output = new Uint8Array(((length * 5) / 8) | 0)\n\n  for (let i = 0; i < length; i++) {\n    value = (value << 5) | alphabet.indexOf(input[i])\n    bits += 5\n\n    if (bits >= 8) {\n      output[index++] = (value >>> (bits - 8)) & 255\n      bits -= 8\n    }\n  }\n\n  return output\n}\n\nfunction encode(\n  buffer: Uint8Array | ArrayBufferLike,\n  alphabet: string\n): string {\n  const length = buffer.byteLength\n  const view = new Uint8Array(buffer)\n  const padding = alphabet.indexOf('=') === alphabet.length - 1\n\n  if (padding) {\n    alphabet = alphabet.substring(0, alphabet.length - 2)\n  }\n\n  let bits = 0\n  let value = 0\n  let output = ''\n\n  for (let i = 0; i < length; i++) {\n    value = (value << 8) | view[i]\n    bits += 8\n\n    while (bits >= 5) {\n      output += alphabet[(value >>> (bits - 5)) & 31]\n      bits -= 5\n    }\n  }\n\n  if (bits > 0) {\n    output += alphabet[(value << (5 - bits)) & 31]\n  }\n\n  if (padding) {\n    while (output.length % 8 !== 0) {\n      output += '='\n    }\n  }\n\n  return output\n}\n\nexport function base32(alphabet: string) {\n  return {\n    encode(input: Uint8Array | string): string {\n      if (typeof input === 'string') {\n        return encode(uint8arrays.fromString(input), alphabet)\n      }\n\n      return encode(input, alphabet)\n    },\n    decode(input: string): Uint8Array {\n      for (const char of input) {\n        if (alphabet.indexOf(char) < 0) {\n          throw new Error('invalid base32 character')\n        }\n      }\n\n      return decode(input, alphabet)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}