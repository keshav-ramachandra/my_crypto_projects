{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { getRenNetworkDetails, NullLogger, TxStatus } from \"@renproject/interfaces\";\nimport { HttpProvider } from \"@renproject/provider\";\nimport { assertType, fromBase64, isDefined, SECONDS, sleep, toURLBase64 } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport { RPCMethod } from \"./methods\";\nimport { unmarshalTypedPackValue } from \"./pack/pack\";\nimport { hashTransaction, mintParamsType, submitGatewayType } from \"./transaction\";\nimport { unmarshalBurnTx, unmarshalMintTx } from \"./unmarshal\";\nexport const resolveV2Contract = ({\n  asset,\n  from,\n  to\n}) => {\n  if (from.assetIsNative && from.assetIsNative(asset)) {\n    return `${asset}/to${to.name}`;\n  }\n\n  if (to.assetIsNative && to.assetIsNative(asset)) {\n    return `${asset}/from${from.name}`;\n  }\n\n  return `${asset}/from${from.name}To${to.name}`;\n};\nexport class RenVMProvider {\n  constructor(network, provider, logger = NullLogger) {\n    this.version = () => 2;\n\n    this.selector = params => {\n      return resolveV2Contract(params);\n    };\n\n    this.queryBlock = (blockHeight, retry) => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.QueryBlock, {\n        blockHeight\n      }, retry);\n    });\n\n    this.queryBlocks = (blockHeight, n, retry) => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.QueryBlocks, {\n        blockHeight,\n        n\n      }, retry);\n    });\n\n    this.submitGateway = (gateway, tx, retry) => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.SubmitGateway, {\n        gateway,\n        tx\n      }, retry);\n    });\n\n    this.submitTx = (tx, retry) => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.SubmitTx, {\n        tx\n      }, retry);\n    });\n\n    this.queryTx = (txHash, retry) => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.QueryTx, {\n        txHash\n      }, retry);\n    });\n\n    this.queryTxs = (tags, page, pageSize, txStatus, retry) => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.QueryTxs, {\n        tags,\n        page: (page || 0).toString(),\n        pageSize: (pageSize || 0).toString(),\n        txStatus\n      }, retry);\n    });\n\n    this.queryConfig = retry => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.QueryConfig, {}, retry);\n    });\n\n    this.queryState = retry => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.QueryState, {}, retry);\n    });\n\n    this.buildGateway = ({\n      selector,\n      gHash,\n      gPubKey,\n      nHash,\n      nonce,\n      payload,\n      pHash,\n      to,\n      transactionVersion\n    }) => {\n      assertType(\"Buffer\", {\n        gHash,\n        gPubKey,\n        nHash,\n        nonce,\n        payload,\n        pHash\n      });\n      assertType(\"string\", {\n        to\n      });\n      const version = isDefined(transactionVersion) ? String(transactionVersion) : \"1\";\n      const txIn = {\n        t: submitGatewayType(),\n        v: {\n          ghash: toURLBase64(gHash),\n          gpubkey: toURLBase64(gPubKey),\n          nhash: toURLBase64(nHash),\n          nonce: toURLBase64(nonce),\n          payload: toURLBase64(payload),\n          phash: toURLBase64(pHash),\n          to\n        }\n      };\n      return {\n        selector: selector,\n        version,\n        // TODO: Fix types\n        in: txIn\n      };\n    };\n\n    this.buildTransaction = ({\n      selector,\n      gHash,\n      gPubKey,\n      nHash,\n      nonce,\n      output,\n      amount,\n      payload,\n      pHash,\n      to,\n      transactionVersion\n    }) => {\n      assertType(\"Buffer\", {\n        gHash,\n        gPubKey,\n        nHash,\n        nonce,\n        payload,\n        pHash,\n        txid: output.txid\n      });\n      assertType(\"string\", {\n        to,\n        amount,\n        txindex: output.txindex\n      });\n      const version = isDefined(transactionVersion) ? String(transactionVersion) : \"1\";\n      const txIn = {\n        t: mintParamsType(),\n        v: {\n          txid: toURLBase64(output.txid),\n          txindex: output.txindex,\n          ghash: toURLBase64(gHash),\n          gpubkey: toURLBase64(gPubKey),\n          nhash: toURLBase64(nHash),\n          nonce: toURLBase64(nonce),\n          payload: toURLBase64(payload),\n          phash: toURLBase64(pHash),\n          to,\n          amount\n        }\n      };\n      return {\n        hash: toURLBase64(hashTransaction(version, selector, txIn)),\n        selector: selector,\n        version,\n        // TODO: Fix types\n        in: txIn\n      };\n    };\n\n    this.mintTxHash = params => {\n      return fromBase64(this.buildTransaction(params).hash);\n    };\n\n    this.submitMint = (params, retries) => __awaiter(this, void 0, void 0, function* () {\n      const tx = this.buildTransaction(params);\n      yield this.submitTx(tx, retries);\n      return fromBase64(tx.hash);\n    });\n\n    this.submitGatewayDetails = (gateway, params, retries) => __awaiter(this, void 0, void 0, function* () {\n      const tx = this.buildGateway(params);\n      yield this.submitGateway(gateway, tx, retries);\n      return gateway;\n    });\n\n    this.burnTxHash = this.mintTxHash;\n    this.submitBurn = this.submitMint;\n    /**\n     * Queries the result of a RenVM transaction and unmarshals the result into\n     * a [[LockAndMintTransaction]] or [[BurnAndReleaseTransaction]].\n     *\n     * @param renVMTxHash The transaction hash as a Buffer.\n     */\n\n    this.queryMintOrBurn = (_selector, renVMTxHash, retries) => __awaiter(this, void 0, void 0, function* () {\n      try {\n        const response = yield this.queryTx(toURLBase64(renVMTxHash), retries); // Unmarshal transaction.\n        // TODO: Improve mint/burn detection. Currently checks if the format\n        // is `ASSET/toChain` or `ASSET/fromChainToChain`. It may return\n        // a false positive if the chain name contains `To`.\n\n        const isMint = /((\\/to)|(To))/.exec(response.tx.selector);\n\n        if (isMint) {\n          return unmarshalMintTx(response);\n        } else {\n          return unmarshalBurnTx(response);\n        }\n      } catch (error) {\n        throw error;\n      }\n    });\n    /**\n     * Fetches the result of a RenVM transaction on a repeated basis until the\n     * transaction's status is `\"done\"`.\n     *\n     * @param utxoTxHash The transaction hash as a Buffer.\n     * @param onStatus A callback called each time the status of the transaction\n     * is refreshed - even if it hasn't changed.\n     * @param _cancelRequested A function that returns `true` to cancel the\n     * loop.\n     */\n\n\n    this.waitForTX = (selector, utxoTxHash, onStatus, _cancelRequested, timeout) => __awaiter(this, void 0, void 0, function* () {\n      assertType(\"Buffer\", {\n        utxoTxHash\n      });\n      let rawResponse;\n\n      while (true) {\n        if (_cancelRequested && _cancelRequested()) {\n          throw new Error(`waitForTX cancelled.`);\n        }\n\n        try {\n          const result = yield this.queryMintOrBurn(selector, utxoTxHash);\n\n          if (result && result.txStatus === TxStatus.TxStatusDone) {\n            rawResponse = result;\n            break;\n          } else if (onStatus && result && result.txStatus) {\n            onStatus(result.txStatus);\n          }\n        } catch (error) {\n          if (/(not found)|(not available)/.exec(String((error || {}).message))) {// ignore\n          } else {\n            this.logger.error(String(error)); // TODO: throw unexpected errors\n          }\n        }\n\n        yield sleep(isDefined(timeout) ? timeout : 15 * SECONDS);\n      }\n\n      return rawResponse;\n    });\n    /**\n     * selectPublicKey fetches the public key for the RenVM shard handling\n     * the provided contract.\n     *\n     * @param chain The chain for which the public key should be fetched.\n     * @returns The public key hash (20 bytes) as a string.\n     */\n\n\n    this.selectPublicKey = (_selector, chain) => __awaiter(this, void 0, void 0, function* () {\n      // Call the ren_queryShards RPC.\n      const response = yield this.queryState(5);\n      return fromBase64(response.state[chain].pubKey);\n    }); // In the future, this will be asynchronous. It returns a promise for\n    // compatibility.\n    // eslint-disable-next-line @typescript-eslint/require-await\n\n\n    this.getNetwork = _selector => __awaiter(this, void 0, void 0, function* () {\n      return this.network;\n    });\n\n    this.getConfirmationTarget = (_selector, chain) => __awaiter(this, void 0, void 0, function* () {\n      const renVMConfig = yield this.sendMessage(RPCMethod.QueryConfig, {});\n      return parseInt(renVMConfig.confirmations[chain.name], 10);\n    });\n\n    this.estimateTransactionFee = (asset, _lockChain, hostChain) => __awaiter(this, void 0, void 0, function* () {\n      const renVMState = yield this.sendMessage(RPCMethod.QueryBlockState, {});\n      const blockState = unmarshalTypedPackValue(renVMState.state);\n\n      if (!blockState[asset]) {\n        throw new Error(`No fee details found for ${asset}`);\n      }\n\n      const {\n        gasLimit,\n        gasCap\n      } = blockState[asset];\n      const fee = new BigNumber(gasLimit).times(new BigNumber(gasCap));\n      const mintAndBurnFees = blockState[asset].fees.chains.filter(chainFees => chainFees.chain === hostChain.name)[0];\n      return {\n        lock: fee,\n        release: fee,\n        mint: mintAndBurnFees && mintAndBurnFees.mintFee ? mintAndBurnFees.mintFee.toNumber() : 15,\n        burn: mintAndBurnFees && mintAndBurnFees.burnFee ? mintAndBurnFees.burnFee.toNumber() : 15\n      };\n    });\n\n    if (!provider || typeof provider === \"string\") {\n      const rpcUrl = provider || (getRenNetworkDetails(network) || {}).lightnode;\n\n      try {\n        provider = new HttpProvider(rpcUrl, logger);\n      } catch (error) {\n        if (/Invalid node URL/.exec(String(error && error.message))) {\n          throw new Error(`Invalid network or provider URL: \"${(getRenNetworkDetails(network) || {}).name || String(network)}\"`);\n        }\n\n        throw error;\n      }\n    }\n\n    this.network = network;\n    this.logger = logger;\n    this.provider = provider;\n    this.sendMessage = this.provider.sendMessage;\n  }\n\n}","map":{"version":3,"sources":["../../../src/v2/renVMProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getRenNetworkDetails, NullLogger, TxStatus, } from \"@renproject/interfaces\";\nimport { HttpProvider } from \"@renproject/provider\";\nimport { assertType, fromBase64, isDefined, SECONDS, sleep, toURLBase64, } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport { RPCMethod, } from \"./methods\";\nimport { unmarshalTypedPackValue } from \"./pack/pack\";\nimport { hashTransaction, mintParamsType, submitGatewayType, } from \"./transaction\";\nimport { unmarshalBurnTx, unmarshalMintTx } from \"./unmarshal\";\nexport const resolveV2Contract = ({ asset, from, to, }) => {\n    if (from.assetIsNative &&\n        from.assetIsNative(asset)) {\n        return `${asset}/to${to.name}`;\n    }\n    if (to.assetIsNative &&\n        to.assetIsNative(asset)) {\n        return `${asset}/from${from.name}`;\n    }\n    return `${asset}/from${from.name}To${to.name}`;\n};\nexport class RenVMProvider {\n    constructor(network, provider, logger = NullLogger) {\n        this.version = () => 2;\n        this.selector = (params) => {\n            return resolveV2Contract(params);\n        };\n        this.queryBlock = (blockHeight, retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.QueryBlock, { blockHeight }, retry);\n        });\n        this.queryBlocks = (blockHeight, n, retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.QueryBlocks, { blockHeight, n }, retry);\n        });\n        this.submitGateway = (gateway, tx, retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.SubmitGateway, { gateway, tx }, retry);\n        });\n        this.submitTx = (tx, retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.SubmitTx, { tx }, retry);\n        });\n        this.queryTx = (txHash, retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.QueryTx, { txHash }, retry);\n        });\n        this.queryTxs = (tags, page, pageSize, txStatus, retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.QueryTxs, {\n                tags,\n                page: (page || 0).toString(),\n                pageSize: (pageSize || 0).toString(),\n                txStatus,\n            }, retry);\n        });\n        this.queryConfig = (retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.QueryConfig, {}, retry);\n        });\n        this.queryState = (retry) => __awaiter(this, void 0, void 0, function* () { return this.sendMessage(RPCMethod.QueryState, {}, retry); });\n        this.buildGateway = ({ selector, gHash, gPubKey, nHash, nonce, payload, pHash, to, transactionVersion, }) => {\n            assertType(\"Buffer\", {\n                gHash,\n                gPubKey,\n                nHash,\n                nonce,\n                payload,\n                pHash,\n            });\n            assertType(\"string\", { to });\n            const version = isDefined(transactionVersion)\n                ? String(transactionVersion)\n                : \"1\";\n            const txIn = {\n                t: submitGatewayType(),\n                v: {\n                    ghash: toURLBase64(gHash),\n                    gpubkey: toURLBase64(gPubKey),\n                    nhash: toURLBase64(nHash),\n                    nonce: toURLBase64(nonce),\n                    payload: toURLBase64(payload),\n                    phash: toURLBase64(pHash),\n                    to,\n                },\n            };\n            return {\n                selector: selector,\n                version,\n                // TODO: Fix types\n                in: txIn,\n            };\n        };\n        this.buildTransaction = ({ selector, gHash, gPubKey, nHash, nonce, output, amount, payload, pHash, to, transactionVersion, }) => {\n            assertType(\"Buffer\", {\n                gHash,\n                gPubKey,\n                nHash,\n                nonce,\n                payload,\n                pHash,\n                txid: output.txid,\n            });\n            assertType(\"string\", { to, amount, txindex: output.txindex });\n            const version = isDefined(transactionVersion)\n                ? String(transactionVersion)\n                : \"1\";\n            const txIn = {\n                t: mintParamsType(),\n                v: {\n                    txid: toURLBase64(output.txid),\n                    txindex: output.txindex,\n                    ghash: toURLBase64(gHash),\n                    gpubkey: toURLBase64(gPubKey),\n                    nhash: toURLBase64(nHash),\n                    nonce: toURLBase64(nonce),\n                    payload: toURLBase64(payload),\n                    phash: toURLBase64(pHash),\n                    to,\n                    amount,\n                },\n            };\n            return {\n                hash: toURLBase64(hashTransaction(version, selector, txIn)),\n                selector: selector,\n                version,\n                // TODO: Fix types\n                in: txIn,\n            };\n        };\n        this.mintTxHash = (params) => {\n            return fromBase64(this.buildTransaction(params).hash);\n        };\n        this.submitMint = (params, retries) => __awaiter(this, void 0, void 0, function* () {\n            const tx = this.buildTransaction(params);\n            yield this.submitTx(tx, retries);\n            return fromBase64(tx.hash);\n        });\n        this.submitGatewayDetails = (gateway, params, retries) => __awaiter(this, void 0, void 0, function* () {\n            const tx = this.buildGateway(params);\n            yield this.submitGateway(gateway, tx, retries);\n            return gateway;\n        });\n        this.burnTxHash = this.mintTxHash;\n        this.submitBurn = this.submitMint;\n        /**\n         * Queries the result of a RenVM transaction and unmarshals the result into\n         * a [[LockAndMintTransaction]] or [[BurnAndReleaseTransaction]].\n         *\n         * @param renVMTxHash The transaction hash as a Buffer.\n         */\n        this.queryMintOrBurn = (_selector, renVMTxHash, retries) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield this.queryTx(toURLBase64(renVMTxHash), retries);\n                // Unmarshal transaction.\n                // TODO: Improve mint/burn detection. Currently checks if the format\n                // is `ASSET/toChain` or `ASSET/fromChainToChain`. It may return\n                // a false positive if the chain name contains `To`.\n                const isMint = /((\\/to)|(To))/.exec(response.tx.selector);\n                if (isMint) {\n                    return unmarshalMintTx(response);\n                }\n                else {\n                    return unmarshalBurnTx(response);\n                }\n            }\n            catch (error) {\n                throw error;\n            }\n        });\n        /**\n         * Fetches the result of a RenVM transaction on a repeated basis until the\n         * transaction's status is `\"done\"`.\n         *\n         * @param utxoTxHash The transaction hash as a Buffer.\n         * @param onStatus A callback called each time the status of the transaction\n         * is refreshed - even if it hasn't changed.\n         * @param _cancelRequested A function that returns `true` to cancel the\n         * loop.\n         */\n        this.waitForTX = (selector, utxoTxHash, onStatus, _cancelRequested, timeout) => __awaiter(this, void 0, void 0, function* () {\n            assertType(\"Buffer\", { utxoTxHash });\n            let rawResponse;\n            while (true) {\n                if (_cancelRequested && _cancelRequested()) {\n                    throw new Error(`waitForTX cancelled.`);\n                }\n                try {\n                    const result = yield this.queryMintOrBurn(selector, utxoTxHash);\n                    if (result && result.txStatus === TxStatus.TxStatusDone) {\n                        rawResponse = result;\n                        break;\n                    }\n                    else if (onStatus && result && result.txStatus) {\n                        onStatus(result.txStatus);\n                    }\n                }\n                catch (error) {\n                    if (/(not found)|(not available)/.exec(String((error || {}).message))) {\n                        // ignore\n                    }\n                    else {\n                        this.logger.error(String(error));\n                        // TODO: throw unexpected errors\n                    }\n                }\n                yield sleep(isDefined(timeout) ? timeout : 15 * SECONDS);\n            }\n            return rawResponse;\n        });\n        /**\n         * selectPublicKey fetches the public key for the RenVM shard handling\n         * the provided contract.\n         *\n         * @param chain The chain for which the public key should be fetched.\n         * @returns The public key hash (20 bytes) as a string.\n         */\n        this.selectPublicKey = (_selector, chain) => __awaiter(this, void 0, void 0, function* () {\n            // Call the ren_queryShards RPC.\n            const response = yield this.queryState(5);\n            return fromBase64(response.state[chain].pubKey);\n        });\n        // In the future, this will be asynchronous. It returns a promise for\n        // compatibility.\n        // eslint-disable-next-line @typescript-eslint/require-await\n        this.getNetwork = (_selector) => __awaiter(this, void 0, void 0, function* () {\n            return this.network;\n        });\n        this.getConfirmationTarget = (_selector, chain) => __awaiter(this, void 0, void 0, function* () {\n            const renVMConfig = yield this.sendMessage(RPCMethod.QueryConfig, {});\n            return parseInt(renVMConfig.confirmations[chain.name], 10);\n        });\n        this.estimateTransactionFee = (asset, _lockChain, hostChain) => __awaiter(this, void 0, void 0, function* () {\n            const renVMState = yield this.sendMessage(RPCMethod.QueryBlockState, {});\n            const blockState = unmarshalTypedPackValue(renVMState.state);\n            if (!blockState[asset]) {\n                throw new Error(`No fee details found for ${asset}`);\n            }\n            const { gasLimit, gasCap } = blockState[asset];\n            const fee = new BigNumber(gasLimit).times(new BigNumber(gasCap));\n            const mintAndBurnFees = blockState[asset].fees.chains.filter((chainFees) => chainFees.chain === hostChain.name)[0];\n            return {\n                lock: fee,\n                release: fee,\n                mint: mintAndBurnFees && mintAndBurnFees.mintFee\n                    ? mintAndBurnFees.mintFee.toNumber()\n                    : 15,\n                burn: mintAndBurnFees && mintAndBurnFees.burnFee\n                    ? mintAndBurnFees.burnFee.toNumber()\n                    : 15,\n            };\n        });\n        if (!provider || typeof provider === \"string\") {\n            const rpcUrl = provider || (getRenNetworkDetails(network) || {}).lightnode;\n            try {\n                provider = new HttpProvider(rpcUrl, logger);\n            }\n            catch (error) {\n                if (/Invalid node URL/.exec(String(error && error.message))) {\n                    throw new Error(`Invalid network or provider URL: \"${(getRenNetworkDetails(network) || {}).name ||\n                        String(network)}\"`);\n                }\n                throw error;\n            }\n        }\n        this.network = network;\n        this.logger = logger;\n        this.provider = provider;\n        this.sendMessage = this.provider.sendMessage;\n    }\n}\n//# sourceMappingURL=renVMProvider.js.map"]},"metadata":{},"sourceType":"module"}