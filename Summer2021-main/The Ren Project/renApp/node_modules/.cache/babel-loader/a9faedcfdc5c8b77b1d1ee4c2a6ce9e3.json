{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { getRenNetworkDetails, RenNetwork } from \"@renproject/interfaces\";\nimport { assertType, extractError, fromHex, Ox, payloadToABI, utilsWithChainNetwork } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport Web3 from \"web3\";\nimport { renDevnetVDot3, renMainnet, renMainnetVDot3, renTestnet, renTestnetVDot3 } from \"./networks\";\nimport { addressIsValid, transactionIsValid, extractBurnDetails, findBurnByNonce, findTransactionBySigHash, forwardWeb3Events, getGatewayAddress, getTokenAddress, ignorePromiEventError, manualPromiEvent, submitToEthereum, withDefaultAccount } from \"./utils\";\nexport const EthereumConfigMap = {\n  [RenNetwork.Mainnet]: renMainnet,\n  [RenNetwork.Testnet]: renTestnet,\n  [RenNetwork.MainnetVDot3]: renMainnetVDot3,\n  [RenNetwork.TestnetVDot3]: renTestnetVDot3,\n  [RenNetwork.DevnetVDot3]: renDevnetVDot3\n};\n\nconst isEthereumConfig = renNetwork => {\n  return !!renNetwork.addresses;\n};\n\nconst resolveNetwork = renNetwork => {\n  if (!renNetwork) {\n    return EthereumConfigMap[RenNetwork.Mainnet];\n  }\n\n  let networkConfig;\n\n  if (renNetwork && isEthereumConfig(renNetwork)) {\n    networkConfig = renNetwork;\n  } else if (renNetwork) {\n    const networkDetails = getRenNetworkDetails(renNetwork);\n\n    if (EthereumConfigMap[networkDetails.name]) {\n      networkConfig = EthereumConfigMap[networkDetails.name];\n    }\n  }\n\n  if (!networkConfig) {\n    throw new Error(`Unrecognized network ${typeof renNetwork === \"string\" ? renNetwork : renNetwork.name}.`);\n  }\n\n  return networkConfig;\n};\n\nexport class EthereumBaseChain {\n  constructor(web3Provider, renNetwork) {\n    this.chain = EthereumBaseChain.chain;\n    this.name = EthereumBaseChain.chain;\n    this.legacyName = \"Eth\";\n    this.logRequestLimit = undefined;\n    this.configMap = EthereumConfigMap;\n    this.utils = utilsWithChainNetwork(EthereumBaseChain.utils, () => this.renNetworkDetails);\n\n    this.getTokenContractAddress = asset => __awaiter(this, void 0, void 0, function* () {\n      if (!this.web3 || !this.renNetworkDetails) {\n        throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n      }\n\n      return getTokenAddress(this.renNetworkDetails, this.web3, asset);\n    });\n\n    this.getGatewayContractAddress = token => __awaiter(this, void 0, void 0, function* () {\n      if (!this.web3 || !this.renNetworkDetails) {\n        throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n      }\n\n      const gatewayAddress = yield getGatewayAddress(this.renNetworkDetails, this.web3, token);\n\n      if (gatewayAddress === \"0x0000000000000000000000000000000000000000\") {\n        throw new Error(`Asset not supported on mint-chain.`);\n      }\n\n      return gatewayAddress;\n    });\n\n    this.withProvider = web3Provider => {\n      this.web3 = new Web3(web3Provider);\n      return this;\n    };\n    /**\n     * See [LockChain.initialize].\n     */\n\n\n    this.initialize = renNetwork => {\n      this.renNetworkDetails = this.renNetworkDetails || EthereumConfigMap[getRenNetworkDetails(renNetwork).name];\n\n      if (!this.renNetworkDetails) {\n        throw new Error(`Unable to set ${this.name} network for RenVM network ${getRenNetworkDetails(renNetwork).name}. Please provide ${this.name} network details to ${this.name} constructor.`);\n      }\n\n      return this;\n    }; // Supported assets\n\n\n    this.assetIsNative = asset => {\n      return asset === \"ETH\";\n    };\n    /**\n     * `assetIsSupported` should return true if the asset is native to the\n     * MintChain.\n     *\n     * ```ts\n     * ethereum.assetIsSupported = asset => asset === \"ETH\";\n     * ```\n     */\n\n\n    this.assetIsSupported = asset => __awaiter(this, void 0, void 0, function* () {\n      if (this.assetIsNative(asset)) {\n        return true;\n      }\n\n      if (!this.web3 || !this.renNetworkDetails) {\n        throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n      } // Check that there's a gateway contract for the asset.\n\n\n      try {\n        return !!(yield this.getGatewayContractAddress(asset));\n      } catch (error) {\n        if (/(Empty address returned)|(Asset not supported on mint-chain)/.exec(String((error || {}).message))) {// Ignore\n        } else {\n          console.warn(error);\n        }\n\n        return false;\n      }\n    });\n    /**\n     * `assetDecimals` should return the number of decimals of the asset.\n     *\n     * If the asset is not supported, an error should be thrown.\n     *\n     \n     */\n\n\n    this.assetDecimals = asset => __awaiter(this, void 0, void 0, function* () {\n      if (!this.web3) {\n        throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n      }\n\n      if (asset === \"ETH\") {\n        return 18;\n      }\n\n      const tokenAddress = yield this.getTokenContractAddress(asset);\n      const decimalsABI = {\n        constant: true,\n        inputs: [],\n        name: \"decimals\",\n        outputs: [{\n          internalType: \"uint256\",\n          name: \"\",\n          type: \"uint256\"\n        }],\n        payable: false,\n        stateMutability: \"view\",\n        type: \"function\"\n      };\n      const tokenContract = new this.web3.eth.Contract([decimalsABI], tokenAddress);\n      const decimalsRaw = yield yield tokenContract.methods.decimals().call();\n      return new BigNumber(decimalsRaw).toNumber();\n    });\n\n    this.transactionID = transaction => {\n      return transaction || \"\";\n    };\n\n    this.transactionIDFromRPCFormat = (txid, txindex) => this.transactionID(this.transactionFromRPCFormat(txid, txindex));\n\n    this.transactionFromRPCFormat = (txid, _txindex) => Ox(txid);\n    /**\n     * @deprecated Renamed to `transactionFromRPCFormat`.\n     * Will be removed in 3.0.0.\n     */\n\n\n    this.transactionFromID = this.transactionFromRPCFormat;\n\n    this.transactionConfidence = transaction => __awaiter(this, void 0, void 0, function* () {\n      if (!this.web3 || !this.renNetworkDetails) {\n        throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n      }\n\n      if (transaction === null) {\n        throw new Error(`Unable to fetch transaction confidence, transaction hash is 'null'.`);\n      }\n\n      const currentBlock = new BigNumber((yield this.web3.eth.getBlockNumber()).toString());\n      const receipt = yield this.web3.eth.getTransactionReceipt(transaction);\n      let current = 0;\n\n      if (receipt.blockNumber) {\n        const transactionBlock = new BigNumber(receipt.blockNumber.toString());\n        current = currentBlock.minus(transactionBlock).plus(1).toNumber();\n      }\n\n      return {\n        current,\n        target: this.renNetworkDetails.isTestnet ? 15 : 30\n      };\n    });\n\n    this.submitMint = (asset, contractCalls, mintTx, eventEmitter) => __awaiter(this, void 0, void 0, function* () {\n      if (!mintTx.out) {\n        throw new Error(`No signature passed to mint submission.`);\n      }\n\n      if (mintTx.out.revert !== undefined) {\n        throw new Error(`Unable to submit reverted RenVM transaction.`);\n      }\n\n      if (!this.web3) {\n        throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n      }\n\n      const existingTransaction = yield this.findTransaction(asset, mintTx.out.nhash, mintTx.out.sighash);\n\n      if (existingTransaction) {\n        yield manualPromiEvent(this.web3, existingTransaction, eventEmitter);\n        return existingTransaction;\n      }\n\n      return yield submitToEthereum(this.web3, contractCalls, mintTx, eventEmitter);\n    });\n\n    this.findTransaction = (asset, nHash, sigHash) => __awaiter(this, void 0, void 0, function* () {\n      if (!this.renNetworkDetails || !this.web3) {\n        throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n      }\n\n      return findTransactionBySigHash(this.renNetworkDetails, this.web3, asset, nHash, sigHash, this.logRequestLimit);\n    });\n\n    this.resolveTokenGatewayContract = asset => __awaiter(this, void 0, void 0, function* () {\n      if (!this.renNetworkDetails || !this.web3) {\n        throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n      }\n\n      return Ox(yield getTokenAddress(this.renNetworkDetails, this.web3, asset));\n    });\n    /**\n     * Read a burn reference from an Ethereum transaction - or submit a\n     * transaction first if the transaction details have been provided.\n     */\n\n\n    this.findBurnTransaction = (asset, // Once of the following should not be undefined.\n    burn, eventEmitter, logger, timeout) => __awaiter(this, void 0, void 0, function* () {\n      if (!this.renNetworkDetails || !this.web3) {\n        throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n      }\n\n      const {\n        burnNonce,\n        contractCalls\n      } = burn;\n      let {\n        transaction\n      } = burn;\n\n      if (!transaction && burnNonce) {\n        return findBurnByNonce(this.renNetworkDetails, this.web3, asset, burnNonce.toString());\n      } // There are three parameter configs:\n      // Situation (1): A `burnNonce` is provided\n      // Situation (2): Contract call details are provided\n      // Situation (3): A transaction is provided\n      // Handle situation (2)\n      // Make a call to the provided contract and Pass on the\n      // transaction hash.\n\n\n      if (!transaction && contractCalls) {\n        for (let i = 0; i < contractCalls.length; i++) {\n          const contractCall = contractCalls[i];\n          const last = i === contractCalls.length - 1;\n          const {\n            contractParams,\n            contractFn,\n            sendTo\n          } = contractCall;\n          const callParams = [...(contractParams || []).map(value => value.value)];\n          const ABI = payloadToABI(contractFn, contractParams);\n          const contract = new this.web3.eth.Contract(ABI, sendTo);\n          const txConfig = typeof contractCall === \"object\" ? contractCall.txConfig : {};\n          const config = yield withDefaultAccount(this.web3, Object.assign(Object.assign({}, txConfig), {\n            value: txConfig && txConfig.value ? txConfig.value.toString() : undefined,\n            gasPrice: txConfig && txConfig.gasPrice ? txConfig.gasPrice.toString() : undefined\n          }));\n          logger.debug(\"Calling Ethereum contract\", contractFn, sendTo, ...callParams, config);\n          const tx = contract.methods[contractFn](...callParams).send(config);\n\n          if (last) {\n            forwardWeb3Events(tx, eventEmitter);\n          }\n\n          transaction = yield new Promise((resolve, reject) => tx.on(\"transactionHash\", resolve).catch(error => {\n            try {\n              if (ignorePromiEventError(error)) {\n                logger.error(extractError(error));\n                return;\n              }\n            } catch (_error) {\n              /* Ignore _error */\n            }\n\n            reject(error);\n          }));\n          logger.debug(\"Transaction hash\", transaction);\n        }\n      }\n\n      if (!transaction) {\n        throw new Error(`Unable to find burn from provided parameters.`);\n      }\n\n      return extractBurnDetails(this.web3, transaction, logger, timeout);\n    });\n\n    this.getFees = asset => __awaiter(this, void 0, void 0, function* () {\n      if (!this.web3) {\n        throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n      }\n\n      const gatewayAddress = yield this.getGatewayContractAddress(asset);\n      const mintFeeABI = {\n        constant: true,\n        inputs: [],\n        name: \"mintFee\",\n        outputs: [{\n          internalType: \"uint16\",\n          name: \"\",\n          type: \"uint16\"\n        }],\n        payable: false,\n        stateMutability: \"view\",\n        type: \"function\"\n      };\n      const burnFeeABI = {\n        constant: true,\n        inputs: [],\n        name: \"burnFee\",\n        outputs: [{\n          internalType: \"uint16\",\n          name: \"\",\n          type: \"uint16\"\n        }],\n        payable: false,\n        stateMutability: \"view\",\n        type: \"function\"\n      };\n      const gatewayContract = new this.web3.eth.Contract([mintFeeABI, burnFeeABI], gatewayAddress);\n      const mintFee = yield gatewayContract.methods.mintFee().call();\n      const burnFee = yield gatewayContract.methods.burnFee().call();\n      return {\n        mint: new BigNumber(mintFee.toString()).toNumber(),\n        burn: new BigNumber(burnFee.toString()).toNumber()\n      };\n    });\n\n    this.getBalance = (asset, address) => __awaiter(this, void 0, void 0, function* () {\n      const balanceOfABI = {\n        constant: true,\n        inputs: [{\n          internalType: \"address\",\n          name: \"account\",\n          type: \"address\"\n        }],\n        name: \"balanceOf\",\n        outputs: [{\n          internalType: \"uint256\",\n          name: \"\",\n          type: \"uint256\"\n        }],\n        payable: false,\n        stateMutability: \"view\",\n        type: \"function\"\n      };\n\n      if (!this.web3) {\n        throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n      }\n\n      const tokenAddress = yield this.getTokenContractAddress(asset);\n      const tokenContract = new this.web3.eth.Contract([balanceOfABI], tokenAddress);\n      const balanceRaw = yield yield tokenContract.methods.balanceOf(address).call();\n      return new BigNumber(balanceRaw.toString());\n    });\n\n    this.transactionRPCFormat = (transaction, _v2) => {\n      assertType(\"string | null\", {\n        transaction\n      });\n\n      if (transaction === null) {\n        throw new Error(`Unable to encode transaction, transaction hash is 'null'.`);\n      }\n\n      return {\n        txid: fromHex(transaction),\n        txindex: \"0\"\n      };\n    };\n\n    this.transactionRPCTxidFromID = transactionID => fromHex(transactionID);\n\n    this.web3 = new Web3(web3Provider);\n\n    if (renNetwork) {\n      this.renNetworkDetails = resolveNetwork(renNetwork);\n    }\n  }\n\n}\nEthereumBaseChain.chain = \"Ethereum\";\nEthereumBaseChain.configMap = EthereumConfigMap;\nEthereumBaseChain.utils = {\n  resolveChainNetwork: resolveNetwork,\n  addressIsValid,\n  transactionIsValid,\n  addressExplorerLink: (address, network) => `${(EthereumBaseChain.utils.resolveChainNetwork(network) || renMainnet).etherscan}/address/${address}`,\n  transactionExplorerLink: (transaction, network) => `${(EthereumBaseChain.utils.resolveChainNetwork(network) || renMainnet).etherscan}/tx/${transaction || \"\"}`\n};\nconst _ = EthereumBaseChain;","map":{"version":3,"sources":["../../src/base.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getRenNetworkDetails, RenNetwork, } from \"@renproject/interfaces\";\nimport { assertType, extractError, fromHex, Ox, payloadToABI, utilsWithChainNetwork, } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport Web3 from \"web3\";\nimport { renDevnetVDot3, renMainnet, renMainnetVDot3, renTestnet, renTestnetVDot3, } from \"./networks\";\nimport { addressIsValid, transactionIsValid, extractBurnDetails, findBurnByNonce, findTransactionBySigHash, forwardWeb3Events, getGatewayAddress, getTokenAddress, ignorePromiEventError, manualPromiEvent, submitToEthereum, withDefaultAccount, } from \"./utils\";\nexport const EthereumConfigMap = {\n    [RenNetwork.Mainnet]: renMainnet,\n    [RenNetwork.Testnet]: renTestnet,\n    [RenNetwork.MainnetVDot3]: renMainnetVDot3,\n    [RenNetwork.TestnetVDot3]: renTestnetVDot3,\n    [RenNetwork.DevnetVDot3]: renDevnetVDot3,\n};\nconst isEthereumConfig = (renNetwork) => {\n    return !!renNetwork.addresses;\n};\nconst resolveNetwork = (renNetwork) => {\n    if (!renNetwork) {\n        return EthereumConfigMap[RenNetwork.Mainnet];\n    }\n    let networkConfig;\n    if (renNetwork && isEthereumConfig(renNetwork)) {\n        networkConfig = renNetwork;\n    }\n    else if (renNetwork) {\n        const networkDetails = getRenNetworkDetails(renNetwork);\n        if (EthereumConfigMap[networkDetails.name]) {\n            networkConfig = EthereumConfigMap[networkDetails.name];\n        }\n    }\n    if (!networkConfig) {\n        throw new Error(`Unrecognized network ${typeof renNetwork === \"string\" ? renNetwork : renNetwork.name}.`);\n    }\n    return networkConfig;\n};\nexport class EthereumBaseChain {\n    constructor(web3Provider, renNetwork) {\n        this.chain = EthereumBaseChain.chain;\n        this.name = EthereumBaseChain.chain;\n        this.legacyName = \"Eth\";\n        this.logRequestLimit = undefined;\n        this.configMap = EthereumConfigMap;\n        this.utils = utilsWithChainNetwork(EthereumBaseChain.utils, () => this.renNetworkDetails);\n        this.getTokenContractAddress = (asset) => __awaiter(this, void 0, void 0, function* () {\n            if (!this.web3 || !this.renNetworkDetails) {\n                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n            }\n            return getTokenAddress(this.renNetworkDetails, this.web3, asset);\n        });\n        this.getGatewayContractAddress = (token) => __awaiter(this, void 0, void 0, function* () {\n            if (!this.web3 || !this.renNetworkDetails) {\n                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n            }\n            const gatewayAddress = yield getGatewayAddress(this.renNetworkDetails, this.web3, token);\n            if (gatewayAddress === \"0x0000000000000000000000000000000000000000\") {\n                throw new Error(`Asset not supported on mint-chain.`);\n            }\n            return gatewayAddress;\n        });\n        this.withProvider = (web3Provider) => {\n            this.web3 = new Web3(web3Provider);\n            return this;\n        };\n        /**\n         * See [LockChain.initialize].\n         */\n        this.initialize = (renNetwork) => {\n            this.renNetworkDetails =\n                this.renNetworkDetails ||\n                    EthereumConfigMap[getRenNetworkDetails(renNetwork).name];\n            if (!this.renNetworkDetails) {\n                throw new Error(`Unable to set ${this.name} network for RenVM network ${getRenNetworkDetails(renNetwork).name}. Please provide ${this.name} network details to ${this.name} constructor.`);\n            }\n            return this;\n        };\n        // Supported assets\n        this.assetIsNative = (asset) => {\n            return asset === \"ETH\";\n        };\n        /**\n         * `assetIsSupported` should return true if the asset is native to the\n         * MintChain.\n         *\n         * ```ts\n         * ethereum.assetIsSupported = asset => asset === \"ETH\";\n         * ```\n         */\n        this.assetIsSupported = (asset) => __awaiter(this, void 0, void 0, function* () {\n            if (this.assetIsNative(asset)) {\n                return true;\n            }\n            if (!this.web3 || !this.renNetworkDetails) {\n                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n            }\n            // Check that there's a gateway contract for the asset.\n            try {\n                return !!(yield this.getGatewayContractAddress(asset));\n            }\n            catch (error) {\n                if (/(Empty address returned)|(Asset not supported on mint-chain)/.exec(String((error || {}).message))) {\n                    // Ignore\n                }\n                else {\n                    console.warn(error);\n                }\n                return false;\n            }\n        });\n        /**\n         * `assetDecimals` should return the number of decimals of the asset.\n         *\n         * If the asset is not supported, an error should be thrown.\n         *\n         \n         */\n        this.assetDecimals = (asset) => __awaiter(this, void 0, void 0, function* () {\n            if (!this.web3) {\n                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n            }\n            if (asset === \"ETH\") {\n                return 18;\n            }\n            const tokenAddress = yield this.getTokenContractAddress(asset);\n            const decimalsABI = {\n                constant: true,\n                inputs: [],\n                name: \"decimals\",\n                outputs: [\n                    {\n                        internalType: \"uint256\",\n                        name: \"\",\n                        type: \"uint256\",\n                    },\n                ],\n                payable: false,\n                stateMutability: \"view\",\n                type: \"function\",\n            };\n            const tokenContract = new this.web3.eth.Contract([decimalsABI], tokenAddress);\n            const decimalsRaw = yield yield tokenContract.methods.decimals().call();\n            return new BigNumber(decimalsRaw).toNumber();\n        });\n        this.transactionID = (transaction) => {\n            return transaction || \"\";\n        };\n        this.transactionIDFromRPCFormat = (txid, txindex) => this.transactionID(this.transactionFromRPCFormat(txid, txindex));\n        this.transactionFromRPCFormat = (txid, _txindex) => Ox(txid);\n        /**\n         * @deprecated Renamed to `transactionFromRPCFormat`.\n         * Will be removed in 3.0.0.\n         */\n        this.transactionFromID = this.transactionFromRPCFormat;\n        this.transactionConfidence = (transaction) => __awaiter(this, void 0, void 0, function* () {\n            if (!this.web3 || !this.renNetworkDetails) {\n                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n            }\n            if (transaction === null) {\n                throw new Error(`Unable to fetch transaction confidence, transaction hash is 'null'.`);\n            }\n            const currentBlock = new BigNumber((yield this.web3.eth.getBlockNumber()).toString());\n            const receipt = yield this.web3.eth.getTransactionReceipt(transaction);\n            let current = 0;\n            if (receipt.blockNumber) {\n                const transactionBlock = new BigNumber(receipt.blockNumber.toString());\n                current = currentBlock.minus(transactionBlock).plus(1).toNumber();\n            }\n            return {\n                current,\n                target: this.renNetworkDetails.isTestnet ? 15 : 30,\n            };\n        });\n        this.submitMint = (asset, contractCalls, mintTx, eventEmitter) => __awaiter(this, void 0, void 0, function* () {\n            if (!mintTx.out) {\n                throw new Error(`No signature passed to mint submission.`);\n            }\n            if (mintTx.out.revert !== undefined) {\n                throw new Error(`Unable to submit reverted RenVM transaction.`);\n            }\n            if (!this.web3) {\n                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n            }\n            const existingTransaction = yield this.findTransaction(asset, mintTx.out.nhash, mintTx.out.sighash);\n            if (existingTransaction) {\n                yield manualPromiEvent(this.web3, existingTransaction, eventEmitter);\n                return existingTransaction;\n            }\n            return yield submitToEthereum(this.web3, contractCalls, mintTx, eventEmitter);\n        });\n        this.findTransaction = (asset, nHash, sigHash) => __awaiter(this, void 0, void 0, function* () {\n            if (!this.renNetworkDetails || !this.web3) {\n                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n            }\n            return findTransactionBySigHash(this.renNetworkDetails, this.web3, asset, nHash, sigHash, this.logRequestLimit);\n        });\n        this.resolveTokenGatewayContract = (asset) => __awaiter(this, void 0, void 0, function* () {\n            if (!this.renNetworkDetails || !this.web3) {\n                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n            }\n            return Ox(yield getTokenAddress(this.renNetworkDetails, this.web3, asset));\n        });\n        /**\n         * Read a burn reference from an Ethereum transaction - or submit a\n         * transaction first if the transaction details have been provided.\n         */\n        this.findBurnTransaction = (asset, \n        // Once of the following should not be undefined.\n        burn, eventEmitter, logger, timeout) => __awaiter(this, void 0, void 0, function* () {\n            if (!this.renNetworkDetails || !this.web3) {\n                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n            }\n            const { burnNonce, contractCalls } = burn;\n            let { transaction } = burn;\n            if (!transaction && burnNonce) {\n                return findBurnByNonce(this.renNetworkDetails, this.web3, asset, burnNonce.toString());\n            }\n            // There are three parameter configs:\n            // Situation (1): A `burnNonce` is provided\n            // Situation (2): Contract call details are provided\n            // Situation (3): A transaction is provided\n            // Handle situation (2)\n            // Make a call to the provided contract and Pass on the\n            // transaction hash.\n            if (!transaction && contractCalls) {\n                for (let i = 0; i < contractCalls.length; i++) {\n                    const contractCall = contractCalls[i];\n                    const last = i === contractCalls.length - 1;\n                    const { contractParams, contractFn, sendTo } = contractCall;\n                    const callParams = [\n                        ...(contractParams || []).map((value) => value.value),\n                    ];\n                    const ABI = payloadToABI(contractFn, contractParams);\n                    const contract = new this.web3.eth.Contract(ABI, sendTo);\n                    const txConfig = typeof contractCall === \"object\"\n                        ? contractCall.txConfig\n                        : {};\n                    const config = yield withDefaultAccount(this.web3, Object.assign(Object.assign({}, txConfig), {\n                        value: txConfig && txConfig.value\n                            ? txConfig.value.toString()\n                            : undefined,\n                        gasPrice: txConfig && txConfig.gasPrice\n                            ? txConfig.gasPrice.toString()\n                            : undefined,\n                    }));\n                    logger.debug(\"Calling Ethereum contract\", contractFn, sendTo, ...callParams, config);\n                    const tx = contract.methods[contractFn](...callParams).send(config);\n                    if (last) {\n                        forwardWeb3Events(tx, eventEmitter);\n                    }\n                    transaction = yield new Promise((resolve, reject) => tx.on(\"transactionHash\", resolve).catch((error) => {\n                        try {\n                            if (ignorePromiEventError(error)) {\n                                logger.error(extractError(error));\n                                return;\n                            }\n                        }\n                        catch (_error) {\n                            /* Ignore _error */\n                        }\n                        reject(error);\n                    }));\n                    logger.debug(\"Transaction hash\", transaction);\n                }\n            }\n            if (!transaction) {\n                throw new Error(`Unable to find burn from provided parameters.`);\n            }\n            return extractBurnDetails(this.web3, transaction, logger, timeout);\n        });\n        this.getFees = (asset) => __awaiter(this, void 0, void 0, function* () {\n            if (!this.web3) {\n                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n            }\n            const gatewayAddress = yield this.getGatewayContractAddress(asset);\n            const mintFeeABI = {\n                constant: true,\n                inputs: [],\n                name: \"mintFee\",\n                outputs: [\n                    {\n                        internalType: \"uint16\",\n                        name: \"\",\n                        type: \"uint16\",\n                    },\n                ],\n                payable: false,\n                stateMutability: \"view\",\n                type: \"function\",\n            };\n            const burnFeeABI = {\n                constant: true,\n                inputs: [],\n                name: \"burnFee\",\n                outputs: [\n                    {\n                        internalType: \"uint16\",\n                        name: \"\",\n                        type: \"uint16\",\n                    },\n                ],\n                payable: false,\n                stateMutability: \"view\",\n                type: \"function\",\n            };\n            const gatewayContract = new this.web3.eth.Contract([mintFeeABI, burnFeeABI], gatewayAddress);\n            const mintFee = yield gatewayContract.methods.mintFee().call();\n            const burnFee = yield gatewayContract.methods.burnFee().call();\n            return {\n                mint: new BigNumber(mintFee.toString()).toNumber(),\n                burn: new BigNumber(burnFee.toString()).toNumber(),\n            };\n        });\n        this.getBalance = (asset, address) => __awaiter(this, void 0, void 0, function* () {\n            const balanceOfABI = {\n                constant: true,\n                inputs: [\n                    {\n                        internalType: \"address\",\n                        name: \"account\",\n                        type: \"address\",\n                    },\n                ],\n                name: \"balanceOf\",\n                outputs: [\n                    {\n                        internalType: \"uint256\",\n                        name: \"\",\n                        type: \"uint256\",\n                    },\n                ],\n                payable: false,\n                stateMutability: \"view\",\n                type: \"function\",\n            };\n            if (!this.web3) {\n                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);\n            }\n            const tokenAddress = yield this.getTokenContractAddress(asset);\n            const tokenContract = new this.web3.eth.Contract([balanceOfABI], tokenAddress);\n            const balanceRaw = yield yield tokenContract.methods\n                .balanceOf(address)\n                .call();\n            return new BigNumber(balanceRaw.toString());\n        });\n        this.transactionRPCFormat = (transaction, _v2) => {\n            assertType(\"string | null\", { transaction });\n            if (transaction === null) {\n                throw new Error(`Unable to encode transaction, transaction hash is 'null'.`);\n            }\n            return {\n                txid: fromHex(transaction),\n                txindex: \"0\",\n            };\n        };\n        this.transactionRPCTxidFromID = (transactionID) => fromHex(transactionID);\n        this.web3 = new Web3(web3Provider);\n        if (renNetwork) {\n            this.renNetworkDetails = resolveNetwork(renNetwork);\n        }\n    }\n}\nEthereumBaseChain.chain = \"Ethereum\";\nEthereumBaseChain.configMap = EthereumConfigMap;\nEthereumBaseChain.utils = {\n    resolveChainNetwork: resolveNetwork,\n    addressIsValid,\n    transactionIsValid,\n    addressExplorerLink: (address, network) => `${(EthereumBaseChain.utils.resolveChainNetwork(network) ||\n        renMainnet).etherscan}/address/${address}`,\n    transactionExplorerLink: (transaction, network) => `${(EthereumBaseChain.utils.resolveChainNetwork(network) ||\n        renMainnet).etherscan}/tx/${transaction || \"\"}`,\n};\nconst _ = EthereumBaseChain;\n//# sourceMappingURL=base.js.map"]},"metadata":{},"sourceType":"module"}