{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { getRenNetworkDetails, NullLogger, RenJSErrors, TxStatus } from \"@renproject/interfaces\";\nimport { HttpProvider } from \"@renproject/provider\";\nimport { assertType, extractError, fromBase64, isDefined, keccak256, parseV1Selector, SECONDS, sleep, strip0x, toBase64 } from \"@renproject/utils\";\nimport { List } from \"immutable\";\nimport { RPCMethod } from \"./methods\";\nimport { unmarshalBurnTx, unmarshalFees, unmarshalMintTx } from \"./unmarshal\";\nimport { RenVMType } from \"./value\";\nexport const generateMintTxHash = (selector, encodedID, deposit, logger = NullLogger) => {\n  // Type validation\n  assertType(\"string\", {\n    encodedID,\n    deposit\n  });\n  const message = `txHash_${selector}_${encodedID}_${deposit}`;\n  const digest = keccak256(Buffer.from(message));\n  logger.debug(\"Mint txHash\", toBase64(digest), message);\n  return digest;\n};\nexport class RenVMProvider {\n  constructor(network, provider, logger = NullLogger) {\n    this.version = () => 1;\n\n    this.selector = ({\n      asset,\n      from,\n      to\n    }) => {\n      return `${asset}0${from.legacyName || from.name}2${to.legacyName || from.name}`;\n    };\n\n    this.queryBlock = (blockHeight, retry) => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.MethodQueryBlock, {\n        blockHeight\n      }, retry);\n    });\n\n    this.queryBlocks = (blockHeight, n, retry) => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.MethodQueryBlocks, {\n        blockHeight,\n        n\n      }, retry);\n    });\n\n    this.submitTx = (tx, retry) => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.MethodSubmitTx, {\n        tx\n      }, retry);\n    });\n\n    this.queryTx = (txHash, retry) => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.MethodQueryTx, {\n        txHash\n      }, retry);\n    });\n\n    this.queryTxs = (tags, page, pageSize, txStatus, retry) => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.MethodQueryTxs, {\n        tags,\n        page: (page || 0).toString(),\n        pageSize: (pageSize || 0).toString(),\n        txStatus\n      }, retry);\n    });\n\n    this.queryNumPeers = retry => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.MethodQueryNumPeers, {}, retry);\n    });\n\n    this.queryPeers = retry => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.MethodQueryPeers, {}, retry);\n    });\n\n    this.queryShards = retry => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.MethodQueryShards, {}, retry);\n    });\n\n    this.queryStat = retry => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.MethodQueryStat, {}, retry);\n    });\n\n    this.queryFees = retry => __awaiter(this, void 0, void 0, function* () {\n      return this.sendMessage(RPCMethod.MethodQueryFees, {}, retry);\n    });\n\n    this.getFees = () => __awaiter(this, void 0, void 0, function* () {\n      return unmarshalFees(yield this.queryFees());\n    });\n\n    this.mintTxHash = ({\n      selector,\n      gHash,\n      outputHashFormat\n    }) => {\n      assertType(\"Buffer\", {\n        gHash\n      });\n      assertType(\"string\", {\n        outputHashFormat\n      });\n      return generateMintTxHash(selector, toBase64(gHash), outputHashFormat, this.logger);\n    };\n\n    this.submitMint = ({\n      selector,\n      nonce,\n      output,\n      payload,\n      to,\n      token,\n      fn,\n      fnABI,\n      tags\n    }) => __awaiter(this, void 0, void 0, function* () {\n      const {\n        txindex,\n        txid\n      } = output;\n      assertType(\"Buffer\", {\n        nonce,\n        payload,\n        txid\n      });\n      assertType(\"string\", {\n        to,\n        token,\n        fn,\n        txindex\n      });\n      const response = yield this.sendMessage(RPCMethod.MethodSubmitTx, {\n        tx: {\n          to: selector,\n          in: [//\n          {\n            name: \"p\",\n            type: RenVMType.ExtEthCompatPayload,\n            value: {\n              abi: toBase64(Buffer.from(JSON.stringify(fnABI))),\n              value: toBase64(payload),\n              fn: toBase64(Buffer.from(fn))\n            }\n          }, // The hash of the payload data\n          // { name: \"phash\" as const, type: RenVMType.B32 as const, value: toBase64(pHash) },\n          // The amount of BTC (in SATs) that has be transferred to the gateway\n          // { name: \"amount\" as const, type: \"u64\", as const value: amount },\n          // The ERC20 contract address on Ethereum for BTC\n          {\n            name: \"token\",\n            type: RenVMType.ExtTypeEthCompatAddress,\n            value: strip0x(token)\n          }, // The address on the Ethereum blockchain to which BTC will be transferred\n          {\n            name: \"to\",\n            type: RenVMType.ExtTypeEthCompatAddress,\n            value: strip0x(to)\n          }, // The nonce is used to randomize the gateway\n          {\n            name: \"n\",\n            type: RenVMType.B32,\n            value: toBase64(nonce)\n          }, // UTXO\n          {\n            name: \"utxo\",\n            type: RenVMType.ExtTypeBtcCompatUTXO,\n            value: {\n              txHash: toBase64(txid),\n              vOut: txindex\n            }\n          }]\n        },\n        tags\n      });\n      return fromBase64(response.tx.hash);\n    });\n\n    this.submitBurn = params => __awaiter(this, void 0, void 0, function* () {\n      const {\n        selector,\n        burnNonce,\n        tags\n      } = params;\n      const response = yield this.sendMessage(RPCMethod.MethodSubmitTx, {\n        tx: {\n          to: selector,\n          in: [{\n            name: \"ref\",\n            type: RenVMType.U64,\n            value: burnNonce.decimalPlaces(0).toFixed()\n          }]\n        },\n        tags\n      });\n      return fromBase64(response.tx.hash);\n    });\n\n    this.queryMintOrBurn = (_selector, utxoTxHash, retries) => __awaiter(this, void 0, void 0, function* () {\n      const response = yield this.queryTx(toBase64(utxoTxHash), retries); // Unmarshal transaction.\n\n      const {\n        asset,\n        from\n      } = parseV1Selector(response.tx.to);\n\n      if (asset.toUpperCase() === from.toUpperCase()) {\n        return unmarshalMintTx(response);\n      } else {\n        return unmarshalBurnTx(response);\n      }\n    });\n\n    this.waitForTX = (selector, utxoTxHash, onStatus, _cancelRequested, timeout) => __awaiter(this, void 0, void 0, function* () {\n      assertType(\"Buffer\", {\n        utxoTxHash\n      });\n      let rawResponse;\n\n      while (true) {\n        if (_cancelRequested && _cancelRequested()) {\n          throw new Error(`waitForTX cancelled`);\n        }\n\n        try {\n          const result = yield this.queryMintOrBurn(selector, utxoTxHash);\n\n          if (result && result.txStatus === TxStatus.TxStatusDone) {\n            rawResponse = result;\n            break;\n          } else if (onStatus && result && result.txStatus) {\n            onStatus(result.txStatus);\n          }\n        } catch (error) {\n          if (/(not found)|(not available)/.exec(String((error || {}).message))) {// ignore\n          } else {\n            this.logger.error(String(error)); // TODO: throw unexpected errors\n          }\n        }\n\n        yield sleep(isDefined(timeout) ? timeout : 15 * SECONDS);\n      }\n\n      return rawResponse;\n    });\n    /**\n     * selectPublicKey fetches the public key for the RenVM shard handling\n     * the provided contract.\n     *\n     * @param asset The asset for which the public key should be fetched.\n     * @returns The public key hash (20 bytes) as a string.\n     */\n\n\n    this.selectPublicKey = (_selector, asset) => __awaiter(this, void 0, void 0, function* () {\n      // Call the ren_queryShards RPC.\n      const response = yield this.queryShards(5); // Prioritize primary shards.\n\n      const chosenShard = response.shards.sort((a, b) => a.primary && b.primary ? -1 : a.primary ? -1 : b.primary ? 1 : 0)[0];\n\n      if (!chosenShard) {\n        throw new Error(\"Unable to load public key from RenVM: no shards found\");\n      } // Get the gateway pubKey from the gateway with the right asset within\n      // the shard with the lowest total value locked.\n\n\n      const tokenGateway = List(chosenShard.gateways).filter(gateway => gateway.asset === asset).first(undefined);\n\n      if (!tokenGateway) {\n        throw new Error(`Unable to load public key from RenVM: no gateway for the asset ${asset}`);\n      } // Use this gateway pubKey to build the gateway address.\n      // return hash160(\n\n\n      return fromBase64(tokenGateway.pubKey);\n    }); // In the future, this will be asynchronous. It returns a promise for\n    // compatibility.\n    // eslint-disable-next-line @typescript-eslint/require-await\n\n\n    this.getNetwork = _selector => __awaiter(this, void 0, void 0, function* () {\n      return this.network;\n    });\n\n    this.getConfirmationTarget = (selector, _chain) => __awaiter(this, void 0, void 0, function* () {\n      const {\n        asset\n      } = parseV1Selector(selector);\n\n      switch (this.network) {\n        case \"mainnet\":\n          switch (asset) {\n            case \"BTC\":\n              return 6;\n\n            case \"ZEC\":\n              return 24;\n\n            case \"BCH\":\n              return 15;\n\n            case \"ETH\":\n              return 30;\n          }\n\n          break;\n\n        case \"testnet\":\n          switch (asset) {\n            case \"BTC\":\n              return 2;\n\n            case \"ZEC\":\n              return 6;\n\n            case \"BCH\":\n              return 2;\n\n            case \"ETH\":\n              return 12;\n          }\n\n          break;\n      }\n\n      return undefined;\n    });\n\n    this.estimateTransactionFee = (_asset, _lockChain, hostChain) => __awaiter(this, void 0, void 0, function* () {\n      const allFees = yield this.getFees();\n      const fees = allFees[hostChain.legacyName ? hostChain.legacyName.toLowerCase() : hostChain.name.toLowerCase()];\n      return Object.assign(Object.assign({}, fees), {\n        mint: 25,\n        burn: 15\n      });\n    });\n\n    if (!provider) {\n      const rpcUrl = (getRenNetworkDetails(network) || {}).lightnode;\n\n      try {\n        provider = new HttpProvider(rpcUrl, logger);\n      } catch (error) {\n        if (/Invalid node URL/.exec(String(error && error.message))) {\n          throw new Error(`Invalid network or provider URL: \"${(getRenNetworkDetails(network) || {}).name || String(network)}\"`);\n        }\n\n        throw error;\n      }\n    }\n\n    this.network = network;\n    this.logger = logger;\n    this.provider = provider;\n\n    this.sendMessage = (method, request, retry = 2, timeout = 120 * SECONDS) => __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield this.provider.sendMessage(method, request, retry, timeout);\n      } catch (error) {\n        const errorString = extractError(error);\n\n        if (/(tx hash=[a-zA-Z0-9+\\/=]+ not found)/.exec(errorString)) {\n          error.code = RenJSErrors.RenVMTransactionNotFound;\n        }\n\n        if (/(insufficient funds)/.exec(errorString)) {\n          error.code = RenJSErrors.AmountTooSmall;\n        }\n\n        if (/(utxo spent or invalid index)/.exec(errorString)) {\n          error.code = RenJSErrors.DepositSpentOrNotFound;\n        }\n\n        throw error;\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/v1/renVMProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getRenNetworkDetails, NullLogger, RenJSErrors, TxStatus, } from \"@renproject/interfaces\";\nimport { HttpProvider } from \"@renproject/provider\";\nimport { assertType, extractError, fromBase64, isDefined, keccak256, parseV1Selector, SECONDS, sleep, strip0x, toBase64, } from \"@renproject/utils\";\nimport { List } from \"immutable\";\nimport { RPCMethod, } from \"./methods\";\nimport { unmarshalBurnTx, unmarshalFees, unmarshalMintTx } from \"./unmarshal\";\nimport { RenVMType } from \"./value\";\nexport const generateMintTxHash = (selector, encodedID, deposit, logger = NullLogger) => {\n    // Type validation\n    assertType(\"string\", { encodedID, deposit });\n    const message = `txHash_${selector}_${encodedID}_${deposit}`;\n    const digest = keccak256(Buffer.from(message));\n    logger.debug(\"Mint txHash\", toBase64(digest), message);\n    return digest;\n};\nexport class RenVMProvider {\n    constructor(network, provider, logger = NullLogger) {\n        this.version = () => 1;\n        this.selector = ({ asset, from, to, }) => {\n            return `${asset}0${from.legacyName || from.name}2${to.legacyName || from.name}`;\n        };\n        this.queryBlock = (blockHeight, retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.MethodQueryBlock, { blockHeight }, retry);\n        });\n        this.queryBlocks = (blockHeight, n, retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.MethodQueryBlocks, { blockHeight, n }, retry);\n        });\n        this.submitTx = (tx, retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.MethodSubmitTx, { tx }, retry);\n        });\n        this.queryTx = (txHash, retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.MethodQueryTx, { txHash }, retry);\n        });\n        this.queryTxs = (tags, page, pageSize, txStatus, retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.MethodQueryTxs, {\n                tags,\n                page: (page || 0).toString(),\n                pageSize: (pageSize || 0).toString(),\n                txStatus,\n            }, retry);\n        });\n        this.queryNumPeers = (retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.MethodQueryNumPeers, {}, retry);\n        });\n        this.queryPeers = (retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.MethodQueryPeers, {}, retry);\n        });\n        this.queryShards = (retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.MethodQueryShards, {}, retry);\n        });\n        this.queryStat = (retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.MethodQueryStat, {}, retry);\n        });\n        this.queryFees = (retry) => __awaiter(this, void 0, void 0, function* () {\n            return this.sendMessage(RPCMethod.MethodQueryFees, {}, retry);\n        });\n        this.getFees = () => __awaiter(this, void 0, void 0, function* () { return unmarshalFees(yield this.queryFees()); });\n        this.mintTxHash = ({ selector, gHash, outputHashFormat, }) => {\n            assertType(\"Buffer\", { gHash });\n            assertType(\"string\", { outputHashFormat });\n            return generateMintTxHash(selector, toBase64(gHash), outputHashFormat, this.logger);\n        };\n        this.submitMint = ({ selector, nonce, output, payload, to, token, fn, fnABI, tags, }) => __awaiter(this, void 0, void 0, function* () {\n            const { txindex, txid } = output;\n            assertType(\"Buffer\", { nonce, payload, txid });\n            assertType(\"string\", { to, token, fn, txindex });\n            const response = yield this.sendMessage(RPCMethod.MethodSubmitTx, {\n                tx: {\n                    to: selector,\n                    in: [\n                        //\n                        {\n                            name: \"p\",\n                            type: RenVMType.ExtEthCompatPayload,\n                            value: {\n                                abi: toBase64(Buffer.from(JSON.stringify(fnABI))),\n                                value: toBase64(payload),\n                                fn: toBase64(Buffer.from(fn)),\n                            },\n                        },\n                        // The hash of the payload data\n                        // { name: \"phash\" as const, type: RenVMType.B32 as const, value: toBase64(pHash) },\n                        // The amount of BTC (in SATs) that has be transferred to the gateway\n                        // { name: \"amount\" as const, type: \"u64\", as const value: amount },\n                        // The ERC20 contract address on Ethereum for BTC\n                        {\n                            name: \"token\",\n                            type: RenVMType.ExtTypeEthCompatAddress,\n                            value: strip0x(token),\n                        },\n                        // The address on the Ethereum blockchain to which BTC will be transferred\n                        {\n                            name: \"to\",\n                            type: RenVMType.ExtTypeEthCompatAddress,\n                            value: strip0x(to),\n                        },\n                        // The nonce is used to randomize the gateway\n                        {\n                            name: \"n\",\n                            type: RenVMType.B32,\n                            value: toBase64(nonce),\n                        },\n                        // UTXO\n                        {\n                            name: \"utxo\",\n                            type: RenVMType.ExtTypeBtcCompatUTXO,\n                            value: {\n                                txHash: toBase64(txid),\n                                vOut: txindex,\n                            },\n                        },\n                    ],\n                },\n                tags,\n            });\n            return fromBase64(response.tx.hash);\n        });\n        this.submitBurn = (params) => __awaiter(this, void 0, void 0, function* () {\n            const { selector, burnNonce, tags } = params;\n            const response = yield this.sendMessage(RPCMethod.MethodSubmitTx, {\n                tx: {\n                    to: selector,\n                    in: [\n                        {\n                            name: \"ref\",\n                            type: RenVMType.U64,\n                            value: burnNonce.decimalPlaces(0).toFixed(),\n                        },\n                    ],\n                },\n                tags,\n            });\n            return fromBase64(response.tx.hash);\n        });\n        this.queryMintOrBurn = (_selector, utxoTxHash, retries) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryTx(toBase64(utxoTxHash), retries);\n            // Unmarshal transaction.\n            const { asset, from } = parseV1Selector(response.tx.to);\n            if (asset.toUpperCase() === from.toUpperCase()) {\n                return unmarshalMintTx(response);\n            }\n            else {\n                return unmarshalBurnTx(response);\n            }\n        });\n        this.waitForTX = (selector, utxoTxHash, onStatus, _cancelRequested, timeout) => __awaiter(this, void 0, void 0, function* () {\n            assertType(\"Buffer\", { utxoTxHash });\n            let rawResponse;\n            while (true) {\n                if (_cancelRequested && _cancelRequested()) {\n                    throw new Error(`waitForTX cancelled`);\n                }\n                try {\n                    const result = yield this.queryMintOrBurn(selector, utxoTxHash);\n                    if (result && result.txStatus === TxStatus.TxStatusDone) {\n                        rawResponse = result;\n                        break;\n                    }\n                    else if (onStatus && result && result.txStatus) {\n                        onStatus(result.txStatus);\n                    }\n                }\n                catch (error) {\n                    if (/(not found)|(not available)/.exec(String((error || {}).message))) {\n                        // ignore\n                    }\n                    else {\n                        this.logger.error(String(error));\n                        // TODO: throw unexpected errors\n                    }\n                }\n                yield sleep(isDefined(timeout) ? timeout : 15 * SECONDS);\n            }\n            return rawResponse;\n        });\n        /**\n         * selectPublicKey fetches the public key for the RenVM shard handling\n         * the provided contract.\n         *\n         * @param asset The asset for which the public key should be fetched.\n         * @returns The public key hash (20 bytes) as a string.\n         */\n        this.selectPublicKey = (_selector, asset) => __awaiter(this, void 0, void 0, function* () {\n            // Call the ren_queryShards RPC.\n            const response = yield this.queryShards(5);\n            // Prioritize primary shards.\n            const chosenShard = response.shards.sort((a, b) => a.primary && b.primary ? -1 : a.primary ? -1 : b.primary ? 1 : 0)[0];\n            if (!chosenShard) {\n                throw new Error(\"Unable to load public key from RenVM: no shards found\");\n            }\n            // Get the gateway pubKey from the gateway with the right asset within\n            // the shard with the lowest total value locked.\n            const tokenGateway = List(chosenShard.gateways)\n                .filter((gateway) => gateway.asset === asset)\n                .first(undefined);\n            if (!tokenGateway) {\n                throw new Error(`Unable to load public key from RenVM: no gateway for the asset ${asset}`);\n            }\n            // Use this gateway pubKey to build the gateway address.\n            // return hash160(\n            return fromBase64(tokenGateway.pubKey);\n        });\n        // In the future, this will be asynchronous. It returns a promise for\n        // compatibility.\n        // eslint-disable-next-line @typescript-eslint/require-await\n        this.getNetwork = (_selector) => __awaiter(this, void 0, void 0, function* () {\n            return this.network;\n        });\n        this.getConfirmationTarget = (selector, _chain) => __awaiter(this, void 0, void 0, function* () {\n            const { asset } = parseV1Selector(selector);\n            switch (this.network) {\n                case \"mainnet\":\n                    switch (asset) {\n                        case \"BTC\":\n                            return 6;\n                        case \"ZEC\":\n                            return 24;\n                        case \"BCH\":\n                            return 15;\n                        case \"ETH\":\n                            return 30;\n                    }\n                    break;\n                case \"testnet\":\n                    switch (asset) {\n                        case \"BTC\":\n                            return 2;\n                        case \"ZEC\":\n                            return 6;\n                        case \"BCH\":\n                            return 2;\n                        case \"ETH\":\n                            return 12;\n                    }\n                    break;\n            }\n            return undefined;\n        });\n        this.estimateTransactionFee = (_asset, _lockChain, hostChain) => __awaiter(this, void 0, void 0, function* () {\n            const allFees = yield this.getFees();\n            const fees = allFees[hostChain.legacyName\n                ? hostChain.legacyName.toLowerCase()\n                : hostChain.name.toLowerCase()];\n            return Object.assign(Object.assign({}, fees), { mint: 25, burn: 15 });\n        });\n        if (!provider) {\n            const rpcUrl = (getRenNetworkDetails(network) || {}).lightnode;\n            try {\n                provider = new HttpProvider(rpcUrl, logger);\n            }\n            catch (error) {\n                if (/Invalid node URL/.exec(String(error && error.message))) {\n                    throw new Error(`Invalid network or provider URL: \"${(getRenNetworkDetails(network) || {}).name ||\n                        String(network)}\"`);\n                }\n                throw error;\n            }\n        }\n        this.network = network;\n        this.logger = logger;\n        this.provider = provider;\n        this.sendMessage = (method, request, retry = 2, timeout = 120 * SECONDS) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                return yield this.provider.sendMessage(method, request, retry, timeout);\n            }\n            catch (error) {\n                const errorString = extractError(error);\n                if (/(tx hash=[a-zA-Z0-9+\\/=]+ not found)/.exec(errorString)) {\n                    error.code = RenJSErrors.RenVMTransactionNotFound;\n                }\n                if (/(insufficient funds)/.exec(errorString)) {\n                    error.code = RenJSErrors.AmountTooSmall;\n                }\n                if (/(utxo spent or invalid index)/.exec(errorString)) {\n                    error.code = RenJSErrors.DepositSpentOrNotFound;\n                }\n                throw error;\n            }\n        });\n    }\n}\n//# sourceMappingURL=renVMProvider.js.map"]},"metadata":{},"sourceType":"module"}