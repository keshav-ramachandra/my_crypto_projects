{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { getRenNetworkDetails, newPromiEvent, NullLogger, RenJSErrors, TxStatus, TxStatusIndex } from \"@renproject/interfaces\";\nimport { assertObject, assertType, emptyNonce, extractError, fromBase64, fromHex, generateGHash, generateNHash, generatePHash, generateSHash, isDefined, keccak256, overrideContractCalls, Ox, payloadToMintABI, renVMHashToBase64, retryNTimes, SECONDS, sleep, strip0x, toBase64, toURLBase64 } from \"@renproject/utils\";\nimport { EventEmitter } from \"events\";\nimport { OrderedMap } from \"immutable\";\nimport AbiCoder from \"web3-eth-abi\";\nimport base58 from \"bs58\";\n/**\n * A `LockAndMint` object tied to a particular gateway address. LockAndMint\n * should not be created directly. Instead, [[RenJS.lockAndMint]] will create a\n * `LockAndMint` object.\n *\n * `LockAndMint` extends the EventEmitter class, and emits a `\"deposit\"` event\n * for each new deposit that is observed. Deposits will only be watched for if\n * there is an active listener for the `\"deposit\"` event.\n *\n * A LockAndMint object watches transactions to the [[gatewayAddress]] on the\n * lock-chain.\n *\n * Deposits to the gateway address can be listened to with the `\"deposit\"`\n * event using [[on]], which will return [[LockAndMintDeposit]] instances.\n *\n * ```ts\n * console.log(`Deposit to ${JSON.stringify(lockAndMint.gatewayAddress)}`);\n *\n * lockAndMint.on(\"deposit\", async (deposit) => {\n *    console.log(`Received deposit`, deposit);\n *    await RenJS.defaultDepositHandler(deposit);\n * });\n * ```\n *\n * @noInheritDoc\n */\n\nexport class LockAndMint extends EventEmitter {\n  /**\n   * @hidden - should be created using [[RenJS.lockAndMint]] instead.\n   */\n  constructor(renVM, params, config = {}) {\n    super();\n    /**\n     * Deposits represents the lock deposits that have been detected so far.\n     */\n\n    this.deposits = OrderedMap();\n\n    this.confirmationTarget = () => __awaiter(this, void 0, void 0, function* () {\n      if (isDefined(this._state.targetConfirmations)) {\n        return this._state.targetConfirmations;\n      }\n\n      let target;\n      const getConfirmationTarget = this.renVM.getConfirmationTarget;\n\n      if (getConfirmationTarget) {\n        target = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {\n          return getConfirmationTarget(this._state.selector, this.params.from);\n        }), 2);\n      }\n\n      const defaultConfirmations = this._state.renNetwork && this._state.renNetwork.isTestnet ? 2 : 6;\n      this._state.targetConfirmations = isDefined(target) ? target : defaultConfirmations;\n      return this._state.targetConfirmations;\n    });\n    /**\n     * @hidden - Called automatically when calling [[RenJS.lockAndMint]]. It has\n     * been split from the constructor because it's asynchronous.\n     */\n\n\n    this._initialize = () => __awaiter(this, void 0, void 0, function* () {\n      this._state.renNetwork = this._state.renNetwork || getRenNetworkDetails(yield this.renVM.getNetwork(this._state.selector));\n\n      if (!this.params.from.renNetwork) {\n        yield this.params.from.initialize(this._state.renNetwork);\n      }\n\n      if (!this.params.to.renNetwork) {\n        yield this.params.to.initialize(this._state.renNetwork);\n      }\n\n      const overwriteParams = this.params.to.getMintParams && (yield this.params.to.getMintParams(this.params.asset));\n      this.params = Object.assign(Object.assign({}, overwriteParams), this.params);\n\n      try {\n        this.gatewayAddress = yield this.generateGatewayAddress();\n      } catch (error) {\n        throw error;\n      } // Will fetch deposits as long as there's at least one deposit.\n\n\n      this.wait().catch(console.error);\n\n      try {\n        this._state.targetConfirmations = yield this.confirmationTarget();\n      } catch (error) {\n        console.error(error);\n      }\n\n      return this;\n    });\n    /**\n     * `processDeposit` allows you to manually provide the details of a deposit\n     * and returns a [[LockAndMintDeposit]] object.\n     *\n     * @param deposit The deposit details in the format defined by the\n     * LockChain. This should be the same format as `deposit.depositDetails` for\n     * a deposit returned from `.on(\"deposit\", ...)`.\n     *\n     * ```ts\n     * lockAndMint\n     *   .processDeposit({\n     *       transaction: {\n     *           cid:\n     *               \"bafy2bzacedvu74e7ohjcwlh4fbx7ddf6li42fiuosajob6metcj2qwkgkgof2\",\n     *           to: \"t1v2ftlxhedyoijv7uqgxfygiziaqz23lgkvks77i\",\n     *           amount: (0.01 * 1e8).toString(),\n     *           params: \"EzGbvVHf8lb0v8CUfjh8y+tLbZzfIFcnNnt/gh6axmw=\",\n     *           confirmations: 1,\n     *           nonce: 7,\n     *       },\n     *       amount: (0.01 * 1e8).toString(),\n     *   })\n     *   .on(deposit => RenJS.defaultDepositHandler)\n     *   .catch(console.error);\n     * ```\n     *\n     * @category Main\n     */\n\n\n    this.processDeposit = deposit => __awaiter(this, void 0, void 0, function* () {\n      if (!this._state.renNetwork || !this._state.pHash || !this._state.gHash || !this._state.gPubKey || !this.gatewayAddress) {\n        throw new Error(\"Gateway address must be generated before calling 'wait'.\");\n      }\n\n      const depositID = this.params.from.transactionID(deposit.transaction);\n      let depositObject = this.deposits.get(depositID); // If the confidence has increased.\n\n      if (!depositObject // || (existingConfidenceRatio !== undefined &&\n      // confidenceRatio > existingConfidenceRatio)\n      ) {\n        depositObject = new LockAndMintDeposit(deposit, this.params, this.renVM, Object.assign(Object.assign({}, this._state), {\n          renNetwork: this._state.renNetwork,\n          pHash: this._state.pHash,\n          gHash: this._state.gHash,\n          gPubKey: this._state.gPubKey,\n          token: this._state.token,\n          targetConfirmations: isDefined(this._state.targetConfirmations) ? this._state.targetConfirmations : undefined\n        }), this.gatewayAddress);\n        yield depositObject._initialize(); // Check if deposit has already been submitted.\n\n        if (this._state.config.loadCompletedDeposits || depositObject.status !== DepositStatus.Submitted) {\n          this.emit(\"deposit\", depositObject); // this.deposits.set(deposit);\n\n          this._state.logger.debug(\"new deposit:\", deposit);\n\n          this.deposits = this.deposits.set(depositID, depositObject);\n        }\n      }\n\n      return depositObject;\n    });\n\n    this.addListener = (event, listener) => {\n      // Emit previous deposit events.\n      if (event === \"deposit\") {\n        this.deposits.map(deposit => {\n          listener(deposit);\n        });\n      }\n\n      super.on(event, listener);\n      return this;\n    };\n    /**\n     * `on` creates a new listener to `\"deposit\"` events, returning\n     * [[LockAndMintDeposit]] instances.\n     *\n     * `on` extends `EventEmitter.on`, modifying it to immediately return all\n     * previous `\"deposit\"` events, in addition to new events, when a new\n     * listener is created.\n     *\n     * @category Main\n     */\n\n\n    this.on = (event, listener) => this.addListener(event, listener); // Private methods /////////////////////////////////////////////////////////\n\n\n    this.generateGatewayAddress = () => __awaiter(this, void 0, void 0, function* () {\n      if (this.gatewayAddress) {\n        return this.gatewayAddress;\n      }\n\n      const {\n        nonce,\n        contractCalls\n      } = this.params;\n\n      if (!nonce) {\n        throw new Error(`Must call 'initialize' before calling 'generateGatewayAddress'.`);\n      }\n\n      if (!contractCalls) {\n        throw new Error(`Must provide contract call details.`);\n      } // Last contract call\n\n\n      const {\n        contractParams,\n        sendTo,\n        contractFn\n      } = contractCalls[contractCalls.length - 1]; // FIXME: dirty hack, but we need to re-write how we deal with\n      // addresses in order to do this cleanly\n      // (need to follow the multichain address pattern)\n\n      const sendToHex = this.params.to.name == \"Solana\" ? base58.decode(sendTo).toString(\"hex\") : sendTo;\n      this._state.pHash = generatePHash(contractParams || [], this._state.logger); // Check if the transaction is either a v0.2 transaction, or has the\n      // version set to `0` in a v0.4 transaction.\n      // See [RenJSConfig.transactionVersion]\n\n      const v0Transaction = this.renVM.version(this._state.selector) === 1 || this._state.config.transactionVersion === 0;\n      const tokenGatewayContract = !v0Transaction ? Ox(generateSHash(this._state.selector)) : yield this.params.to.resolveTokenGatewayContract(this.params.asset);\n      const gHash = generateGHash(contractParams || [], sendToHex, tokenGatewayContract, fromHex(nonce), !v0Transaction, this._state.logger);\n      this._state.gHash = gHash;\n      this._state.gPubKey = this._state.config.gPubKey || (yield this.renVM.selectPublicKey(this._state.selector, this.renVM.version(this._state.selector) >= 2 ? this.params.from.name : this.params.asset));\n\n      this._state.logger.debug(\"gPubKey:\", Ox(this._state.gPubKey));\n\n      const gatewayAddress = yield this.params.from.getGatewayAddress(this.params.asset, this._state.gPubKey, gHash);\n      this.gatewayAddress = gatewayAddress;\n\n      this._state.logger.debug(\"gateway address:\", this.gatewayAddress);\n\n      const filteredContractParams = contractParams ? contractParams.filter(contractParam => !contractParam.notInPayload) : contractParams;\n      const encodedParameters = AbiCoder.encodeParameters((filteredContractParams || []).map(i => i.type), (filteredContractParams || []).map(i => i.value));\n      const fnABI = payloadToMintABI(contractFn, filteredContractParams || []);\n\n      if (this.params.tags && this.params.tags.length > 1) {\n        throw new Error(\"Providing multiple tags is not supported yet.\");\n      }\n\n      const tags = this.params.tags && this.params.tags.length ? [this.params.tags[0]] : [];\n      this._state.token = yield this.params.to.resolveTokenGatewayContract(this.params.asset);\n\n      if (this.renVM.submitGatewayDetails) {\n        const promise = this.renVM.submitGatewayDetails(this.params.from.addressToString(gatewayAddress), Object.assign(Object.assign({}, this._state), {\n          token: this._state.token,\n          nHash: Buffer.from(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", \"base64\"),\n          payload: fromHex(encodedParameters),\n          nonce: fromHex(nonce),\n          fn: contractFn,\n          fnABI,\n          to: this.renVM.version(this._state.selector) >= 2 ? strip0x(sendTo) : Ox(sendTo),\n          tags,\n          // See [RenJSConfig.transactionVersion]\n          transactionVersion: this._state.config.transactionVersion\n        }), 5);\n\n        if (promise.catch) {\n          promise.catch(_error => {// Ignore error.\n          });\n        }\n      }\n\n      return this.gatewayAddress;\n    });\n\n    this.wait = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this._state.pHash || !this._state.gHash || !this._state.gPubKey || !this.gatewayAddress) {\n        throw new Error(\"Gateway address must be generated before calling 'wait'.\");\n      }\n\n      while (true) {\n        const listenerCancelled = () => this.listenerCount(\"deposit\") === 0;\n\n        try {\n          // If there are no listeners, continue. TODO: Exit loop entirely\n          // until a lister is added again.\n          if (listenerCancelled()) {\n            yield sleep(1 * SECONDS);\n            continue;\n          }\n        } catch (error) {\n          this._state.logger.error(extractError(error));\n        } // Change the return type of `this.processDeposit` to `void`.\n\n\n        const onDeposit = deposit => __awaiter(this, void 0, void 0, function* () {\n          yield this.processDeposit(deposit);\n        }); // TODO: Flag deposits that have been cancelled, updating their status.\n\n\n        const cancelDeposit = () => __awaiter(this, void 0, void 0, function* () {\n          return Promise.resolve();\n        });\n\n        try {\n          this.getDepositsProgress = yield this.params.from.getDeposits(this.params.asset, this.gatewayAddress, this.getDepositsProgress, onDeposit, cancelDeposit, listenerCancelled);\n        } catch (error) {\n          this._state.logger.error(extractError(error));\n        }\n\n        yield sleep(this._state.config.networkDelay);\n      }\n    });\n\n    this.params = params;\n    this.renVM = renVM;\n    this._state = {\n      logger: config.logger || NullLogger,\n      selector: this.renVM.selector(this.params),\n      config: Object.assign(Object.assign({}, config), {\n        networkDelay: config.networkDelay || 15 * SECONDS\n      })\n    };\n    const txHash = this.params.txHash; // Decode nonce or use empty nonce 0x0.\n\n    const nonce = this.params.nonce ? fromHex(this.params.nonce) : emptyNonce();\n    this.params.nonce = nonce;\n\n    if (!txHash) {\n      this.params.nonce = nonce;\n    }\n\n    {\n      // Debug log\n      const _a = this.params,\n            {\n        to: _to,\n        from: _from\n      } = _a,\n            restOfParams = __rest(_a, [\"to\", \"from\"]);\n\n      this._state.logger.debug(\"lockAndMint created:\", restOfParams);\n    }\n  }\n\n}\nexport var DepositStatus;\n\n(function (DepositStatus) {\n  DepositStatus[\"Detected\"] = \"detected\";\n  DepositStatus[\"Confirmed\"] = \"confirmed\";\n  DepositStatus[\"Signed\"] = \"signed\";\n  DepositStatus[\"Reverted\"] = \"reverted\";\n  DepositStatus[\"Submitted\"] = \"submitted\";\n})(DepositStatus || (DepositStatus = {}));\n\nexport const DepositStatusIndex = {\n  [DepositStatus.Detected]: 0,\n  [DepositStatus.Confirmed]: 1,\n  [DepositStatus.Signed]: 2,\n  [DepositStatus.Reverted]: 3,\n  [DepositStatus.Submitted]: 4\n};\n/**\n * A LockAndMintDeposit represents a deposit that has been made to a gateway\n * address.\n *\n * Once it has been detected, the steps required to complete the mint are:\n * 1. Wait for the transaction to be mined. The number of confirmations here\n * depends on the asset.\n * 2. Submit the deposit to RenVM and wait for a signature.\n * 3. Submit the deposit to the lock-chain.\n *\n * Each of these steps can be performed using their respective methods. Each\n * of these return a PromiEvent, meaning that in addition to being a promise,\n * they also emit events that can be listened to.\n *\n * ```ts\n * await deposit.confirmed();\n * await deposit.signed();\n * await deposit.mint();\n * ```\n */\n\nexport class LockAndMintDeposit {\n  /** @hidden */\n  constructor(depositDetails, params, renVM, state, gatewayAddress) {\n    /** @hidden */\n    this._initialize = () => __awaiter(this, void 0, void 0, function* () {\n      yield this.refreshStatus();\n      return this;\n    });\n    /**\n     * `txHash` returns the RenVM transaction hash, which is distinct from the\n     * lock or mint chain transaction hashes. It can be used to query the\n     * lock-and-mint details from RenVM  once they've been submitted to it.\n     *\n     * The RenVM txHash is a URL-base64 string.\n     *\n     * ```ts\n     * deposit.txHash();\n     * // > \"QNM87rNDuxx54H7VK7D_NAU0u_mjk09-G25IJZL1QrI\"\n     * ```\n     */\n\n\n    this.txHash = () => {\n      // The type of `txHash` is a function instead of a string to match the\n      // interface of BurnAndRelease.\n      return this._state.txHash;\n    };\n    /**\n     * `queryTx` fetches the RenVM transaction details of the deposit.\n     *\n     * ```ts\n     * await deposit.queryTx();\n     * // > { to: \"...\", hash: \"...\", status: \"done\", in: {...}, out: {...} }\n     */\n\n\n    this.queryTx = () => __awaiter(this, void 0, void 0, function* () {\n      if (DepositStatusIndex[this.status] >= DepositStatusIndex[DepositStatus.Signed] && this._state.queryTxResult) {\n        return this._state.queryTxResult;\n      }\n\n      const response = yield this.renVM.queryMintOrBurn(this._state.selector, fromBase64(this.txHash()));\n      this._state.queryTxResult = response; // Update status.\n\n      if (response.out && response.out.revert !== undefined) {\n        this.status = DepositStatus.Reverted;\n        this.revertReason = response.out.revert.toString();\n      } else if (response.out && response.out.signature) {\n        if (DepositStatusIndex[this.status] < DepositStatusIndex[DepositStatus.Signed]) {\n          this.status = DepositStatus.Signed;\n        }\n      }\n\n      return response;\n    });\n    /**\n     * `refreshStatus` fetches the deposit's status on the mint-chain, RenVM\n     * and lock-chain to calculate it's [[DepositStatus]].\n     *\n     * ```ts\n     * await deposit.refreshStatus();\n     * // > \"signed\"\n     * ```\n     */\n\n\n    this.refreshStatus = () => __awaiter(this, void 0, void 0, function* () {\n      const status = yield (() => __awaiter(this, void 0, void 0, function* () {\n        let queryTxResult; // Fetch sighash.\n\n        try {\n          queryTxResult = yield this.queryTx();\n        } catch (_error) {\n          // Ignore error.\n          queryTxResult = null;\n        }\n\n        try {\n          // Ensure that\n          const transaction = yield this.findTransaction();\n\n          if (transaction !== undefined) {\n            return DepositStatus.Submitted;\n          }\n        } catch (_error) {// Ignore error.\n        }\n\n        try {\n          queryTxResult = queryTxResult === undefined ? yield this.queryTx() : queryTxResult;\n\n          if (queryTxResult && queryTxResult.txStatus === TxStatus.TxStatusDone) {\n            // Check if transaction was reverted.\n            if (queryTxResult.out && queryTxResult.out.revert !== undefined) {\n              this.status = DepositStatus.Reverted;\n              this.revertReason = queryTxResult.out.revert.toString();\n            } else {\n              return DepositStatus.Signed;\n            }\n          }\n        } catch (_error) {// Ignore error.\n        }\n\n        try {\n          const confirmations = yield this.confirmations();\n\n          if (confirmations.current >= confirmations.target) {\n            return DepositStatus.Confirmed;\n          }\n        } catch (_error) {// Ignore error.\n        }\n\n        return DepositStatus.Detected;\n      }))();\n      this.status = status;\n      return status;\n    });\n    /**\n     * `confirmations` returns the deposit's current and target number of\n     * confirmations on the lock-chain.\n     *\n     * ```ts\n     * await deposit\n     *  .confirmations();\n     * // > { current: 4, target: 6 }\n     * ```\n     */\n\n\n    this.confirmations = () => __awaiter(this, void 0, void 0, function* () {\n      const {\n        current,\n        target\n      } = yield this.params.from.transactionConfidence(this.depositDetails.transaction);\n      return {\n        current,\n        target: isDefined(this._state.targetConfirmations) ? this._state.targetConfirmations : target\n      };\n    });\n\n    this.confirmationTarget = () => __awaiter(this, void 0, void 0, function* () {\n      if (isDefined(this._state.targetConfirmations)) {\n        return this._state.targetConfirmations;\n      }\n\n      let target;\n      const getConfirmationTarget = this.renVM.getConfirmationTarget;\n\n      if (getConfirmationTarget) {\n        target = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {\n          return getConfirmationTarget(this._state.selector, this.params.from);\n        }), 2);\n      }\n\n      const defaultConfirmations = this._state.renNetwork && this._state.renNetwork.isTestnet ? 2 : 6;\n      this._state.targetConfirmations = isDefined(target) ? target : defaultConfirmations;\n      return this._state.targetConfirmations;\n    });\n    /**\n     * `confirmed` will return once the deposit has reached the target number of\n     * confirmations.\n     *\n     * It returns a PromiEvent which emits a `\"confirmation\"` event with the\n     * current and target number of confirmations as the event parameters.\n     *\n     * The events emitted by the PromiEvent are:\n     * 1. `\"confirmation\"` - called when a new confirmation is seen\n     * 2. `\"target\"` - called immediately to make the target confirmations\n     * available.\n     *\n     * ```ts\n     * await deposit\n     *  .confirmed()\n     *  .on(\"target\", (target) => console.log(`Waiting for ${target} confirmations`))\n     *  .on(\"confirmation\", (confs, target) => console.log(`${confs}/${target}`))\n     * ```\n     *\n     * @category Main\n     */\n\n\n    this.confirmed = () => {\n      const promiEvent = newPromiEvent();\n      (() => __awaiter(this, void 0, void 0, function* () {\n        try {\n          promiEvent.emit(\"target\", yield this.confirmationTarget());\n        } catch (error) {\n          this._state.logger.error(error);\n        } // If the transaction has been confirmed according to RenVM, return.\n\n\n        const transactionIsConfirmed = () => DepositStatusIndex[this.status] >= DepositStatusIndex[DepositStatus.Confirmed] || this._state.queryTxResult && TxStatusIndex[this._state.queryTxResult.txStatus] >= TxStatusIndex[TxStatus.TxStatusPending];\n\n        let iterationCount = 0;\n        let currentConfidenceRatio = 0; // Continue while the transaction isn't confirmed and the promievent\n        // isn't cancelled.\n\n        while (!promiEvent._isCancelled() && !transactionIsConfirmed()) {\n          // In the first loop, submit to RenVM immediately.\n          if (iterationCount % 5 === 0) {\n            try {\n              if (!this._state.renTxSubmitted) {\n                yield this._submitMintTransaction();\n              }\n\n              yield this.queryTx();\n\n              if (transactionIsConfirmed()) {\n                break;\n              }\n            } catch (error) {\n              // Ignore error.\n              this._state.logger.debug(error);\n            }\n          }\n\n          try {\n            const confidence = yield this.confirmations();\n            const confidenceRatio = confidence.target === 0 ? 1 : confidence.current / confidence.target;\n\n            if (confidenceRatio > currentConfidenceRatio) {\n              currentConfidenceRatio = confidenceRatio;\n              promiEvent.emit(\"confirmation\", confidence.current, confidence.target);\n            }\n\n            if (confidenceRatio >= 1) {\n              break;\n            }\n\n            this._state.logger.debug(`deposit confidence: ${confidence.current} / ${confidence.target}`);\n          } catch (error) {\n            this._state.logger.error(`Error fetching transaction confidence: ${extractError(error)}`);\n          }\n\n          yield sleep(this._state.config.networkDelay);\n          iterationCount += 1;\n        } // Update status.\n\n\n        if (DepositStatusIndex[this.status] < DepositStatusIndex[DepositStatus.Confirmed]) {\n          this.status = DepositStatus.Confirmed;\n        }\n\n        return this;\n      }))().then(promiEvent.resolve).catch(promiEvent.reject);\n      return promiEvent;\n    };\n    /**\n     * `signed` waits for RenVM's signature to be available.\n     *\n     * It returns a PromiEvent which emits a `\"txHash\"` event with the deposit's\n     * RenVM txHash (aka Transaction ID).\n     *\n     * ```ts\n     * await deposit\n     *  .signed()\n     *  .on(\"txHash\", (txHash) => console.log(txHash))\n     * ```\n     *\n     * The events emitted by the PromiEvent are:\n     * 1. `txHash` - the RenVM transaction hash of the deposit.\n     * 2. `status` - the RenVM status of the transaction, of type [[TxStatus]].\n     *\n     * @category Main\n     */\n\n\n    this.signed = () => {\n      const promiEvent = newPromiEvent();\n      (() => __awaiter(this, void 0, void 0, function* () {\n        let txHash = this.txHash(); // If the transaction has been reverted, throw the revert reason.\n\n        if (this.status === DepositStatus.Reverted) {\n          throw new Error(this.revertReason || `RenVM transaction ${txHash} reverted.`);\n        } // Check if the signature is already available.\n\n\n        if (DepositStatusIndex[this.status] >= DepositStatusIndex[DepositStatus.Signed] && this._state.queryTxResult && this._state.queryTxResult.out) {// NO_COMMIT\n          // return this;\n        }\n\n        promiEvent.emit(\"txHash\", txHash);\n\n        this._state.logger.debug(\"RenVM txHash:\", txHash); // Try to submit to RenVM. If that fails, see if they already\n        // know about the transaction.\n\n\n        try {\n          txHash = yield this._submitMintTransaction();\n        } catch (error) {\n          // this.logger.error(error);\n          try {\n            // Check if the darknodes have already seen the transaction\n            const queryTxResponse = yield this.queryTx();\n\n            if (queryTxResponse.txStatus === TxStatus.TxStatusNil) {\n              throw new Error(`Transaction ${txHash} has not been submitted previously.`);\n            }\n\n            txHash = queryTxResponse.hash;\n          } catch (errorInner) {\n            let submitted = false; // If transaction is not found, check for RenVM v0.2 error message.\n\n            if (errorInner.code === RenJSErrors.RenVMTransactionNotFound) {\n              if (error.code === RenJSErrors.AmountTooSmall || error.code === RenJSErrors.DepositSpentOrNotFound) {\n                this.status = DepositStatus.Reverted;\n                this.revertReason = String((error || {}).message).replace(/Node returned status \\d+ with reason: /, \"\");\n                throw new Error(this.revertReason);\n              } else {\n                // Retry submitting 2 more times to reduce chance\n                // of network issues causing problems.\n                txHash = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {\n                  return this._submitMintTransaction();\n                }), 2, 5 * SECONDS);\n                submitted = true;\n              }\n            } // Ignore errorInner.\n\n\n            this._state.logger.debug(errorInner);\n\n            if (!submitted) {\n              throw error;\n            }\n          }\n        }\n\n        const response = yield this.renVM.waitForTX(this._state.selector, fromBase64(txHash), status => {\n          promiEvent.emit(\"status\", status);\n\n          this._state.logger.debug(\"transaction status:\", status);\n        }, () => promiEvent._isCancelled(), this._state.config.networkDelay);\n        this._state.queryTxResult = response; // Update status.\n\n        if (response.out && response.out.revert !== undefined) {\n          this.status = DepositStatus.Reverted;\n          this.revertReason = response.out.revert.toString();\n          throw new Error(this.revertReason);\n        } else if (response.out && response.out.signature) {\n          if (DepositStatusIndex[this.status] < DepositStatusIndex[DepositStatus.Signed]) {\n            this.status = DepositStatus.Signed;\n          }\n\n          this._state.logger.debug(\"signature:\", response.out && response.out.signature);\n        }\n\n        return this;\n      }))().then(promiEvent.resolve).catch(promiEvent.reject);\n      return promiEvent;\n    };\n    /**\n     * `findTransaction` checks if the deposit signature has already been\n     * submitted to the mint chain.\n     *\n     * ```ts\n     * await deposit.findTransaction();\n     * // > \"0x1234\" // (or undefined)\n     * ```\n     */\n\n\n    this.findTransaction = () => __awaiter(this, void 0, void 0, function* () {\n      if (this.params.to.findTransaction) {\n        const sigHash = this._state.queryTxResult && this._state.queryTxResult.out && this._state.queryTxResult.out.revert === undefined ? this._state.queryTxResult.out.sighash : undefined; // Check if the signature has already been submitted\n\n        this.mintTransaction = yield this.params.to.findTransaction(this.params.asset, this._state.nHash, sigHash);\n        return this.mintTransaction;\n      }\n\n      if (this.params.contractCalls && this.params.to.findTransactionByDepositDetails && this._state.queryTxResult && this._state.queryTxResult.out && this._state.queryTxResult.out.revert === undefined) {\n        this.mintTransaction = yield this.params.to.findTransactionByDepositDetails(this.params.asset, keccak256(Buffer.from(this._state.selector)), this._state.nHash, this._state.pHash, this.params.contractCalls[0].sendTo, this._state.queryTxResult.out.amount);\n        return this.mintTransaction;\n      }\n\n      return undefined;\n    });\n    /**\n     * `mint` submits the RenVM signature to the mint chain.\n     *\n     * It returns a PromiEvent and the events emitted depend on the mint chain.\n     *\n     * The PromiEvent's events are defined by the mint-chain implementation. For\n     * Ethereum, it emits the same events as a Web3 PromiEvent.\n     *\n     * @category Main\n     */\n\n\n    this.mint = override => {\n      const promiEvent = newPromiEvent();\n      (() => __awaiter(this, void 0, void 0, function* () {\n        if (!this._state.queryTxResult) {\n          throw new Error(`Unable to submit to Ethereum without signature. Call 'signed' first.`);\n        }\n\n        const overrideArray = Object.keys(override || {}).map(key => ({\n          name: key,\n          value: (override || {})[key]\n        })); // Override contract call parameters that have been passed in to\n        // \"mint\".\n\n        let contractCalls = overrideContractCalls(this.params.contractCalls || [], {\n          contractParams: overrideArray\n        }); // Filter parameters that should be included in the payload hash but\n        // not the contract call.\n\n        contractCalls = contractCalls.map(call => Object.assign(Object.assign({}, call), {\n          contractParams: call.contractParams ? call.contractParams.filter(param => !param.onlyInPayload) : call.contractParams\n        }));\n        const asset = this.params.asset;\n        this.mintTransaction = yield this.params.to.submitMint(asset, contractCalls, this._state.queryTxResult, promiEvent); // Update status.\n\n        this.status = DepositStatus.Submitted;\n        return this.mintTransaction;\n      }))().then(promiEvent.resolve).catch(promiEvent.reject);\n      return promiEvent;\n    }; // Private methods /////////////////////////////////////////////////////////\n\n    /**\n     * `_submitMintTransaction` will create the RebVN mint transaction and return\n     * its txHash. If `config.submit` is true, it will also submit it to RenVM.\n     *\n     * Note that `_submitMintTransaction`'s return type changes from `string` to\n     * `Promise<string>` if `config.submit` is true. This may be split up into\n     * two methods in the future to avoid this weirdness - likely once the `v1`\n     * RPC format is phased out.\n     *\n     * @param config Set `config.submit` to `true` to submit the transaction.\n     */\n\n\n    this._submitMintTransaction = () => __awaiter(this, void 0, void 0, function* () {\n      const {\n        token\n      } = this._state;\n\n      if (!token) {\n        throw new Error(`Deposit object must be initialized.`);\n      }\n\n      const expectedTxHash = this.txHash(); // Return if the transaction has already been successfully submitted.\n\n      if (this._state.renTxSubmitted) {\n        return expectedTxHash;\n      } // The transaction has already been submitted and accepted.\n\n\n      if (this._state.renTxSubmitted) {\n        return expectedTxHash;\n      }\n\n      const encodedHash = yield this.renVM.submitMint(Object.assign(Object.assign({}, this._state), {\n        token,\n        // See [RenJSConfig.transactionVersion]\n        transactionVersion: this._state.config.transactionVersion\n      }));\n      const returnedTxHash = this.renVM.version(this._state.selector) >= 2 ? toURLBase64(encodedHash) : toBase64(encodedHash); // Indicate that the tx has been submitted successfully.\n\n      this._state.renTxSubmitted = true;\n\n      if (returnedTxHash !== expectedTxHash) {\n        this._state.logger.warn(`Unexpected txHash returned from RenVM. Received: ${returnedTxHash}, expected: ${expectedTxHash}`);\n      }\n\n      this._state.renTxSubmitted = true;\n      return returnedTxHash;\n    });\n\n    this.validateParams = () => {\n      assertObject({\n        from: \"object\",\n        to: \"object\",\n        contractCalls: \"any[]\",\n        asset: \"string\",\n        txHash: \"string | undefined\",\n        nonce: \"Buffer | string | undefined\",\n        tags: \"string[] | undefined\"\n      }, {\n        params: this.params\n      });\n\n      if (this.params.contractCalls) {\n        this.params.contractCalls.map(contractCall => {\n          assertType(\"string\", {\n            sendTo: contractCall.sendTo,\n            contractFn: contractCall.contractFn\n          });\n        });\n      }\n    };\n\n    assertObject({\n      transaction: \"any\",\n      amount: \"string\"\n    }, {\n      depositDetails: depositDetails\n    });\n    assertObject({\n      selector: \"string\",\n      logger: \"object\",\n      renNetwork: \"object\",\n      gPubKey: \"Buffer\",\n      gHash: \"Buffer\",\n      pHash: \"Buffer\",\n      targetConfirmations: \"number | undefined\",\n      config: \"object\"\n    }, {\n      state\n    });\n    this.depositDetails = depositDetails;\n    this.params = params;\n    this.renVM = renVM;\n    this.gatewayAddress = gatewayAddress; // this._state = state;\n    // `processDeposit` will call `refreshStatus` which will set the proper\n    // status.\n\n    this.status = DepositStatus.Detected;\n    const {\n      txHash,\n      contractCalls,\n      nonce\n    } = this.params;\n\n    if (!nonce) {\n      throw new Error(`No nonce passed in to LockAndMintDeposit.`);\n    }\n\n    if (!txHash && (!contractCalls || !contractCalls.length)) {\n      throw new Error(`Must provide Ren transaction hash or contract call details.`);\n    }\n\n    this.validateParams();\n    const deposit = this.depositDetails;\n    const providedTxHash = this.params.txHash ? renVMHashToBase64(this.params.txHash, this.renVM.version(state.selector) >= 2) : undefined;\n\n    if (!contractCalls || !contractCalls.length) {\n      throw new Error(`Unable to submit to RenVM without contract call details.`);\n    } // Last contract call\n\n\n    const {\n      contractParams,\n      sendTo,\n      contractFn\n    } = contractCalls[contractCalls.length - 1];\n    const filteredContractParams = contractParams ? contractParams.filter(contractParam => !contractParam.notInPayload) : contractParams;\n    const encodedParameters = AbiCoder.encodeParameters((filteredContractParams || []).map(i => i.type), (filteredContractParams || []).map(i => i.value));\n    const {\n      pHash,\n      config\n    } = state; // Check if the transaction is either a v0.2 transaction, or has the\n    // version set to `0` in a v0.4 transaction.\n    // See [RenJSConfig.transactionVersion]\n\n    const v0Transaction = this.renVM.version(state.selector) === 1 || config.transactionVersion === 0;\n    const transactionDetails = this.params.from.transactionRPCFormat(this.depositDetails.transaction, !v0Transaction);\n    const nHash = generateNHash(fromHex(nonce), transactionDetails.txid, transactionDetails.txindex, !v0Transaction);\n    const outputHashFormat = renVM.version(state.selector) >= 2 ? \"\" : this.params.from.depositV1HashString(deposit);\n    const fnABI = payloadToMintABI(contractFn, filteredContractParams || []);\n\n    if (this.params.tags && this.params.tags.length > 1) {\n      throw new Error(\"Providing multiple tags is not supported yet.\");\n    }\n\n    const tags = this.params.tags && this.params.tags.length ? [this.params.tags[0]] : [];\n    this._state = Object.assign(Object.assign({}, state), {\n      // gHash\n      // gPubKey\n      nHash,\n      nonce: fromHex(nonce),\n      output: this.params.from.transactionRPCFormat(deposit.transaction, renVM.version(state.selector) >= 2),\n      amount: deposit.amount,\n      payload: fromHex(encodedParameters),\n      pHash,\n      to: renVM.version(state.selector) >= 2 ? strip0x(sendTo) : Ox(sendTo),\n      fn: contractFn,\n      fnABI,\n      tags,\n      // Will be set in the next statement.\n      txHash: \"\",\n      renTxSubmitted: false\n    });\n    this._state.txHash = (renVM.version(this._state.selector) >= 2 ? toURLBase64 : toBase64)(this.renVM.mintTxHash(Object.assign(Object.assign({}, this._state), {\n      outputHashFormat,\n      // See [RenJSConfig.transactionVersion]\n      transactionVersion: config.transactionVersion\n    })));\n\n    if (providedTxHash && !fromBase64(providedTxHash).equals(fromBase64(this.txHash()))) {\n      throw new Error(`Inconsistent RenVM transaction hash: got ${providedTxHash} but expected ${this.txHash()}.`);\n    }\n\n    {\n      // Debug log\n      const _a = this.params,\n            {\n        to: _to,\n        from: _from\n      } = _a,\n            restOfParams = __rest(_a, [\"to\", \"from\"]);\n\n      this._state.logger.debug(\"LockAndMintDeposit created\", depositDetails, restOfParams);\n    }\n  }\n\n}","map":{"version":3,"sources":["../../src/lockAndMint.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { getRenNetworkDetails, newPromiEvent, NullLogger, RenJSErrors, TxStatus, TxStatusIndex, } from \"@renproject/interfaces\";\nimport { assertObject, assertType, emptyNonce, extractError, fromBase64, fromHex, generateGHash, generateNHash, generatePHash, generateSHash, isDefined, keccak256, overrideContractCalls, Ox, payloadToMintABI, renVMHashToBase64, retryNTimes, SECONDS, sleep, strip0x, toBase64, toURLBase64, } from \"@renproject/utils\";\nimport { EventEmitter } from \"events\";\nimport { OrderedMap } from \"immutable\";\nimport AbiCoder from \"web3-eth-abi\";\nimport base58 from \"bs58\";\n/**\n * A `LockAndMint` object tied to a particular gateway address. LockAndMint\n * should not be created directly. Instead, [[RenJS.lockAndMint]] will create a\n * `LockAndMint` object.\n *\n * `LockAndMint` extends the EventEmitter class, and emits a `\"deposit\"` event\n * for each new deposit that is observed. Deposits will only be watched for if\n * there is an active listener for the `\"deposit\"` event.\n *\n * A LockAndMint object watches transactions to the [[gatewayAddress]] on the\n * lock-chain.\n *\n * Deposits to the gateway address can be listened to with the `\"deposit\"`\n * event using [[on]], which will return [[LockAndMintDeposit]] instances.\n *\n * ```ts\n * console.log(`Deposit to ${JSON.stringify(lockAndMint.gatewayAddress)}`);\n *\n * lockAndMint.on(\"deposit\", async (deposit) => {\n *    console.log(`Received deposit`, deposit);\n *    await RenJS.defaultDepositHandler(deposit);\n * });\n * ```\n *\n * @noInheritDoc\n */\nexport class LockAndMint extends EventEmitter {\n    /**\n     * @hidden - should be created using [[RenJS.lockAndMint]] instead.\n     */\n    constructor(renVM, params, config = {}) {\n        super();\n        /**\n         * Deposits represents the lock deposits that have been detected so far.\n         */\n        this.deposits = OrderedMap();\n        this.confirmationTarget = () => __awaiter(this, void 0, void 0, function* () {\n            if (isDefined(this._state.targetConfirmations)) {\n                return this._state.targetConfirmations;\n            }\n            let target;\n            const getConfirmationTarget = this.renVM.getConfirmationTarget;\n            if (getConfirmationTarget) {\n                target = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {\n                    return getConfirmationTarget(this._state.selector, this.params.from);\n                }), 2);\n            }\n            const defaultConfirmations = this._state.renNetwork && this._state.renNetwork.isTestnet ? 2 : 6;\n            this._state.targetConfirmations = isDefined(target)\n                ? target\n                : defaultConfirmations;\n            return this._state.targetConfirmations;\n        });\n        /**\n         * @hidden - Called automatically when calling [[RenJS.lockAndMint]]. It has\n         * been split from the constructor because it's asynchronous.\n         */\n        this._initialize = () => __awaiter(this, void 0, void 0, function* () {\n            this._state.renNetwork =\n                this._state.renNetwork ||\n                    getRenNetworkDetails(yield this.renVM.getNetwork(this._state.selector));\n            if (!this.params.from.renNetwork) {\n                yield this.params.from.initialize(this._state.renNetwork);\n            }\n            if (!this.params.to.renNetwork) {\n                yield this.params.to.initialize(this._state.renNetwork);\n            }\n            const overwriteParams = this.params.to.getMintParams &&\n                (yield this.params.to.getMintParams(this.params.asset));\n            this.params = Object.assign(Object.assign({}, overwriteParams), this.params);\n            try {\n                this.gatewayAddress = yield this.generateGatewayAddress();\n            }\n            catch (error) {\n                throw error;\n            }\n            // Will fetch deposits as long as there's at least one deposit.\n            this.wait().catch(console.error);\n            try {\n                this._state.targetConfirmations = yield this.confirmationTarget();\n            }\n            catch (error) {\n                console.error(error);\n            }\n            return this;\n        });\n        /**\n         * `processDeposit` allows you to manually provide the details of a deposit\n         * and returns a [[LockAndMintDeposit]] object.\n         *\n         * @param deposit The deposit details in the format defined by the\n         * LockChain. This should be the same format as `deposit.depositDetails` for\n         * a deposit returned from `.on(\"deposit\", ...)`.\n         *\n         * ```ts\n         * lockAndMint\n         *   .processDeposit({\n         *       transaction: {\n         *           cid:\n         *               \"bafy2bzacedvu74e7ohjcwlh4fbx7ddf6li42fiuosajob6metcj2qwkgkgof2\",\n         *           to: \"t1v2ftlxhedyoijv7uqgxfygiziaqz23lgkvks77i\",\n         *           amount: (0.01 * 1e8).toString(),\n         *           params: \"EzGbvVHf8lb0v8CUfjh8y+tLbZzfIFcnNnt/gh6axmw=\",\n         *           confirmations: 1,\n         *           nonce: 7,\n         *       },\n         *       amount: (0.01 * 1e8).toString(),\n         *   })\n         *   .on(deposit => RenJS.defaultDepositHandler)\n         *   .catch(console.error);\n         * ```\n         *\n         * @category Main\n         */\n        this.processDeposit = (deposit) => __awaiter(this, void 0, void 0, function* () {\n            if (!this._state.renNetwork ||\n                !this._state.pHash ||\n                !this._state.gHash ||\n                !this._state.gPubKey ||\n                !this.gatewayAddress) {\n                throw new Error(\"Gateway address must be generated before calling 'wait'.\");\n            }\n            const depositID = this.params.from.transactionID(deposit.transaction);\n            let depositObject = this.deposits.get(depositID);\n            // If the confidence has increased.\n            if (!depositObject\n            // || (existingConfidenceRatio !== undefined &&\n            // confidenceRatio > existingConfidenceRatio)\n            ) {\n                depositObject = new LockAndMintDeposit(deposit, this.params, this.renVM, Object.assign(Object.assign({}, this._state), { renNetwork: this._state.renNetwork, pHash: this._state.pHash, gHash: this._state.gHash, gPubKey: this._state.gPubKey, token: this._state.token, targetConfirmations: isDefined(this._state.targetConfirmations)\n                        ? this._state.targetConfirmations\n                        : undefined }), this.gatewayAddress);\n                yield depositObject._initialize();\n                // Check if deposit has already been submitted.\n                if (this._state.config.loadCompletedDeposits ||\n                    depositObject.status !== DepositStatus.Submitted) {\n                    this.emit(\"deposit\", depositObject);\n                    // this.deposits.set(deposit);\n                    this._state.logger.debug(\"new deposit:\", deposit);\n                    this.deposits = this.deposits.set(depositID, depositObject);\n                }\n            }\n            return depositObject;\n        });\n        this.addListener = (event, listener) => {\n            // Emit previous deposit events.\n            if (event === \"deposit\") {\n                this.deposits.map((deposit) => {\n                    listener(deposit);\n                });\n            }\n            super.on(event, listener);\n            return this;\n        };\n        /**\n         * `on` creates a new listener to `\"deposit\"` events, returning\n         * [[LockAndMintDeposit]] instances.\n         *\n         * `on` extends `EventEmitter.on`, modifying it to immediately return all\n         * previous `\"deposit\"` events, in addition to new events, when a new\n         * listener is created.\n         *\n         * @category Main\n         */\n        this.on = (event, listener) => this.addListener(event, listener);\n        // Private methods /////////////////////////////////////////////////////////\n        this.generateGatewayAddress = () => __awaiter(this, void 0, void 0, function* () {\n            if (this.gatewayAddress) {\n                return this.gatewayAddress;\n            }\n            const { nonce, contractCalls } = this.params;\n            if (!nonce) {\n                throw new Error(`Must call 'initialize' before calling 'generateGatewayAddress'.`);\n            }\n            if (!contractCalls) {\n                throw new Error(`Must provide contract call details.`);\n            }\n            // Last contract call\n            const { contractParams, sendTo, contractFn } = contractCalls[contractCalls.length - 1];\n            // FIXME: dirty hack, but we need to re-write how we deal with\n            // addresses in order to do this cleanly\n            // (need to follow the multichain address pattern)\n            const sendToHex = this.params.to.name == \"Solana\"\n                ? base58.decode(sendTo).toString(\"hex\")\n                : sendTo;\n            this._state.pHash = generatePHash(contractParams || [], this._state.logger);\n            // Check if the transaction is either a v0.2 transaction, or has the\n            // version set to `0` in a v0.4 transaction.\n            // See [RenJSConfig.transactionVersion]\n            const v0Transaction = this.renVM.version(this._state.selector) === 1 ||\n                this._state.config.transactionVersion === 0;\n            const tokenGatewayContract = !v0Transaction\n                ? Ox(generateSHash(this._state.selector))\n                : yield this.params.to.resolveTokenGatewayContract(this.params.asset);\n            const gHash = generateGHash(contractParams || [], sendToHex, tokenGatewayContract, fromHex(nonce), !v0Transaction, this._state.logger);\n            this._state.gHash = gHash;\n            this._state.gPubKey =\n                this._state.config.gPubKey ||\n                    (yield this.renVM.selectPublicKey(this._state.selector, this.renVM.version(this._state.selector) >= 2\n                        ? this.params.from.name\n                        : this.params.asset));\n            this._state.logger.debug(\"gPubKey:\", Ox(this._state.gPubKey));\n            const gatewayAddress = yield this.params.from.getGatewayAddress(this.params.asset, this._state.gPubKey, gHash);\n            this.gatewayAddress = gatewayAddress;\n            this._state.logger.debug(\"gateway address:\", this.gatewayAddress);\n            const filteredContractParams = contractParams\n                ? contractParams.filter((contractParam) => !contractParam.notInPayload)\n                : contractParams;\n            const encodedParameters = AbiCoder.encodeParameters((filteredContractParams || []).map((i) => i.type), (filteredContractParams || []).map((i) => i.value));\n            const fnABI = payloadToMintABI(contractFn, filteredContractParams || []);\n            if (this.params.tags && this.params.tags.length > 1) {\n                throw new Error(\"Providing multiple tags is not supported yet.\");\n            }\n            const tags = this.params.tags && this.params.tags.length\n                ? [this.params.tags[0]]\n                : [];\n            this._state.token =\n                yield this.params.to.resolveTokenGatewayContract(this.params.asset);\n            if (this.renVM.submitGatewayDetails) {\n                const promise = this.renVM.submitGatewayDetails(this.params.from.addressToString(gatewayAddress), Object.assign(Object.assign({}, this._state), { token: this._state.token, nHash: Buffer.from(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", \"base64\"), payload: fromHex(encodedParameters), nonce: fromHex(nonce), fn: contractFn, fnABI, to: this.renVM.version(this._state.selector) >= 2\n                        ? strip0x(sendTo)\n                        : Ox(sendTo), tags, \n                    // See [RenJSConfig.transactionVersion]\n                    transactionVersion: this._state.config.transactionVersion }), 5);\n                if (promise.catch) {\n                    promise.catch((_error) => {\n                        // Ignore error.\n                    });\n                }\n            }\n            return this.gatewayAddress;\n        });\n        this.wait = () => __awaiter(this, void 0, void 0, function* () {\n            if (!this._state.pHash ||\n                !this._state.gHash ||\n                !this._state.gPubKey ||\n                !this.gatewayAddress) {\n                throw new Error(\"Gateway address must be generated before calling 'wait'.\");\n            }\n            while (true) {\n                const listenerCancelled = () => this.listenerCount(\"deposit\") === 0;\n                try {\n                    // If there are no listeners, continue. TODO: Exit loop entirely\n                    // until a lister is added again.\n                    if (listenerCancelled()) {\n                        yield sleep(1 * SECONDS);\n                        continue;\n                    }\n                }\n                catch (error) {\n                    this._state.logger.error(extractError(error));\n                }\n                // Change the return type of `this.processDeposit` to `void`.\n                const onDeposit = (deposit) => __awaiter(this, void 0, void 0, function* () {\n                    yield this.processDeposit(deposit);\n                });\n                // TODO: Flag deposits that have been cancelled, updating their status.\n                const cancelDeposit = () => __awaiter(this, void 0, void 0, function* () { return Promise.resolve(); });\n                try {\n                    this.getDepositsProgress = yield this.params.from.getDeposits(this.params.asset, this.gatewayAddress, this.getDepositsProgress, onDeposit, cancelDeposit, listenerCancelled);\n                }\n                catch (error) {\n                    this._state.logger.error(extractError(error));\n                }\n                yield sleep(this._state.config.networkDelay);\n            }\n        });\n        this.params = params;\n        this.renVM = renVM;\n        this._state = {\n            logger: config.logger || NullLogger,\n            selector: this.renVM.selector(this.params),\n            config: Object.assign(Object.assign({}, config), { networkDelay: config.networkDelay || 15 * SECONDS }),\n        };\n        const txHash = this.params.txHash;\n        // Decode nonce or use empty nonce 0x0.\n        const nonce = this.params.nonce\n            ? fromHex(this.params.nonce)\n            : emptyNonce();\n        this.params.nonce = nonce;\n        if (!txHash) {\n            this.params.nonce = nonce;\n        }\n        {\n            // Debug log\n            const _a = this.params, { to: _to, from: _from } = _a, restOfParams = __rest(_a, [\"to\", \"from\"]);\n            this._state.logger.debug(\"lockAndMint created:\", restOfParams);\n        }\n    }\n}\nexport var DepositStatus;\n(function (DepositStatus) {\n    DepositStatus[\"Detected\"] = \"detected\";\n    DepositStatus[\"Confirmed\"] = \"confirmed\";\n    DepositStatus[\"Signed\"] = \"signed\";\n    DepositStatus[\"Reverted\"] = \"reverted\";\n    DepositStatus[\"Submitted\"] = \"submitted\";\n})(DepositStatus || (DepositStatus = {}));\nexport const DepositStatusIndex = {\n    [DepositStatus.Detected]: 0,\n    [DepositStatus.Confirmed]: 1,\n    [DepositStatus.Signed]: 2,\n    [DepositStatus.Reverted]: 3,\n    [DepositStatus.Submitted]: 4,\n};\n/**\n * A LockAndMintDeposit represents a deposit that has been made to a gateway\n * address.\n *\n * Once it has been detected, the steps required to complete the mint are:\n * 1. Wait for the transaction to be mined. The number of confirmations here\n * depends on the asset.\n * 2. Submit the deposit to RenVM and wait for a signature.\n * 3. Submit the deposit to the lock-chain.\n *\n * Each of these steps can be performed using their respective methods. Each\n * of these return a PromiEvent, meaning that in addition to being a promise,\n * they also emit events that can be listened to.\n *\n * ```ts\n * await deposit.confirmed();\n * await deposit.signed();\n * await deposit.mint();\n * ```\n */\nexport class LockAndMintDeposit {\n    /** @hidden */\n    constructor(depositDetails, params, renVM, state, gatewayAddress) {\n        /** @hidden */\n        this._initialize = () => __awaiter(this, void 0, void 0, function* () {\n            yield this.refreshStatus();\n            return this;\n        });\n        /**\n         * `txHash` returns the RenVM transaction hash, which is distinct from the\n         * lock or mint chain transaction hashes. It can be used to query the\n         * lock-and-mint details from RenVM  once they've been submitted to it.\n         *\n         * The RenVM txHash is a URL-base64 string.\n         *\n         * ```ts\n         * deposit.txHash();\n         * // > \"QNM87rNDuxx54H7VK7D_NAU0u_mjk09-G25IJZL1QrI\"\n         * ```\n         */\n        this.txHash = () => {\n            // The type of `txHash` is a function instead of a string to match the\n            // interface of BurnAndRelease.\n            return this._state.txHash;\n        };\n        /**\n         * `queryTx` fetches the RenVM transaction details of the deposit.\n         *\n         * ```ts\n         * await deposit.queryTx();\n         * // > { to: \"...\", hash: \"...\", status: \"done\", in: {...}, out: {...} }\n         */\n        this.queryTx = () => __awaiter(this, void 0, void 0, function* () {\n            if (DepositStatusIndex[this.status] >=\n                DepositStatusIndex[DepositStatus.Signed] &&\n                this._state.queryTxResult) {\n                return this._state.queryTxResult;\n            }\n            const response = yield this.renVM.queryMintOrBurn(this._state.selector, fromBase64(this.txHash()));\n            this._state.queryTxResult = response;\n            // Update status.\n            if (response.out && response.out.revert !== undefined) {\n                this.status = DepositStatus.Reverted;\n                this.revertReason = response.out.revert.toString();\n            }\n            else if (response.out && response.out.signature) {\n                if (DepositStatusIndex[this.status] <\n                    DepositStatusIndex[DepositStatus.Signed]) {\n                    this.status = DepositStatus.Signed;\n                }\n            }\n            return response;\n        });\n        /**\n         * `refreshStatus` fetches the deposit's status on the mint-chain, RenVM\n         * and lock-chain to calculate it's [[DepositStatus]].\n         *\n         * ```ts\n         * await deposit.refreshStatus();\n         * // > \"signed\"\n         * ```\n         */\n        this.refreshStatus = () => __awaiter(this, void 0, void 0, function* () {\n            const status = yield (() => __awaiter(this, void 0, void 0, function* () {\n                let queryTxResult;\n                // Fetch sighash.\n                try {\n                    queryTxResult = yield this.queryTx();\n                }\n                catch (_error) {\n                    // Ignore error.\n                    queryTxResult = null;\n                }\n                try {\n                    // Ensure that\n                    const transaction = yield this.findTransaction();\n                    if (transaction !== undefined) {\n                        return DepositStatus.Submitted;\n                    }\n                }\n                catch (_error) {\n                    // Ignore error.\n                }\n                try {\n                    queryTxResult =\n                        queryTxResult === undefined\n                            ? yield this.queryTx()\n                            : queryTxResult;\n                    if (queryTxResult &&\n                        queryTxResult.txStatus === TxStatus.TxStatusDone) {\n                        // Check if transaction was reverted.\n                        if (queryTxResult.out &&\n                            queryTxResult.out.revert !== undefined) {\n                            this.status = DepositStatus.Reverted;\n                            this.revertReason = queryTxResult.out.revert.toString();\n                        }\n                        else {\n                            return DepositStatus.Signed;\n                        }\n                    }\n                }\n                catch (_error) {\n                    // Ignore error.\n                }\n                try {\n                    const confirmations = yield this.confirmations();\n                    if (confirmations.current >= confirmations.target) {\n                        return DepositStatus.Confirmed;\n                    }\n                }\n                catch (_error) {\n                    // Ignore error.\n                }\n                return DepositStatus.Detected;\n            }))();\n            this.status = status;\n            return status;\n        });\n        /**\n         * `confirmations` returns the deposit's current and target number of\n         * confirmations on the lock-chain.\n         *\n         * ```ts\n         * await deposit\n         *  .confirmations();\n         * // > { current: 4, target: 6 }\n         * ```\n         */\n        this.confirmations = () => __awaiter(this, void 0, void 0, function* () {\n            const { current, target } = yield this.params.from.transactionConfidence(this.depositDetails.transaction);\n            return {\n                current,\n                target: isDefined(this._state.targetConfirmations)\n                    ? this._state.targetConfirmations\n                    : target,\n            };\n        });\n        this.confirmationTarget = () => __awaiter(this, void 0, void 0, function* () {\n            if (isDefined(this._state.targetConfirmations)) {\n                return this._state.targetConfirmations;\n            }\n            let target;\n            const getConfirmationTarget = this.renVM.getConfirmationTarget;\n            if (getConfirmationTarget) {\n                target = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {\n                    return getConfirmationTarget(this._state.selector, this.params.from);\n                }), 2);\n            }\n            const defaultConfirmations = this._state.renNetwork && this._state.renNetwork.isTestnet ? 2 : 6;\n            this._state.targetConfirmations = isDefined(target)\n                ? target\n                : defaultConfirmations;\n            return this._state.targetConfirmations;\n        });\n        /**\n         * `confirmed` will return once the deposit has reached the target number of\n         * confirmations.\n         *\n         * It returns a PromiEvent which emits a `\"confirmation\"` event with the\n         * current and target number of confirmations as the event parameters.\n         *\n         * The events emitted by the PromiEvent are:\n         * 1. `\"confirmation\"` - called when a new confirmation is seen\n         * 2. `\"target\"` - called immediately to make the target confirmations\n         * available.\n         *\n         * ```ts\n         * await deposit\n         *  .confirmed()\n         *  .on(\"target\", (target) => console.log(`Waiting for ${target} confirmations`))\n         *  .on(\"confirmation\", (confs, target) => console.log(`${confs}/${target}`))\n         * ```\n         *\n         * @category Main\n         */\n        this.confirmed = () => {\n            const promiEvent = newPromiEvent();\n            (() => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    promiEvent.emit(\"target\", yield this.confirmationTarget());\n                }\n                catch (error) {\n                    this._state.logger.error(error);\n                }\n                // If the transaction has been confirmed according to RenVM, return.\n                const transactionIsConfirmed = () => DepositStatusIndex[this.status] >=\n                    DepositStatusIndex[DepositStatus.Confirmed] ||\n                    (this._state.queryTxResult &&\n                        TxStatusIndex[this._state.queryTxResult.txStatus] >=\n                            TxStatusIndex[TxStatus.TxStatusPending]);\n                let iterationCount = 0;\n                let currentConfidenceRatio = 0;\n                // Continue while the transaction isn't confirmed and the promievent\n                // isn't cancelled.\n                while (!promiEvent._isCancelled() && !transactionIsConfirmed()) {\n                    // In the first loop, submit to RenVM immediately.\n                    if (iterationCount % 5 === 0) {\n                        try {\n                            if (!this._state.renTxSubmitted) {\n                                yield this._submitMintTransaction();\n                            }\n                            yield this.queryTx();\n                            if (transactionIsConfirmed()) {\n                                break;\n                            }\n                        }\n                        catch (error) {\n                            // Ignore error.\n                            this._state.logger.debug(error);\n                        }\n                    }\n                    try {\n                        const confidence = yield this.confirmations();\n                        const confidenceRatio = confidence.target === 0\n                            ? 1\n                            : confidence.current / confidence.target;\n                        if (confidenceRatio > currentConfidenceRatio) {\n                            currentConfidenceRatio = confidenceRatio;\n                            promiEvent.emit(\"confirmation\", confidence.current, confidence.target);\n                        }\n                        if (confidenceRatio >= 1) {\n                            break;\n                        }\n                        this._state.logger.debug(`deposit confidence: ${confidence.current} / ${confidence.target}`);\n                    }\n                    catch (error) {\n                        this._state.logger.error(`Error fetching transaction confidence: ${extractError(error)}`);\n                    }\n                    yield sleep(this._state.config.networkDelay);\n                    iterationCount += 1;\n                }\n                // Update status.\n                if (DepositStatusIndex[this.status] <\n                    DepositStatusIndex[DepositStatus.Confirmed]) {\n                    this.status = DepositStatus.Confirmed;\n                }\n                return this;\n            }))()\n                .then(promiEvent.resolve)\n                .catch(promiEvent.reject);\n            return promiEvent;\n        };\n        /**\n         * `signed` waits for RenVM's signature to be available.\n         *\n         * It returns a PromiEvent which emits a `\"txHash\"` event with the deposit's\n         * RenVM txHash (aka Transaction ID).\n         *\n         * ```ts\n         * await deposit\n         *  .signed()\n         *  .on(\"txHash\", (txHash) => console.log(txHash))\n         * ```\n         *\n         * The events emitted by the PromiEvent are:\n         * 1. `txHash` - the RenVM transaction hash of the deposit.\n         * 2. `status` - the RenVM status of the transaction, of type [[TxStatus]].\n         *\n         * @category Main\n         */\n        this.signed = () => {\n            const promiEvent = newPromiEvent();\n            (() => __awaiter(this, void 0, void 0, function* () {\n                let txHash = this.txHash();\n                // If the transaction has been reverted, throw the revert reason.\n                if (this.status === DepositStatus.Reverted) {\n                    throw new Error(this.revertReason ||\n                        `RenVM transaction ${txHash} reverted.`);\n                }\n                // Check if the signature is already available.\n                if (DepositStatusIndex[this.status] >=\n                    DepositStatusIndex[DepositStatus.Signed] &&\n                    this._state.queryTxResult &&\n                    this._state.queryTxResult.out) {\n                    // NO_COMMIT\n                    // return this;\n                }\n                promiEvent.emit(\"txHash\", txHash);\n                this._state.logger.debug(\"RenVM txHash:\", txHash);\n                // Try to submit to RenVM. If that fails, see if they already\n                // know about the transaction.\n                try {\n                    txHash = yield this._submitMintTransaction();\n                }\n                catch (error) {\n                    // this.logger.error(error);\n                    try {\n                        // Check if the darknodes have already seen the transaction\n                        const queryTxResponse = yield this.queryTx();\n                        if (queryTxResponse.txStatus === TxStatus.TxStatusNil) {\n                            throw new Error(`Transaction ${txHash} has not been submitted previously.`);\n                        }\n                        txHash = queryTxResponse.hash;\n                    }\n                    catch (errorInner) {\n                        let submitted = false;\n                        // If transaction is not found, check for RenVM v0.2 error message.\n                        if (errorInner.code === RenJSErrors.RenVMTransactionNotFound) {\n                            if (error.code === RenJSErrors.AmountTooSmall ||\n                                error.code === RenJSErrors.DepositSpentOrNotFound) {\n                                this.status = DepositStatus.Reverted;\n                                this.revertReason = String((error || {}).message).replace(/Node returned status \\d+ with reason: /, \"\");\n                                throw new Error(this.revertReason);\n                            }\n                            else {\n                                // Retry submitting 2 more times to reduce chance\n                                // of network issues causing problems.\n                                txHash = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () { return this._submitMintTransaction(); }), 2, 5 * SECONDS);\n                                submitted = true;\n                            }\n                        }\n                        // Ignore errorInner.\n                        this._state.logger.debug(errorInner);\n                        if (!submitted) {\n                            throw error;\n                        }\n                    }\n                }\n                const response = yield this.renVM.waitForTX(this._state.selector, fromBase64(txHash), (status) => {\n                    promiEvent.emit(\"status\", status);\n                    this._state.logger.debug(\"transaction status:\", status);\n                }, () => promiEvent._isCancelled(), this._state.config.networkDelay);\n                this._state.queryTxResult = response;\n                // Update status.\n                if (response.out && response.out.revert !== undefined) {\n                    this.status = DepositStatus.Reverted;\n                    this.revertReason = response.out.revert.toString();\n                    throw new Error(this.revertReason);\n                }\n                else if (response.out && response.out.signature) {\n                    if (DepositStatusIndex[this.status] <\n                        DepositStatusIndex[DepositStatus.Signed]) {\n                        this.status = DepositStatus.Signed;\n                    }\n                    this._state.logger.debug(\"signature:\", response.out && response.out.signature);\n                }\n                return this;\n            }))()\n                .then(promiEvent.resolve)\n                .catch(promiEvent.reject);\n            return promiEvent;\n        };\n        /**\n         * `findTransaction` checks if the deposit signature has already been\n         * submitted to the mint chain.\n         *\n         * ```ts\n         * await deposit.findTransaction();\n         * // > \"0x1234\" // (or undefined)\n         * ```\n         */\n        this.findTransaction = () => __awaiter(this, void 0, void 0, function* () {\n            if (this.params.to.findTransaction) {\n                const sigHash = this._state.queryTxResult &&\n                    this._state.queryTxResult.out &&\n                    this._state.queryTxResult.out.revert === undefined\n                    ? this._state.queryTxResult.out.sighash\n                    : undefined;\n                // Check if the signature has already been submitted\n                this.mintTransaction = yield this.params.to.findTransaction(this.params.asset, this._state.nHash, sigHash);\n                return this.mintTransaction;\n            }\n            if (this.params.contractCalls &&\n                this.params.to.findTransactionByDepositDetails &&\n                this._state.queryTxResult &&\n                this._state.queryTxResult.out &&\n                this._state.queryTxResult.out.revert === undefined) {\n                this.mintTransaction =\n                    yield this.params.to.findTransactionByDepositDetails(this.params.asset, keccak256(Buffer.from(this._state.selector)), this._state.nHash, this._state.pHash, this.params.contractCalls[0].sendTo, this._state.queryTxResult.out.amount);\n                return this.mintTransaction;\n            }\n            return undefined;\n        });\n        /**\n         * `mint` submits the RenVM signature to the mint chain.\n         *\n         * It returns a PromiEvent and the events emitted depend on the mint chain.\n         *\n         * The PromiEvent's events are defined by the mint-chain implementation. For\n         * Ethereum, it emits the same events as a Web3 PromiEvent.\n         *\n         * @category Main\n         */\n        this.mint = (override) => {\n            const promiEvent = newPromiEvent();\n            (() => __awaiter(this, void 0, void 0, function* () {\n                if (!this._state.queryTxResult) {\n                    throw new Error(`Unable to submit to Ethereum without signature. Call 'signed' first.`);\n                }\n                const overrideArray = Object.keys(override || {}).map((key) => ({\n                    name: key,\n                    value: (override || {})[key],\n                }));\n                // Override contract call parameters that have been passed in to\n                // \"mint\".\n                let contractCalls = overrideContractCalls(this.params.contractCalls || [], { contractParams: overrideArray });\n                // Filter parameters that should be included in the payload hash but\n                // not the contract call.\n                contractCalls = contractCalls.map((call) => (Object.assign(Object.assign({}, call), { contractParams: call.contractParams\n                        ? call.contractParams.filter((param) => !param.onlyInPayload)\n                        : call.contractParams })));\n                const asset = this.params.asset;\n                this.mintTransaction = yield this.params.to.submitMint(asset, contractCalls, this._state.queryTxResult, promiEvent);\n                // Update status.\n                this.status = DepositStatus.Submitted;\n                return this.mintTransaction;\n            }))()\n                .then(promiEvent.resolve)\n                .catch(promiEvent.reject);\n            return promiEvent;\n        };\n        // Private methods /////////////////////////////////////////////////////////\n        /**\n         * `_submitMintTransaction` will create the RebVN mint transaction and return\n         * its txHash. If `config.submit` is true, it will also submit it to RenVM.\n         *\n         * Note that `_submitMintTransaction`'s return type changes from `string` to\n         * `Promise<string>` if `config.submit` is true. This may be split up into\n         * two methods in the future to avoid this weirdness - likely once the `v1`\n         * RPC format is phased out.\n         *\n         * @param config Set `config.submit` to `true` to submit the transaction.\n         */\n        this._submitMintTransaction = () => __awaiter(this, void 0, void 0, function* () {\n            const { token } = this._state;\n            if (!token) {\n                throw new Error(`Deposit object must be initialized.`);\n            }\n            const expectedTxHash = this.txHash();\n            // Return if the transaction has already been successfully submitted.\n            if (this._state.renTxSubmitted) {\n                return expectedTxHash;\n            }\n            // The transaction has already been submitted and accepted.\n            if (this._state.renTxSubmitted) {\n                return expectedTxHash;\n            }\n            const encodedHash = yield this.renVM.submitMint(Object.assign(Object.assign({}, this._state), { token, \n                // See [RenJSConfig.transactionVersion]\n                transactionVersion: this._state.config.transactionVersion }));\n            const returnedTxHash = this.renVM.version(this._state.selector) >= 2\n                ? toURLBase64(encodedHash)\n                : toBase64(encodedHash);\n            // Indicate that the tx has been submitted successfully.\n            this._state.renTxSubmitted = true;\n            if (returnedTxHash !== expectedTxHash) {\n                this._state.logger.warn(`Unexpected txHash returned from RenVM. Received: ${returnedTxHash}, expected: ${expectedTxHash}`);\n            }\n            this._state.renTxSubmitted = true;\n            return returnedTxHash;\n        });\n        this.validateParams = () => {\n            assertObject({\n                from: \"object\",\n                to: \"object\",\n                contractCalls: \"any[]\",\n                asset: \"string\",\n                txHash: \"string | undefined\",\n                nonce: \"Buffer | string | undefined\",\n                tags: \"string[] | undefined\",\n            }, { params: this.params });\n            if (this.params.contractCalls) {\n                this.params.contractCalls.map((contractCall) => {\n                    assertType(\"string\", {\n                        sendTo: contractCall.sendTo,\n                        contractFn: contractCall.contractFn,\n                    });\n                });\n            }\n        };\n        assertObject({\n            transaction: \"any\",\n            amount: \"string\",\n        }, {\n            depositDetails: depositDetails,\n        });\n        assertObject({\n            selector: \"string\",\n            logger: \"object\",\n            renNetwork: \"object\",\n            gPubKey: \"Buffer\",\n            gHash: \"Buffer\",\n            pHash: \"Buffer\",\n            targetConfirmations: \"number | undefined\",\n            config: \"object\",\n        }, { state });\n        this.depositDetails = depositDetails;\n        this.params = params;\n        this.renVM = renVM;\n        this.gatewayAddress = gatewayAddress;\n        // this._state = state;\n        // `processDeposit` will call `refreshStatus` which will set the proper\n        // status.\n        this.status = DepositStatus.Detected;\n        const { txHash, contractCalls, nonce } = this.params;\n        if (!nonce) {\n            throw new Error(`No nonce passed in to LockAndMintDeposit.`);\n        }\n        if (!txHash && (!contractCalls || !contractCalls.length)) {\n            throw new Error(`Must provide Ren transaction hash or contract call details.`);\n        }\n        this.validateParams();\n        const deposit = this.depositDetails;\n        const providedTxHash = this.params.txHash\n            ? renVMHashToBase64(this.params.txHash, this.renVM.version(state.selector) >= 2)\n            : undefined;\n        if (!contractCalls || !contractCalls.length) {\n            throw new Error(`Unable to submit to RenVM without contract call details.`);\n        }\n        // Last contract call\n        const { contractParams, sendTo, contractFn } = contractCalls[contractCalls.length - 1];\n        const filteredContractParams = contractParams\n            ? contractParams.filter((contractParam) => !contractParam.notInPayload)\n            : contractParams;\n        const encodedParameters = AbiCoder.encodeParameters((filteredContractParams || []).map((i) => i.type), (filteredContractParams || []).map((i) => i.value));\n        const { pHash, config } = state;\n        // Check if the transaction is either a v0.2 transaction, or has the\n        // version set to `0` in a v0.4 transaction.\n        // See [RenJSConfig.transactionVersion]\n        const v0Transaction = this.renVM.version(state.selector) === 1 ||\n            config.transactionVersion === 0;\n        const transactionDetails = this.params.from.transactionRPCFormat(this.depositDetails.transaction, !v0Transaction);\n        const nHash = generateNHash(fromHex(nonce), transactionDetails.txid, transactionDetails.txindex, !v0Transaction);\n        const outputHashFormat = renVM.version(state.selector) >= 2\n            ? \"\"\n            : this.params.from.depositV1HashString(deposit);\n        const fnABI = payloadToMintABI(contractFn, filteredContractParams || []);\n        if (this.params.tags && this.params.tags.length > 1) {\n            throw new Error(\"Providing multiple tags is not supported yet.\");\n        }\n        const tags = this.params.tags && this.params.tags.length\n            ? [this.params.tags[0]]\n            : [];\n        this._state = Object.assign(Object.assign({}, state), { \n            // gHash\n            // gPubKey\n            nHash, nonce: fromHex(nonce), output: this.params.from.transactionRPCFormat(deposit.transaction, renVM.version(state.selector) >= 2), amount: deposit.amount, payload: fromHex(encodedParameters), pHash, to: renVM.version(state.selector) >= 2\n                ? strip0x(sendTo)\n                : Ox(sendTo), fn: contractFn, fnABI,\n            tags, \n            // Will be set in the next statement.\n            txHash: \"\", renTxSubmitted: false });\n        this._state.txHash = (renVM.version(this._state.selector) >= 2 ? toURLBase64 : toBase64)(this.renVM.mintTxHash(Object.assign(Object.assign({}, this._state), { outputHashFormat, \n            // See [RenJSConfig.transactionVersion]\n            transactionVersion: config.transactionVersion })));\n        if (providedTxHash &&\n            !fromBase64(providedTxHash).equals(fromBase64(this.txHash()))) {\n            throw new Error(`Inconsistent RenVM transaction hash: got ${providedTxHash} but expected ${this.txHash()}.`);\n        }\n        {\n            // Debug log\n            const _a = this.params, { to: _to, from: _from } = _a, restOfParams = __rest(_a, [\"to\", \"from\"]);\n            this._state.logger.debug(\"LockAndMintDeposit created\", depositDetails, restOfParams);\n        }\n    }\n}\n//# sourceMappingURL=lockAndMint.js.map"]},"metadata":{},"sourceType":"module"}