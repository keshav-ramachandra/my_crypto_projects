{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { LogLevel, NullLogger } from \"@renproject/interfaces\";\nimport { extractError, retryNTimes, SECONDS } from \"@renproject/utils\";\nimport axios from \"axios\";\n\nconst generatePayload = (method, params) => ({\n  id: 1,\n  jsonrpc: \"2.0\",\n  method,\n  params\n});\n\nexport class HttpProvider {\n  constructor(ipOrMultiaddress, logger = NullLogger) {\n    this.sendMessage = (method, request, retry = 2, timeout = 120 * SECONDS) => __awaiter(this, void 0, void 0, function* () {\n      const payload = generatePayload(method, request);\n\n      if ( // Check level before doing expensive JSON call.\n      typeof this.logger.level !== \"number\" || this.logger.level >= LogLevel.Debug) {\n        this.logger.debug(\"[request]\", JSON.stringify(payload, null, \"    \"));\n      }\n\n      try {\n        const response = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {\n          return axios.post(this.nodeURL, payload, // Use a 120 second timeout. This could be reduced, but\n          // should be done based on the method, since some requests\n          // may take a long time, especially on a slow connection.\n          {\n            timeout\n          });\n        }), retry, 1 * SECONDS);\n\n        if (response.status !== 200) {\n          throw this.responseError(`Unexpected status code ${String(response.status)} returned from node.`, response);\n        }\n\n        if (response.data.error) {\n          throw new Error(response.data.error);\n        }\n\n        if (response.data.result === undefined) {\n          throw new Error(`Empty result returned from node.`);\n        }\n\n        if (typeof this.logger.level !== \"number\" || this.logger.level >= LogLevel.Debug) {\n          this.logger.debug(\"[response]\", JSON.stringify(response.data.result, null, \"    \"));\n        }\n\n        return response.data.result;\n      } catch (error) {\n        if (error.response) {\n          error.message = `Node returned status ${String(error.response.status)} with reason: ${extractError(error)}`;\n        }\n\n        throw error;\n      }\n    });\n\n    this.responseError = (msg, response) => {\n      const error = new Error(msg);\n      error.response = response;\n      return error;\n    };\n\n    this.logger = logger;\n\n    if (typeof ipOrMultiaddress !== \"string\") {\n      throw new Error(`Invalid node URL ${String(ipOrMultiaddress)}`);\n    }\n\n    if (ipOrMultiaddress.indexOf(\"://\") === -1) {\n      throw new Error(`Invalid node URL without protocol: ${ipOrMultiaddress}.`);\n    }\n\n    this.nodeURL = ipOrMultiaddress;\n  }\n\n}","map":{"version":3,"sources":["../../src/httpProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LogLevel, NullLogger } from \"@renproject/interfaces\";\nimport { extractError, retryNTimes, SECONDS } from \"@renproject/utils\";\nimport axios from \"axios\";\nconst generatePayload = (method, params) => ({\n    id: 1,\n    jsonrpc: \"2.0\",\n    method,\n    params,\n});\nexport class HttpProvider {\n    constructor(ipOrMultiaddress, logger = NullLogger) {\n        this.sendMessage = (method, request, retry = 2, timeout = 120 * SECONDS) => __awaiter(this, void 0, void 0, function* () {\n            const payload = generatePayload(method, request);\n            if (\n            // Check level before doing expensive JSON call.\n            typeof this.logger.level !== \"number\" ||\n                this.logger.level >= LogLevel.Debug) {\n                this.logger.debug(\"[request]\", JSON.stringify(payload, null, \"    \"));\n            }\n            try {\n                const response = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {\n                    return axios.post(this.nodeURL, payload, \n                    // Use a 120 second timeout. This could be reduced, but\n                    // should be done based on the method, since some requests\n                    // may take a long time, especially on a slow connection.\n                    { timeout });\n                }), retry, 1 * SECONDS);\n                if (response.status !== 200) {\n                    throw this.responseError(`Unexpected status code ${String(response.status)} returned from node.`, response);\n                }\n                if (response.data.error) {\n                    throw new Error(response.data.error);\n                }\n                if (response.data.result === undefined) {\n                    throw new Error(`Empty result returned from node.`);\n                }\n                if (typeof this.logger.level !== \"number\" ||\n                    this.logger.level >= LogLevel.Debug) {\n                    this.logger.debug(\"[response]\", JSON.stringify(response.data.result, null, \"    \"));\n                }\n                return response.data.result;\n            }\n            catch (error) {\n                if (error.response) {\n                    error.message = `Node returned status ${String(error.response.status)} with reason: ${extractError(error)}`;\n                }\n                throw error;\n            }\n        });\n        this.responseError = (msg, response) => {\n            const error = new Error(msg);\n            error.response = response;\n            return error;\n        };\n        this.logger = logger;\n        if (typeof ipOrMultiaddress !== \"string\") {\n            throw new Error(`Invalid node URL ${String(ipOrMultiaddress)}`);\n        }\n        if (ipOrMultiaddress.indexOf(\"://\") === -1) {\n            throw new Error(`Invalid node URL without protocol: ${ipOrMultiaddress}.`);\n        }\n        this.nodeURL = ipOrMultiaddress;\n    }\n}\n//# sourceMappingURL=httpProvider.js.map"]},"metadata":{},"sourceType":"module"}