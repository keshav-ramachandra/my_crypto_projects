{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { getRenNetworkDetails, newPromiEvent, NullLogger } from \"@renproject/interfaces\";\nimport { assertObject, assertType, fromBase64, generateBurnTxHash, generateGHash, generateNHash, generatePHash, generateSHash, isDefined, Ox, renVMHashToBase64, retryNTimes, SECONDS, sleep, toBase64, toURLBase64 } from \"@renproject/utils\";\nimport BN from \"bn.js\";\nimport BigNumber from \"bignumber.js\";\nexport var BurnAndReleaseStatus;\n\n(function (BurnAndReleaseStatus) {\n  BurnAndReleaseStatus[\"Pending\"] = \"pending\";\n  BurnAndReleaseStatus[\"Burned\"] = \"burned\";\n  BurnAndReleaseStatus[\"Released\"] = \"released\";\n  BurnAndReleaseStatus[\"Reverted\"] = \"reverted\";\n})(BurnAndReleaseStatus || (BurnAndReleaseStatus = {}));\n\nexport class BurnAndRelease {\n  /** @hidden */\n  constructor(renVM, params, config = {}) {\n    this.validateParams = () => {\n      assertObject({\n        from: \"object | undefined\",\n        to: \"object\",\n        transaction: \"any | undefined\",\n        burnNonce: \"string | number | undefined\",\n        contractCalls: \"any[] | undefined\",\n        asset: \"string\",\n        txHash: \"string | undefined\",\n        nonce: \"Buffer | string | undefined\",\n        tags: \"string[] | undefined\"\n      }, {\n        params: this.params\n      });\n\n      if (this.params.contractCalls) {\n        this.params.contractCalls.map(contractCall => {\n          assertType(\"string\", {\n            sendTo: contractCall.sendTo,\n            contractFn: contractCall.contractFn\n          });\n        });\n      }\n    };\n    /** @hidden */\n\n\n    this._initialize = () => __awaiter(this, void 0, void 0, function* () {\n      this._state.renNetwork = this._state.renNetwork || getRenNetworkDetails(yield this.renVM.getNetwork(this._state.selector));\n\n      if (this.params.from && !this.params.from.renNetwork) {\n        yield this.params.from.initialize(this._state.renNetwork);\n      }\n\n      if (!this.params.to.renNetwork) {\n        yield this.params.to.initialize(this._state.renNetwork);\n      }\n\n      const burnPayload = this.params.to.burnPayload && (yield this.params.to.burnPayload(this.params.from.burnPayloadConfig));\n      const overwriteParams = this.params.from && this.params.from.getBurnParams && (yield this.params.from.getBurnParams(this.params.asset, burnPayload));\n      this.params = Object.assign(Object.assign({}, overwriteParams), this.params);\n\n      if (this.renVM.version(this._state.selector) >= 2) {\n        this._state.gPubKey = yield this.renVM.selectPublicKey(this._state.selector, this.params.to.name);\n      }\n\n      return this;\n    });\n    /**\n     * TODO: Refresh the BurnAndRelease status by checking the status of the\n     * mint-chain transaction and the RenVM transaction.\n     *\n     * ```ts\n     * await burnAndRelease.refreshStatus();\n     * // > \"released\"\n     * ```\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n\n\n    this.refreshStatus = () => __awaiter(this, void 0, void 0, function* () {\n      return this.status;\n    });\n\n    this.confirmationTarget = () => __awaiter(this, void 0, void 0, function* () {\n      if (isDefined(this._state.targetConfirmations)) {\n        return this._state.targetConfirmations;\n      }\n\n      let target;\n      const getConfirmationTarget = this.renVM.getConfirmationTarget;\n\n      if (getConfirmationTarget) {\n        target = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {\n          return getConfirmationTarget(this._state.selector, this.params.from);\n        }), 2);\n      }\n\n      this._state.targetConfirmations = isDefined(target) ? target : 6;\n      return this._state.targetConfirmations;\n    });\n    /**\n     * Read a burn reference from an Ethereum transaction - or submit a\n     * transaction first if the transaction details have been provided.\n     */\n\n\n    this.burn = () => {\n      const promiEvent = newPromiEvent();\n      (() => __awaiter(this, void 0, void 0, function* () {\n        if (this.params.txHash) {\n          return this;\n        }\n\n        if (!this.params.from) {\n          throw new Error(`Must either provide field \\`to\\` or field \\`txHash\\`.`);\n        }\n\n        const {\n          asset,\n          transaction,\n          burnNonce,\n          contractCalls\n        } = this.params;\n        this.burnDetails = yield this.params.from.findBurnTransaction(asset, {\n          transaction,\n          burnNonce,\n          contractCalls\n        }, promiEvent, this._state.logger, this._state.config.networkDelay);\n        this.status = BurnAndReleaseStatus.Burned;\n        let current = 0,\n            target = 1;\n\n        while (current < target) {\n          try {\n            ({\n              current,\n              target\n            } = yield this.params.from.transactionConfidence(this.burnDetails.transaction));\n\n            if (this._state.targetConfirmations && target < this._state.targetConfirmations) {\n              target = this._state.targetConfirmations;\n            } // Eth based chains only emits until 24 confs;\n            // keep emitting so that we can update the UI\n\n\n            promiEvent.emit(\"confirmation\", current, target); // Exit early so that we don't have to sleep if confs are met\n\n            if (current >= target) {\n              break;\n            }\n          } catch (error) {\n            console.error(error);\n          }\n\n          yield sleep(10 * SECONDS);\n        }\n\n        return this;\n      }))().then(promiEvent.resolve).catch(promiEvent.reject);\n      return promiEvent;\n    };\n    /**\n     * `txHash` returns the RenVM transaction hash, which is distinct from the\n     * lock or mint chain transaction hashes. It can be used to query the\n     * burn-and-release details from RenVM once they've been submitted to it.\n     *\n     * The RenVM txHash is a URL-base64 string.\n     *\n     * ```ts\n     * burnAndRelease.txHash();\n     * // > \"QNM87rNDuxx54H7VK7D_NAU0u_mjk09-G25IJZL1QrI\"\n     * ```\n     */\n\n\n    this.txHash = () => {\n      const txHash = this.params.txHash;\n\n      if (txHash) {\n        return renVMHashToBase64(txHash, this.renVM.version(this._state.selector) >= 2);\n      }\n\n      if (!this.params.from) {\n        throw new Error(`Must either provide field \\`to\\` or field \\`txHash\\`.`);\n      }\n\n      if (!this.burnDetails) {\n        throw new Error(\"Must call `burn` before calling `txHash`.\");\n      }\n\n      if (this.renVM.version(this._state.selector) >= 2 && this.renVM.burnTxHash) {\n        const {\n          transaction,\n          amount,\n          to,\n          nonce\n        } = this.burnDetails;\n        const payload = Buffer.from([]);\n        const pHash = generatePHash([], this._state.logger);\n        const {\n          txid,\n          txindex\n        } = this.params.from.transactionRPCFormat(transaction, true);\n        const nonceBuffer = new BN(nonce.toFixed()).toArrayLike(Buffer, \"be\", 32);\n        const nHash = generateNHash(nonceBuffer, txid, txindex, this.renVM.version(this._state.selector) >= 2, this._state.logger);\n        const sHash = generateSHash(`${this.params.asset}/to${this.params.to.name}`);\n        const gHash = generateGHash([], Ox(this.params.to.addressToBytes(to)), Ox(sHash), nonceBuffer, this.renVM.version(this._state.selector) >= 2, this._state.logger);\n        const {\n          gPubKey\n        } = this._state;\n\n        if (!gPubKey) {\n          throw new Error(`BurnAndRelease object must be initialized.`);\n        }\n\n        return toURLBase64(this.renVM.burnTxHash({\n          selector: this._state.selector,\n          gHash,\n          gPubKey,\n          nHash,\n          nonce: nonceBuffer,\n          output: {\n            txid,\n            txindex\n          },\n          amount: amount.toFixed(),\n          payload,\n          pHash,\n          to: to.toString()\n        }));\n      } else {\n        return toBase64(generateBurnTxHash(this._state.selector, this.burnDetails.nonce.toFixed(), this._state.logger));\n      }\n    };\n    /**\n     * queryTx requests the status of the burn from RenVM.\n     */\n\n\n    this.queryTx = () => __awaiter(this, void 0, void 0, function* () {\n      const burnTransaction = yield this.renVM.queryMintOrBurn(this._state.selector, fromBase64(this.txHash()));\n      this._state.queryTxResult = burnTransaction;\n      return burnTransaction;\n    });\n    /**\n     * submit queries RenVM for the status of the burn until the funds are\n     * released.\n     */\n\n\n    this.release = () => {\n      const promiEvent = newPromiEvent();\n      (() => __awaiter(this, void 0, void 0, function* () {\n        if (!this.burnDetails && !this.params.txHash) {\n          throw new Error(\"Must call `burn` before calling `release`.\");\n        }\n\n        const txHash = this.txHash();\n\n        if (!this.params.txHash && this.burnDetails) {\n          if (!this.params.from) {\n            throw new Error(`Must either provide field \\`to\\` or field \\`txHash\\`.`);\n          }\n\n          if (this.params.tags && this.params.tags.length > 1) {\n            throw new Error(\"Providing multiple tags is not supported yet.\");\n          }\n\n          const tags = this.params.tags && this.params.tags.length ? [this.params.tags[0]] : [];\n          const {\n            transaction,\n            amount,\n            to,\n            nonce\n          } = this.burnDetails;\n\n          try {\n            let returnedTxHash;\n\n            if (this.renVM.version(this._state.selector) >= 2) {\n              assertType(\"string\", {\n                to\n              });\n              const {\n                gPubKey\n              } = this._state;\n\n              if (!gPubKey) {\n                throw new Error(`BurnAndRelease object must be initialized.`);\n              }\n\n              const payload = Buffer.from([]);\n              const pHash = generatePHash([], this._state.logger);\n              const {\n                txid,\n                txindex\n              } = this.params.from.transactionRPCFormat(transaction, true);\n              const nonceBuffer = new BN(nonce.toFixed()).toArrayLike(Buffer, \"be\", 32);\n              const nHash = generateNHash(nonceBuffer, txid, txindex, this.renVM.version(this._state.selector) >= 2, this._state.logger);\n              const sHash = generateSHash(`${this.params.asset}/to${this.params.to.name}`);\n              const gHash = generateGHash([], Ox(this.params.to.addressToBytes(to)), Ox(sHash), nonceBuffer, this.renVM.version(this._state.selector) >= 2, this._state.logger);\n              returnedTxHash = toURLBase64(yield this.renVM.submitBurn({\n                selector: this._state.selector,\n                tags,\n                gHash,\n                gPubKey,\n                nHash,\n                nonce: nonceBuffer,\n                output: {\n                  txid,\n                  txindex\n                },\n                amount: amount.toFixed(),\n                payload,\n                pHash,\n                to: to.toString(),\n                // from v1\n                burnNonce: new BigNumber(0)\n              }));\n            } else {\n              returnedTxHash = toBase64(yield this.renVM.submitBurn({\n                selector: this._state.selector,\n                tags,\n                burnNonce: nonce,\n                // for v2\n                gHash: Buffer.from([]),\n                gPubKey: Buffer.from([]),\n                nHash: Buffer.from([]),\n                nonce: Buffer.from([]),\n                output: {\n                  txid: Buffer.from([]),\n                  txindex: \"\"\n                },\n                amount: \"\",\n                payload: Buffer.from([]),\n                pHash: Buffer.from([]),\n                to: \"\"\n              }));\n            }\n\n            if (txHash && txHash !== returnedTxHash) {\n              this._state.logger.warn(`Unexpected txHash returned from RenVM. Received: ${returnedTxHash}, expected: ${txHash}`);\n            }\n          } catch (error) {\n            // TODO: Check against already being submitted.\n            throw error;\n          }\n        } // const txHash = await this.renVMNetwork.submitTokenFromEthereum(this.params.sendToken, burnNonce);\n\n\n        promiEvent.emit(\"txHash\", txHash);\n\n        this._state.logger.debug(\"txHash:\", txHash);\n\n        const response = yield this.renVM.waitForTX(this._state.selector, fromBase64(txHash), status => {\n          promiEvent.emit(\"status\", status);\n\n          this._state.logger.debug(\"transaction status:\", status);\n        }, () => promiEvent._isCancelled(), this._state.config.networkDelay);\n\n        if (response.out && response.out.revert !== undefined) {\n          this.status = BurnAndReleaseStatus.Reverted;\n          this.revertReason = response.out.revert.toString();\n          throw new Error(this.revertReason);\n        } else {\n          this.status = BurnAndReleaseStatus.Released;\n\n          if (response.out && this.renVM.version(this._state.selector) >= 2) {\n            let transaction;\n\n            try {\n              if (response.out.txid) {\n                const txid = response.out.txid;\n                transaction = yield this.params.to.transactionFromRPCFormat(txid, \"\", true);\n              } else if (response.out.outpoint) {\n                const {\n                  hash,\n                  index\n                } = response.out.outpoint;\n                transaction = yield this.params.to.transactionFromRPCFormat(hash, index.toFixed(), true);\n              }\n            } catch (error) {\n              this._state.logger.debug(error);\n            }\n\n            if (transaction) {\n              this.releaseTransaction = transaction;\n              promiEvent.emit(\"transaction\", transaction);\n            }\n          }\n        }\n\n        return response;\n      }))().then(promiEvent.resolve).catch(promiEvent.reject);\n      return promiEvent;\n    };\n\n    this.params = params;\n    this.renVM = renVM;\n    this._state = {\n      logger: config.logger || NullLogger,\n      selector: this.renVM.selector(this.params),\n      targetConfirmations: undefined,\n      config: Object.assign(Object.assign({}, config), {\n        networkDelay: config.networkDelay || 15 * SECONDS\n      })\n    };\n    this.validateParams();\n    this.status = this.params.txHash ? BurnAndReleaseStatus.Burned : BurnAndReleaseStatus.Pending;\n    {\n      // Debug log\n      const restOfParams = __rest(this.params, []);\n\n      this._state.logger.debug(\"burnAndRelease created:\", restOfParams);\n    }\n  }\n\n}","map":{"version":3,"sources":["../../src/burnAndRelease.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { getRenNetworkDetails, newPromiEvent, NullLogger, } from \"@renproject/interfaces\";\nimport { assertObject, assertType, fromBase64, generateBurnTxHash, generateGHash, generateNHash, generatePHash, generateSHash, isDefined, Ox, renVMHashToBase64, retryNTimes, SECONDS, sleep, toBase64, toURLBase64, } from \"@renproject/utils\";\nimport BN from \"bn.js\";\nimport BigNumber from \"bignumber.js\";\nexport var BurnAndReleaseStatus;\n(function (BurnAndReleaseStatus) {\n    BurnAndReleaseStatus[\"Pending\"] = \"pending\";\n    BurnAndReleaseStatus[\"Burned\"] = \"burned\";\n    BurnAndReleaseStatus[\"Released\"] = \"released\";\n    BurnAndReleaseStatus[\"Reverted\"] = \"reverted\";\n})(BurnAndReleaseStatus || (BurnAndReleaseStatus = {}));\nexport class BurnAndRelease {\n    /** @hidden */\n    constructor(renVM, params, config = {}) {\n        this.validateParams = () => {\n            assertObject({\n                from: \"object | undefined\",\n                to: \"object\",\n                transaction: \"any | undefined\",\n                burnNonce: \"string | number | undefined\",\n                contractCalls: \"any[] | undefined\",\n                asset: \"string\",\n                txHash: \"string | undefined\",\n                nonce: \"Buffer | string | undefined\",\n                tags: \"string[] | undefined\",\n            }, { params: this.params });\n            if (this.params.contractCalls) {\n                this.params.contractCalls.map((contractCall) => {\n                    assertType(\"string\", {\n                        sendTo: contractCall.sendTo,\n                        contractFn: contractCall.contractFn,\n                    });\n                });\n            }\n        };\n        /** @hidden */\n        this._initialize = () => __awaiter(this, void 0, void 0, function* () {\n            this._state.renNetwork =\n                this._state.renNetwork ||\n                    getRenNetworkDetails(yield this.renVM.getNetwork(this._state.selector));\n            if (this.params.from && !this.params.from.renNetwork) {\n                yield this.params.from.initialize(this._state.renNetwork);\n            }\n            if (!this.params.to.renNetwork) {\n                yield this.params.to.initialize(this._state.renNetwork);\n            }\n            const burnPayload = this.params.to.burnPayload &&\n                (yield this.params.to.burnPayload(this.params.from.burnPayloadConfig));\n            const overwriteParams = this.params.from &&\n                this.params.from.getBurnParams &&\n                (yield this.params.from.getBurnParams(this.params.asset, burnPayload));\n            this.params = Object.assign(Object.assign({}, overwriteParams), this.params);\n            if (this.renVM.version(this._state.selector) >= 2) {\n                this._state.gPubKey = yield this.renVM.selectPublicKey(this._state.selector, this.params.to.name);\n            }\n            return this;\n        });\n        /**\n         * TODO: Refresh the BurnAndRelease status by checking the status of the\n         * mint-chain transaction and the RenVM transaction.\n         *\n         * ```ts\n         * await burnAndRelease.refreshStatus();\n         * // > \"released\"\n         * ```\n         */\n        // eslint-disable-next-line @typescript-eslint/require-await\n        this.refreshStatus = () => __awaiter(this, void 0, void 0, function* () {\n            return this.status;\n        });\n        this.confirmationTarget = () => __awaiter(this, void 0, void 0, function* () {\n            if (isDefined(this._state.targetConfirmations)) {\n                return this._state.targetConfirmations;\n            }\n            let target;\n            const getConfirmationTarget = this.renVM.getConfirmationTarget;\n            if (getConfirmationTarget) {\n                target = yield retryNTimes(() => __awaiter(this, void 0, void 0, function* () {\n                    return getConfirmationTarget(this._state.selector, this.params.from);\n                }), 2);\n            }\n            this._state.targetConfirmations = isDefined(target) ? target : 6;\n            return this._state.targetConfirmations;\n        });\n        /**\n         * Read a burn reference from an Ethereum transaction - or submit a\n         * transaction first if the transaction details have been provided.\n         */\n        this.burn = () => {\n            const promiEvent = newPromiEvent();\n            (() => __awaiter(this, void 0, void 0, function* () {\n                if (this.params.txHash) {\n                    return this;\n                }\n                if (!this.params.from) {\n                    throw new Error(`Must either provide field \\`to\\` or field \\`txHash\\`.`);\n                }\n                const { asset, transaction, burnNonce, contractCalls } = this.params;\n                this.burnDetails = yield this.params.from.findBurnTransaction(asset, {\n                    transaction,\n                    burnNonce,\n                    contractCalls,\n                }, promiEvent, this._state.logger, this._state.config.networkDelay);\n                this.status = BurnAndReleaseStatus.Burned;\n                let current = 0, target = 1;\n                while (current < target) {\n                    try {\n                        ({ current, target } =\n                            yield this.params.from.transactionConfidence(this.burnDetails.transaction));\n                        if (this._state.targetConfirmations &&\n                            target < this._state.targetConfirmations) {\n                            target = this._state.targetConfirmations;\n                        }\n                        // Eth based chains only emits until 24 confs;\n                        // keep emitting so that we can update the UI\n                        promiEvent.emit(\"confirmation\", current, target);\n                        // Exit early so that we don't have to sleep if confs are met\n                        if (current >= target) {\n                            break;\n                        }\n                    }\n                    catch (error) {\n                        console.error(error);\n                    }\n                    yield sleep(10 * SECONDS);\n                }\n                return this;\n            }))()\n                .then(promiEvent.resolve)\n                .catch(promiEvent.reject);\n            return promiEvent;\n        };\n        /**\n         * `txHash` returns the RenVM transaction hash, which is distinct from the\n         * lock or mint chain transaction hashes. It can be used to query the\n         * burn-and-release details from RenVM once they've been submitted to it.\n         *\n         * The RenVM txHash is a URL-base64 string.\n         *\n         * ```ts\n         * burnAndRelease.txHash();\n         * // > \"QNM87rNDuxx54H7VK7D_NAU0u_mjk09-G25IJZL1QrI\"\n         * ```\n         */\n        this.txHash = () => {\n            const txHash = this.params.txHash;\n            if (txHash) {\n                return renVMHashToBase64(txHash, this.renVM.version(this._state.selector) >= 2);\n            }\n            if (!this.params.from) {\n                throw new Error(`Must either provide field \\`to\\` or field \\`txHash\\`.`);\n            }\n            if (!this.burnDetails) {\n                throw new Error(\"Must call `burn` before calling `txHash`.\");\n            }\n            if (this.renVM.version(this._state.selector) >= 2 &&\n                this.renVM.burnTxHash) {\n                const { transaction, amount, to, nonce } = this.burnDetails;\n                const payload = Buffer.from([]);\n                const pHash = generatePHash([], this._state.logger);\n                const { txid, txindex } = this.params.from.transactionRPCFormat(transaction, true);\n                const nonceBuffer = new BN(nonce.toFixed()).toArrayLike(Buffer, \"be\", 32);\n                const nHash = generateNHash(nonceBuffer, txid, txindex, this.renVM.version(this._state.selector) >= 2, this._state.logger);\n                const sHash = generateSHash(`${this.params.asset}/to${this.params.to.name}`);\n                const gHash = generateGHash([], Ox(this.params.to.addressToBytes(to)), Ox(sHash), nonceBuffer, this.renVM.version(this._state.selector) >= 2, this._state.logger);\n                const { gPubKey } = this._state;\n                if (!gPubKey) {\n                    throw new Error(`BurnAndRelease object must be initialized.`);\n                }\n                return toURLBase64(this.renVM.burnTxHash({\n                    selector: this._state.selector,\n                    gHash,\n                    gPubKey,\n                    nHash,\n                    nonce: nonceBuffer,\n                    output: {\n                        txid,\n                        txindex,\n                    },\n                    amount: amount.toFixed(),\n                    payload,\n                    pHash,\n                    to: to.toString(),\n                }));\n            }\n            else {\n                return toBase64(generateBurnTxHash(this._state.selector, this.burnDetails.nonce.toFixed(), this._state.logger));\n            }\n        };\n        /**\n         * queryTx requests the status of the burn from RenVM.\n         */\n        this.queryTx = () => __awaiter(this, void 0, void 0, function* () {\n            const burnTransaction = yield this.renVM.queryMintOrBurn(this._state.selector, fromBase64(this.txHash()));\n            this._state.queryTxResult = burnTransaction;\n            return burnTransaction;\n        });\n        /**\n         * submit queries RenVM for the status of the burn until the funds are\n         * released.\n         */\n        this.release = () => {\n            const promiEvent = newPromiEvent();\n            (() => __awaiter(this, void 0, void 0, function* () {\n                if (!this.burnDetails && !this.params.txHash) {\n                    throw new Error(\"Must call `burn` before calling `release`.\");\n                }\n                const txHash = this.txHash();\n                if (!this.params.txHash && this.burnDetails) {\n                    if (!this.params.from) {\n                        throw new Error(`Must either provide field \\`to\\` or field \\`txHash\\`.`);\n                    }\n                    if (this.params.tags && this.params.tags.length > 1) {\n                        throw new Error(\"Providing multiple tags is not supported yet.\");\n                    }\n                    const tags = this.params.tags && this.params.tags.length\n                        ? [this.params.tags[0]]\n                        : [];\n                    const { transaction, amount, to, nonce } = this.burnDetails;\n                    try {\n                        let returnedTxHash;\n                        if (this.renVM.version(this._state.selector) >= 2) {\n                            assertType(\"string\", { to });\n                            const { gPubKey } = this._state;\n                            if (!gPubKey) {\n                                throw new Error(`BurnAndRelease object must be initialized.`);\n                            }\n                            const payload = Buffer.from([]);\n                            const pHash = generatePHash([], this._state.logger);\n                            const { txid, txindex } = this.params.from.transactionRPCFormat(transaction, true);\n                            const nonceBuffer = new BN(nonce.toFixed()).toArrayLike(Buffer, \"be\", 32);\n                            const nHash = generateNHash(nonceBuffer, txid, txindex, this.renVM.version(this._state.selector) >= 2, this._state.logger);\n                            const sHash = generateSHash(`${this.params.asset}/to${this.params.to.name}`);\n                            const gHash = generateGHash([], Ox(this.params.to.addressToBytes(to)), Ox(sHash), nonceBuffer, this.renVM.version(this._state.selector) >= 2, this._state.logger);\n                            returnedTxHash = toURLBase64(yield this.renVM.submitBurn({\n                                selector: this._state.selector,\n                                tags,\n                                gHash,\n                                gPubKey,\n                                nHash,\n                                nonce: nonceBuffer,\n                                output: {\n                                    txid,\n                                    txindex,\n                                },\n                                amount: amount.toFixed(),\n                                payload,\n                                pHash,\n                                to: to.toString(),\n                                // from v1\n                                burnNonce: new BigNumber(0),\n                            }));\n                        }\n                        else {\n                            returnedTxHash = toBase64(yield this.renVM.submitBurn({\n                                selector: this._state.selector,\n                                tags,\n                                burnNonce: nonce,\n                                // for v2\n                                gHash: Buffer.from([]),\n                                gPubKey: Buffer.from([]),\n                                nHash: Buffer.from([]),\n                                nonce: Buffer.from([]),\n                                output: { txid: Buffer.from([]), txindex: \"\" },\n                                amount: \"\",\n                                payload: Buffer.from([]),\n                                pHash: Buffer.from([]),\n                                to: \"\",\n                            }));\n                        }\n                        if (txHash && txHash !== returnedTxHash) {\n                            this._state.logger.warn(`Unexpected txHash returned from RenVM. Received: ${returnedTxHash}, expected: ${txHash}`);\n                        }\n                    }\n                    catch (error) {\n                        // TODO: Check against already being submitted.\n                        throw error;\n                    }\n                }\n                // const txHash = await this.renVMNetwork.submitTokenFromEthereum(this.params.sendToken, burnNonce);\n                promiEvent.emit(\"txHash\", txHash);\n                this._state.logger.debug(\"txHash:\", txHash);\n                const response = yield this.renVM.waitForTX(this._state.selector, fromBase64(txHash), (status) => {\n                    promiEvent.emit(\"status\", status);\n                    this._state.logger.debug(\"transaction status:\", status);\n                }, () => promiEvent._isCancelled(), this._state.config.networkDelay);\n                if (response.out && response.out.revert !== undefined) {\n                    this.status = BurnAndReleaseStatus.Reverted;\n                    this.revertReason = response.out.revert.toString();\n                    throw new Error(this.revertReason);\n                }\n                else {\n                    this.status = BurnAndReleaseStatus.Released;\n                    if (response.out &&\n                        this.renVM.version(this._state.selector) >= 2) {\n                        let transaction;\n                        try {\n                            if (response.out.txid) {\n                                const txid = response.out.txid;\n                                transaction =\n                                    yield this.params.to.transactionFromRPCFormat(txid, \"\", true);\n                            }\n                            else if (response.out.outpoint) {\n                                const { hash, index } = response.out.outpoint;\n                                transaction =\n                                    yield this.params.to.transactionFromRPCFormat(hash, index.toFixed(), true);\n                            }\n                        }\n                        catch (error) {\n                            this._state.logger.debug(error);\n                        }\n                        if (transaction) {\n                            this.releaseTransaction = transaction;\n                            promiEvent.emit(\"transaction\", transaction);\n                        }\n                    }\n                }\n                return response;\n            }))()\n                .then(promiEvent.resolve)\n                .catch(promiEvent.reject);\n            return promiEvent;\n        };\n        this.params = params;\n        this.renVM = renVM;\n        this._state = {\n            logger: config.logger || NullLogger,\n            selector: this.renVM.selector(this.params),\n            targetConfirmations: undefined,\n            config: Object.assign(Object.assign({}, config), { networkDelay: config.networkDelay || 15 * SECONDS }),\n        };\n        this.validateParams();\n        this.status = this.params.txHash\n            ? BurnAndReleaseStatus.Burned\n            : BurnAndReleaseStatus.Pending;\n        {\n            // Debug log\n            const restOfParams = __rest(this.params, []);\n            this._state.logger.debug(\"burnAndRelease created:\", restOfParams);\n        }\n    }\n}\n//# sourceMappingURL=burnAndRelease.js.map"]},"metadata":{},"sourceType":"module"}