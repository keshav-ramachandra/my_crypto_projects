{"ast":null,"code":"import { assert } from \"@renproject/utils\";\nimport { Secp256k1Program, TransactionInstruction } from \"@solana/web3.js\";\nimport * as BufferLayout from \"buffer-layout\";\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\nconst SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8(\"numSignatures\"), BufferLayout.u16(\"signatureOffset\"), BufferLayout.u8(\"signatureInstructionIndex\"), BufferLayout.u16(\"ethAddressOffset\"), BufferLayout.u8(\"ethAddressInstructionIndex\"), BufferLayout.u16(\"messageDataOffset\"), BufferLayout.u16(\"messageDataSize\"), BufferLayout.u8(\"messageInstructionIndex\"), BufferLayout.blob(21, \"ethAddress\"), BufferLayout.blob(64, \"signature\"), BufferLayout.u8(\"recoveryId\")]);\nexport const toBuffer = arr => {\n  if (arr instanceof Buffer) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return Buffer.from(arr);\n  }\n};\n/**\n * Create an secp256k1 instruction with an Ethereum address.\n *\n * We need to add an extra byte to the ethAddress to match our secp offset\n * */\n\nexport function createInstructionWithEthAddress2(params) {\n  const {\n    ethAddress: rawAddress,\n    message,\n    signature,\n    recoveryId\n  } = params;\n  let ethAddress;\n\n  if (typeof rawAddress === \"string\") {\n    if (rawAddress.startsWith(\"0x\")) {\n      ethAddress = Buffer.from(rawAddress.substr(2), \"hex\");\n    } else {\n      ethAddress = Buffer.from(rawAddress, \"hex\");\n    }\n  } else {\n    ethAddress = rawAddress;\n  }\n\n  assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n  const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n  const ethAddressOffset = dataStart + 1;\n  const signatureOffset = ethAddressOffset + ethAddress.length;\n  const messageDataOffset = signatureOffset + signature.length + 1;\n  const numSignatures = 1;\n  const instructionData = Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n  SECP256K1_INSTRUCTION_LAYOUT.encode({\n    numSignatures,\n    signatureOffset,\n    signatureInstructionIndex: 1,\n    ethAddressOffset,\n    ethAddressInstructionIndex: 1,\n    messageDataOffset,\n    messageDataSize: message.length,\n    messageInstructionIndex: 1,\n    signature: toBuffer(signature),\n    ethAddress: toBuffer([0, ...ethAddress]),\n    recoveryId\n  }, instructionData);\n  instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n  return new TransactionInstruction({\n    keys: [],\n    programId: Secp256k1Program.programId,\n    data: instructionData\n  });\n}","map":{"version":3,"sources":["../../src/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { assert } from \"@renproject/utils\";\nimport { Secp256k1Program, TransactionInstruction, } from \"@solana/web3.js\";\nimport * as BufferLayout from \"buffer-layout\";\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\nconst SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([\n    BufferLayout.u8(\"numSignatures\"),\n    BufferLayout.u16(\"signatureOffset\"),\n    BufferLayout.u8(\"signatureInstructionIndex\"),\n    BufferLayout.u16(\"ethAddressOffset\"),\n    BufferLayout.u8(\"ethAddressInstructionIndex\"),\n    BufferLayout.u16(\"messageDataOffset\"),\n    BufferLayout.u16(\"messageDataSize\"),\n    BufferLayout.u8(\"messageInstructionIndex\"),\n    BufferLayout.blob(21, \"ethAddress\"),\n    BufferLayout.blob(64, \"signature\"),\n    BufferLayout.u8(\"recoveryId\"),\n]);\nexport const toBuffer = (arr) => {\n    if (arr instanceof Buffer) {\n        return arr;\n    }\n    else if (arr instanceof Uint8Array) {\n        return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    }\n    else {\n        return Buffer.from(arr);\n    }\n};\n/**\n * Create an secp256k1 instruction with an Ethereum address.\n *\n * We need to add an extra byte to the ethAddress to match our secp offset\n * */\nexport function createInstructionWithEthAddress2(params) {\n    const { ethAddress: rawAddress, message, signature, recoveryId } = params;\n    let ethAddress;\n    if (typeof rawAddress === \"string\") {\n        if (rawAddress.startsWith(\"0x\")) {\n            ethAddress = Buffer.from(rawAddress.substr(2), \"hex\");\n        }\n        else {\n            ethAddress = Buffer.from(rawAddress, \"hex\");\n        }\n    }\n    else {\n        ethAddress = rawAddress;\n    }\n    assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n    const ethAddressOffset = dataStart + 1;\n    const signatureOffset = ethAddressOffset + ethAddress.length;\n    const messageDataOffset = signatureOffset + signature.length + 1;\n    const numSignatures = 1;\n    const instructionData = Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n    SECP256K1_INSTRUCTION_LAYOUT.encode({\n        numSignatures,\n        signatureOffset,\n        signatureInstructionIndex: 1,\n        ethAddressOffset,\n        ethAddressInstructionIndex: 1,\n        messageDataOffset,\n        messageDataSize: message.length,\n        messageInstructionIndex: 1,\n        signature: toBuffer(signature),\n        ethAddress: toBuffer([0, ...ethAddress]),\n        recoveryId,\n    }, instructionData);\n    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n    return new TransactionInstruction({\n        keys: [],\n        programId: Secp256k1Program.programId,\n        data: instructionData,\n    });\n}\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}