{"ast":null,"code":"'use strict';\n\nvar crypto = require('crypto');\n\nvar BufferUtil = require('../util/buffer');\n\nvar $ = require('../util/preconditions'); // Dogecoin\n\n\nvar Scrypt = require('scryptsy');\n\nvar Hash = module.exports;\n\nHash.scrypt = function (buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return BufferUtil.reverse(Scrypt(buf, buf, 1024, 1, 1, 32));\n};\n\nHash.sha1 = function (buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha1').update(buf).digest();\n};\n\nHash.sha1.blocksize = 512;\n\nHash.sha256 = function (buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha256').update(buf).digest();\n};\n\nHash.sha256.blocksize = 512;\n\nHash.sha256sha256 = function (buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.sha256(Hash.sha256(buf));\n};\n\nHash.ripemd160 = function (buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('ripemd160').update(buf).digest();\n};\n\nHash.sha256ripemd160 = function (buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.ripemd160(Hash.sha256(buf));\n};\n\nHash.sha512 = function (buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha512').update(buf).digest();\n};\n\nHash.sha512.blocksize = 1024;\n\nHash.hmac = function (hashf, data, key) {\n  //http://en.wikipedia.org/wiki/Hash-based_message_authentication_code\n  //http://tools.ietf.org/html/rfc4868#section-2\n  $.checkArgument(BufferUtil.isBuffer(data));\n  $.checkArgument(BufferUtil.isBuffer(key));\n  $.checkArgument(hashf.blocksize);\n  var blocksize = hashf.blocksize / 8;\n\n  if (key.length > blocksize) {\n    key = hashf(key);\n  } else if (key < blocksize) {\n    var fill = Buffer.alloc(blocksize);\n    fill.fill(0);\n    key.copy(fill);\n    key = fill;\n  }\n\n  var o_key = Buffer.alloc(blocksize);\n  o_key.fill(0x5c);\n  var i_key = Buffer.alloc(blocksize);\n  i_key.fill(0x36);\n  var o_key_pad = Buffer.alloc(blocksize);\n  var i_key_pad = Buffer.alloc(blocksize);\n\n  for (var i = 0; i < blocksize; i++) {\n    o_key_pad[i] = o_key[i] ^ key[i];\n    i_key_pad[i] = i_key[i] ^ key[i];\n  }\n\n  return hashf(Buffer.concat([o_key_pad, hashf(Buffer.concat([i_key_pad, data]))]));\n};\n\nHash.sha256hmac = function (data, key) {\n  return Hash.hmac(Hash.sha256, data, key);\n};\n\nHash.sha512hmac = function (data, key) {\n  return Hash.hmac(Hash.sha512, data, key);\n};","map":{"version":3,"sources":["/home/kesha/Downloads/ren-main/renApp/node_modules/@CoinSpace/bitcore-lib-dogecoin/lib/crypto/hash.js"],"names":["crypto","require","BufferUtil","$","Scrypt","Hash","module","exports","scrypt","buf","checkArgument","isBuffer","reverse","sha1","createHash","update","digest","blocksize","sha256","sha256sha256","ripemd160","sha256ripemd160","sha512","hmac","hashf","data","key","length","fill","Buffer","alloc","copy","o_key","i_key","o_key_pad","i_key_pad","i","concat","sha256hmac","sha512hmac"],"mappings":"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","sourcesContent":["'use strict';\n\nvar crypto = require('crypto');\nvar BufferUtil = require('../util/buffer');\nvar $ = require('../util/preconditions');\n\n// Dogecoin\nvar Scrypt = require('scryptsy');\n\nvar Hash = module.exports;\n\nHash.scrypt = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return BufferUtil.reverse(Scrypt(buf, buf, 1024, 1, 1, 32));\n}\n\nHash.sha1 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha1').update(buf).digest();\n};\n\nHash.sha1.blocksize = 512;\n\nHash.sha256 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha256').update(buf).digest();\n};\n\nHash.sha256.blocksize = 512;\n\nHash.sha256sha256 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.sha256(Hash.sha256(buf));\n};\n\nHash.ripemd160 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('ripemd160').update(buf).digest();\n};\n\nHash.sha256ripemd160 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.ripemd160(Hash.sha256(buf));\n};\n\nHash.sha512 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha512').update(buf).digest();\n};\n\nHash.sha512.blocksize = 1024;\n\nHash.hmac = function(hashf, data, key) {\n  //http://en.wikipedia.org/wiki/Hash-based_message_authentication_code\n  //http://tools.ietf.org/html/rfc4868#section-2\n  $.checkArgument(BufferUtil.isBuffer(data));\n  $.checkArgument(BufferUtil.isBuffer(key));\n  $.checkArgument(hashf.blocksize);\n\n  var blocksize = hashf.blocksize / 8;\n\n  if (key.length > blocksize) {\n    key = hashf(key);\n  } else if (key < blocksize) {\n    var fill = Buffer.alloc(blocksize);\n    fill.fill(0);\n    key.copy(fill);\n    key = fill;\n  }\n\n  var o_key = Buffer.alloc(blocksize);\n  o_key.fill(0x5c);\n\n  var i_key = Buffer.alloc(blocksize);\n  i_key.fill(0x36);\n\n  var o_key_pad = Buffer.alloc(blocksize);\n  var i_key_pad = Buffer.alloc(blocksize);\n  for (var i = 0; i < blocksize; i++) {\n    o_key_pad[i] = o_key[i] ^ key[i];\n    i_key_pad[i] = i_key[i] ^ key[i];\n  }\n\n  return hashf(Buffer.concat([o_key_pad, hashf(Buffer.concat([i_key_pad, data]))]));\n};\n\nHash.sha256hmac = function(data, key) {\n  return Hash.hmac(Hash.sha256, data, key);\n};\n\nHash.sha512hmac = function(data, key) {\n  return Hash.hmac(Hash.sha512, data, key);\n};\n"]},"metadata":{},"sourceType":"script"}