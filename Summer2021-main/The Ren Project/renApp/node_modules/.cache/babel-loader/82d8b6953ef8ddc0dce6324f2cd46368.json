{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { assertType } from \"./assert\";\nconst mintABITemplate = {\n  constant: false,\n  inputs: [{\n    name: \"_amount\",\n    type: \"uint256\"\n  }, {\n    name: \"_nHash\",\n    type: \"bytes32\"\n  }, {\n    name: \"_sig\",\n    type: \"bytes\"\n  }],\n  outputs: [],\n  payable: true,\n  stateMutability: \"payable\",\n  type: \"function\"\n};\nconst tupleRegex = /tuple\\(([a-zA-Z0-9]+)(?:,([a-zA-Z0-9]+))*\\)/;\n/**\n * If the type of an Ethereum arg matches `tuple(...)`, then it needs to include\n * a `components` array that provides the name and type of each of the tuple's\n * values. If it wasn't included, `fixTuple` will create the components array.\n */\n\nconst fixTuple = argument => {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const {\n    value\n  } = argument,\n        args = __rest(argument, [\"value\"]);\n\n  try {\n    // If type is `tuple(...)` but components haven't been\n    // been passed in, add them.\n    const match = args && args.type && tupleRegex.exec(args.type);\n\n    if (match && !argument.components) {\n      const types = match.slice(1);\n      const components = [];\n\n      for (let i = 0; i < types.length; i++) {\n        components[i] = {\n          name: String(i),\n          type: types[i]\n        };\n      }\n\n      return Object.assign(Object.assign({}, args), {\n        components\n      });\n    }\n  } catch (error) {\n    console.error(error);\n  }\n\n  return args;\n};\n\nexport const payloadToABI = (methodName, payload) => {\n  // Type validation\n  assertType(\"string\", {\n    methodName\n  });\n  (payload || []).map(({\n    type,\n    name\n  }) => assertType(\"string\", {\n    type,\n    name\n  }));\n  return [{\n    name: methodName,\n    type: \"function\",\n    inputs: [...(payload || []).map(fixTuple).map(value => ({\n      type: value.type,\n      name: value.name,\n      components: value.components\n    }))],\n    outputs: []\n  }];\n};\nexport const payloadToMintABI = (methodName, payload) => {\n  // Type validation\n  assertType(\"string\", {\n    methodName\n  });\n  (payload || []).map(({\n    type,\n    name\n  }) => assertType(\"string\", {\n    type,\n    name\n  }));\n  return [Object.assign(Object.assign({}, mintABITemplate), {\n    name: methodName,\n    inputs: [...(payload || []).map(fixTuple).map(value => ({\n      type: value.type,\n      name: value.name,\n      components: value.components\n    })), ...(mintABITemplate.inputs ? mintABITemplate.inputs : [])]\n  })];\n};","map":{"version":3,"sources":["../../src/abi.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { assertType } from \"./assert\";\nconst mintABITemplate = {\n    constant: false,\n    inputs: [\n        {\n            name: \"_amount\",\n            type: \"uint256\",\n        },\n        {\n            name: \"_nHash\",\n            type: \"bytes32\",\n        },\n        {\n            name: \"_sig\",\n            type: \"bytes\",\n        },\n    ],\n    outputs: [],\n    payable: true,\n    stateMutability: \"payable\",\n    type: \"function\",\n};\nconst tupleRegex = /tuple\\(([a-zA-Z0-9]+)(?:,([a-zA-Z0-9]+))*\\)/;\n/**\n * If the type of an Ethereum arg matches `tuple(...)`, then it needs to include\n * a `components` array that provides the name and type of each of the tuple's\n * values. If it wasn't included, `fixTuple` will create the components array.\n */\nconst fixTuple = (argument) => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { value } = argument, args = __rest(argument, [\"value\"]);\n    try {\n        // If type is `tuple(...)` but components haven't been\n        // been passed in, add them.\n        const match = args && args.type && tupleRegex.exec(args.type);\n        if (match && !argument.components) {\n            const types = match.slice(1);\n            const components = [];\n            for (let i = 0; i < types.length; i++) {\n                components[i] = {\n                    name: String(i),\n                    type: types[i],\n                };\n            }\n            return Object.assign(Object.assign({}, args), { components });\n        }\n    }\n    catch (error) {\n        console.error(error);\n    }\n    return args;\n};\nexport const payloadToABI = (methodName, payload) => {\n    // Type validation\n    assertType(\"string\", { methodName });\n    (payload || []).map(({ type, name }) => assertType(\"string\", { type, name }));\n    return [\n        {\n            name: methodName,\n            type: \"function\",\n            inputs: [\n                ...(payload || []).map(fixTuple).map((value) => ({\n                    type: value.type,\n                    name: value.name,\n                    components: value.components,\n                })),\n            ],\n            outputs: [],\n        },\n    ];\n};\nexport const payloadToMintABI = (methodName, payload) => {\n    // Type validation\n    assertType(\"string\", { methodName });\n    (payload || []).map(({ type, name }) => assertType(\"string\", { type, name }));\n    return [\n        Object.assign(Object.assign({}, mintABITemplate), { name: methodName, inputs: [\n                ...(payload || []).map(fixTuple).map((value) => ({\n                    type: value.type,\n                    name: value.name,\n                    components: value.components,\n                })),\n                ...(mintABITemplate.inputs ? mintABITemplate.inputs : []),\n            ] }),\n    ];\n};\n//# sourceMappingURL=abi.js.map"]},"metadata":{},"sourceType":"module"}