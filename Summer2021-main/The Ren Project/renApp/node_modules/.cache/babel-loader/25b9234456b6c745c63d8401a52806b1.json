{"ast":null,"code":"export var OverrideContractCallError;\n\n(function (OverrideContractCallError) {\n  OverrideContractCallError[\"OverrideArrayLengthError\"] = \"Contract call override must be same length as contract calls array.\";\n})(OverrideContractCallError || (OverrideContractCallError = {}));\n\nconst overrideContractCall = (contractCall, override) => {\n  const overrideParams = (override.contractParams || []).reduce((acc, param) => {\n    if (param.name) {\n      acc[param.name] = param;\n    }\n\n    return acc;\n  }, {});\n  let txConfig;\n\n  if (typeof contractCall.txConfig === \"object\" && typeof override.txConfig === \"object\") {\n    txConfig = Object.assign(Object.assign({}, contractCall.txConfig), override.txConfig);\n  } else {\n    txConfig = override.txConfig || contractCall.txConfig;\n  }\n\n  return Object.assign(Object.assign(Object.assign({}, contractCall), override), {\n    // Clone txConfig\n    txConfig,\n    // Clone contractParams\n    contractParams: (contractCall.contractParams || []).map(contractParam => Object.assign(Object.assign({}, contractParam), overrideParams[contractParam.name]))\n  });\n};\n\nexport const overrideContractCalls = (contractCalls, override) => {\n  if (Array.isArray(override) && override.length !== contractCalls.length) {\n    throw new Error(OverrideContractCallError.OverrideArrayLengthError);\n  }\n\n  return contractCalls.map((contractCall, i) => {\n    const contractCallOverride = Array.isArray(override) ? // If override is an array, there should be an array for each call.\n    override[i] : // If there's only one override, apply it to the last contract call.\n    i === contractCalls.length - 1 ? override : // Default to empty object.\n    {};\n    return overrideContractCall(contractCall, contractCallOverride);\n  });\n};","map":{"version":3,"sources":["../../src/contractCalls.ts"],"names":[],"mappings":"AAEA,OAAA,IAAY,yBAAZ;;AAAA,CAAA,UAAY,yBAAZ,EAAqC;AACjC,EAAA,yBAAA,CAAA,0BAAA,CAAA,GAAA,qEAAA;AACH,CAFD,EAAY,yBAAyB,KAAzB,yBAAyB,GAAA,EAAA,CAArC;;AAIA,MAAM,oBAAoB,GAAG,CACzB,YADyB,EAEzB,QAFyB,KAGzB;AACA,QAAM,cAAc,GAAG,CAAC,QAAQ,CAAC,cAAT,IAA2B,EAA5B,EAAgC,MAAhC,CACnB,CAAC,GAAD,EAAM,KAAN,KAAe;AACX,QAAI,KAAK,CAAC,IAAV,EAAgB;AACZ,MAAA,GAAG,CAAC,KAAK,CAAC,IAAP,CAAH,GAAkB,KAAlB;AACH;;AACD,WAAO,GAAP;AACH,GANkB,EAOnB,EAPmB,CAAvB;AAUA,MAAI,QAAJ;;AACA,MACI,OAAO,YAAY,CAAC,QAApB,KAAiC,QAAjC,IACA,OAAO,QAAQ,CAAC,QAAhB,KAA6B,QAFjC,EAGE;AACE,IAAA,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACD,YAAY,CAAC,QADZ,CAAA,EAED,QAAQ,CAAC,QAFR,CAAR;AAIH,GARD,MAQO;AACH,IAAA,QAAQ,GAAG,QAAQ,CAAC,QAAT,IAAqB,YAAY,CAAC,QAA7C;AACH;;AAED,SAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACO,YADP,CAAA,EAEO,QAFP,CAAA,EAEe;AAEX;AACA,IAAA,QAHW;AAKX;AACA,IAAA,cAAc,EAAE,CAAC,YAAY,CAAC,cAAb,IAA+B,EAAhC,EAAoC,GAApC,CACX,aAAD,IAAmB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACZ,aADY,CAAA,EAEZ,cAAc,CAAC,aAAa,CAAC,IAAf,CAFF,CADP;AANL,GAFf,CAAA;AAeH,CA1CD;;AAkDA,OAAO,MAAM,qBAAqB,GAAG,CACjC,aADiC,EAEjC,QAFiC,KAGjB;AAChB,MAAI,KAAK,CAAC,OAAN,CAAc,QAAd,KAA2B,QAAQ,CAAC,MAAT,KAAoB,aAAa,CAAC,MAAjE,EAAyE;AACrE,UAAM,IAAI,KAAJ,CAAU,yBAAyB,CAAC,wBAApC,CAAN;AACH;;AAED,SAAO,aAAa,CAAC,GAAd,CAAkB,CAAC,YAAD,EAAe,CAAf,KAAoB;AACzC,UAAM,oBAAoB,GAAG,KAAK,CAAC,OAAN,CAAc,QAAd,IACvB;AACA,IAAA,QAAQ,CAAC,CAAD,CAFe,GAGvB;AACF,IAAA,CAAC,KAAK,aAAa,CAAC,MAAd,GAAuB,CAA7B,GACE,QADF,GAEE;AACA,MAPN;AAQA,WAAO,oBAAoB,CAAC,YAAD,EAAe,oBAAf,CAA3B;AACH,GAVM,CAAP;AAWH,CAnBM","sourceRoot":"","sourcesContent":["export var OverrideContractCallError;\n(function (OverrideContractCallError) {\n    OverrideContractCallError[\"OverrideArrayLengthError\"] = \"Contract call override must be same length as contract calls array.\";\n})(OverrideContractCallError || (OverrideContractCallError = {}));\nconst overrideContractCall = (contractCall, override) => {\n    const overrideParams = (override.contractParams || []).reduce((acc, param) => {\n        if (param.name) {\n            acc[param.name] = param;\n        }\n        return acc;\n    }, {});\n    let txConfig;\n    if (typeof contractCall.txConfig === \"object\" &&\n        typeof override.txConfig === \"object\") {\n        txConfig = Object.assign(Object.assign({}, contractCall.txConfig), override.txConfig);\n    }\n    else {\n        txConfig = override.txConfig || contractCall.txConfig;\n    }\n    return Object.assign(Object.assign(Object.assign({}, contractCall), override), { \n        // Clone txConfig\n        txConfig, \n        // Clone contractParams\n        contractParams: (contractCall.contractParams || []).map((contractParam) => (Object.assign(Object.assign({}, contractParam), overrideParams[contractParam.name]))) });\n};\nexport const overrideContractCalls = (contractCalls, override) => {\n    if (Array.isArray(override) && override.length !== contractCalls.length) {\n        throw new Error(OverrideContractCallError.OverrideArrayLengthError);\n    }\n    return contractCalls.map((contractCall, i) => {\n        const contractCallOverride = Array.isArray(override)\n            ? // If override is an array, there should be an array for each call.\n                override[i]\n            : // If there's only one override, apply it to the last contract call.\n                i === contractCalls.length - 1\n                    ? override\n                    : // Default to empty object.\n                        {};\n        return overrideContractCall(contractCall, contractCallOverride);\n    });\n};\n//# sourceMappingURL=contractCalls.js.map"]},"metadata":{},"sourceType":"module"}