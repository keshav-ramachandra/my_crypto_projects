{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar inherits = require('inherits');\n\nvar Transaction = require('../transaction');\n\nvar Input = require('./input');\n\nvar Output = require('../output');\n\nvar $ = require('../../util/preconditions');\n\nvar Script = require('../../script');\n\nvar Signature = require('../../crypto/signature');\n\nvar Sighash = require('../sighash');\n\nvar PublicKey = require('../../publickey');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar TransactionSignature = require('../signature');\n/**\n * @constructor\n */\n\n\nfunction MultiSigInput(input, pubkeys, threshold, signatures, opts) {\n  opts = opts || {};\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys;\n  } else {\n    this.publicKeys = _.sortBy(pubkeys, function (publicKey) {\n      return publicKey.toString('hex');\n    });\n  }\n\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script), 'Provided public keys don\\'t match to the provided output script');\n  this.publicKeyIndex = {};\n\n  _.each(this.publicKeys, function (publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n\n  this.threshold = threshold; // Empty array of signatures\n\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\n\ninherits(MultiSigInput, Input);\n\nMultiSigInput.prototype.toObject = function () {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function (publicKey) {\n    return publicKey.toString();\n  });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigInput.prototype._deserializeSignatures = function (signatures) {\n  return _.map(signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigInput.prototype._serializeSignatures = function () {\n  return _.map(this.signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n\n    return signature.toObject();\n  });\n};\n\nMultiSigInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  var self = this;\n  var results = [];\n\n  _.each(this.publicKeys, function (publicKey) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: self.prevTxId,\n        outputIndex: self.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script),\n        sigtype: sigtype\n      }));\n    }\n  });\n\n  return results;\n};\n\nMultiSigInput.prototype.addSignature = function (transaction, signature) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]), 'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature));\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n\n  this._updateScript();\n\n  return this;\n};\n\nMultiSigInput.prototype._updateScript = function () {\n  this.setScript(Script.buildMultisigIn(this.publicKeys, this.threshold, this._createSignatures()));\n  return this;\n};\n\nMultiSigInput.prototype._createSignatures = function () {\n  return _.map(_.filter(this.signatures, function (signature) {\n    return !_.isUndefined(signature);\n  }), function (signature) {\n    return BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]);\n  });\n};\n\nMultiSigInput.prototype.clearSignatures = function () {\n  this.signatures = new Array(this.publicKeys.length);\n\n  this._updateScript();\n};\n\nMultiSigInput.prototype.isFullySigned = function () {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigInput.prototype.countMissingSignatures = function () {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigInput.prototype.countSignatures = function () {\n  return _.reduce(this.signatures, function (sum, signature) {\n    return sum + !!signature;\n  }, 0);\n};\n\nMultiSigInput.prototype.publicKeysWithoutSignature = function () {\n  var self = this;\n  return _.filter(this.publicKeys, function (publicKey) {\n    return !self.signatures[self.publicKeyIndex[publicKey.toString()]];\n  });\n};\n\nMultiSigInput.prototype.isValidSignature = function (transaction, signature) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script);\n};\n/**\n *\n * @param {Buffer[]} signatures\n * @param {PublicKey[]} publicKeys\n * @param {Transaction} transaction\n * @param {Integer} inputIndex\n * @param {Input} input\n * @returns {TransactionSignature[]}\n */\n\n\nMultiSigInput.normalizeSignatures = function (transaction, input, inputIndex, signatures, publicKeys) {\n  return publicKeys.map(function (pubKey) {\n    var signatureMatch = null;\n    signatures = signatures.filter(function (signatureBuffer) {\n      if (signatureMatch) {\n        return true;\n      }\n\n      var signature = new TransactionSignature({\n        signature: Signature.fromTxFormat(signatureBuffer),\n        publicKey: pubKey,\n        prevTxId: input.prevTxId,\n        outputIndex: input.outputIndex,\n        inputIndex: inputIndex,\n        sigtype: Signature.SIGHASH_ALL\n      });\n      signature.signature.nhashtype = signature.sigtype;\n      var isMatch = Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, input.output.script);\n\n      if (isMatch) {\n        signatureMatch = signature;\n        return false;\n      }\n\n      return true;\n    });\n    return signatureMatch ? signatureMatch : null;\n  });\n};\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\n\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\nMultiSigInput.prototype._estimateSize = function () {\n  return MultiSigInput.OPCODES_SIZE + this.threshold * MultiSigInput.SIGNATURE_SIZE;\n};\n\nmodule.exports = MultiSigInput;","map":{"version":3,"sources":["/home/kesha/Downloads/ren-main/renApp/node_modules/@CoinSpace/bitcore-lib-dogecoin/lib/transaction/input/multisig.js"],"names":["_","require","inherits","Transaction","Input","Output","$","Script","Signature","Sighash","PublicKey","BufferUtil","TransactionSignature","MultiSigInput","input","pubkeys","threshold","signatures","opts","apply","arguments","self","publicKeys","noSorting","sortBy","publicKey","toString","checkState","buildMultisigOut","equals","output","script","publicKeyIndex","each","index","_deserializeSignatures","Array","length","prototype","toObject","obj","map","_serializeSignatures","signature","undefined","getSignatures","transaction","privateKey","sigtype","SIGHASH_ALL","results","push","prevTxId","outputIndex","inputIndex","sign","addSignature","isFullySigned","checkArgument","isUndefined","isValidSignature","_updateScript","setScript","buildMultisigIn","_createSignatures","filter","concat","toDER","integerAsSingleByteBuffer","clearSignatures","countSignatures","countMissingSignatures","reduce","sum","publicKeysWithoutSignature","nhashtype","verify","normalizeSignatures","pubKey","signatureMatch","signatureBuffer","fromTxFormat","isMatch","OPCODES_SIZE","SIGNATURE_SIZE","_estimateSize","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAf;;AACA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAIE,WAAW,GAAGF,OAAO,CAAC,gBAAD,CAAzB;;AACA,IAAIG,KAAK,GAAGH,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAII,MAAM,GAAGJ,OAAO,CAAC,WAAD,CAApB;;AACA,IAAIK,CAAC,GAAGL,OAAO,CAAC,0BAAD,CAAf;;AAEA,IAAIM,MAAM,GAAGN,OAAO,CAAC,cAAD,CAApB;;AACA,IAAIO,SAAS,GAAGP,OAAO,CAAC,wBAAD,CAAvB;;AACA,IAAIQ,OAAO,GAAGR,OAAO,CAAC,YAAD,CAArB;;AACA,IAAIS,SAAS,GAAGT,OAAO,CAAC,iBAAD,CAAvB;;AACA,IAAIU,UAAU,GAAGV,OAAO,CAAC,mBAAD,CAAxB;;AACA,IAAIW,oBAAoB,GAAGX,OAAO,CAAC,cAAD,CAAlC;AAEA;AACA;AACA;;;AACA,SAASY,aAAT,CAAuBC,KAAvB,EAA8BC,OAA9B,EAAuCC,SAAvC,EAAkDC,UAAlD,EAA8DC,IAA9D,EAAoE;AAClEA,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAd,EAAAA,KAAK,CAACe,KAAN,CAAY,IAAZ,EAAkBC,SAAlB;AACA,MAAIC,IAAI,GAAG,IAAX;AACAN,EAAAA,OAAO,GAAGA,OAAO,IAAID,KAAK,CAACQ,UAA3B;AACAN,EAAAA,SAAS,GAAGA,SAAS,IAAIF,KAAK,CAACE,SAA/B;AACAC,EAAAA,UAAU,GAAGA,UAAU,IAAIH,KAAK,CAACG,UAAjC;;AACA,MAAIC,IAAI,CAACK,SAAT,EAAoB;AAClB,SAAKD,UAAL,GAAkBP,OAAlB;AACD,GAFD,MAEQ;AACN,SAAKO,UAAL,GAAkBtB,CAAC,CAACwB,MAAF,CAAST,OAAT,EAAkB,UAASU,SAAT,EAAoB;AAAE,aAAOA,SAAS,CAACC,QAAV,CAAmB,KAAnB,CAAP;AAAmC,KAA3E,CAAlB;AACD;;AACDpB,EAAAA,CAAC,CAACqB,UAAF,CAAapB,MAAM,CAACqB,gBAAP,CAAwB,KAAKN,UAA7B,EAAyCN,SAAzC,EAAoDa,MAApD,CAA2D,KAAKC,MAAL,CAAYC,MAAvE,CAAb,EACE,iEADF;AAEA,OAAKC,cAAL,GAAsB,EAAtB;;AACAhC,EAAAA,CAAC,CAACiC,IAAF,CAAO,KAAKX,UAAZ,EAAwB,UAASG,SAAT,EAAoBS,KAApB,EAA2B;AACjDb,IAAAA,IAAI,CAACW,cAAL,CAAoBP,SAAS,CAACC,QAAV,EAApB,IAA4CQ,KAA5C;AACD,GAFD;;AAGA,OAAKlB,SAAL,GAAiBA,SAAjB,CAlBkE,CAmBlE;;AACA,OAAKC,UAAL,GAAkBA,UAAU,GAAG,KAAKkB,sBAAL,CAA4BlB,UAA5B,CAAH,GAA6C,IAAImB,KAAJ,CAAU,KAAKd,UAAL,CAAgBe,MAA1B,CAAzE;AACD;;AACDnC,QAAQ,CAACW,aAAD,EAAgBT,KAAhB,CAAR;;AAEAS,aAAa,CAACyB,SAAd,CAAwBC,QAAxB,GAAmC,YAAW;AAC5C,MAAIC,GAAG,GAAGpC,KAAK,CAACkC,SAAN,CAAgBC,QAAhB,CAAyBpB,KAAzB,CAA+B,IAA/B,EAAqCC,SAArC,CAAV;AACAoB,EAAAA,GAAG,CAACxB,SAAJ,GAAgB,KAAKA,SAArB;AACAwB,EAAAA,GAAG,CAAClB,UAAJ,GAAiBtB,CAAC,CAACyC,GAAF,CAAM,KAAKnB,UAAX,EAAuB,UAASG,SAAT,EAAoB;AAAE,WAAOA,SAAS,CAACC,QAAV,EAAP;AAA8B,GAA3E,CAAjB;AACAc,EAAAA,GAAG,CAACvB,UAAJ,GAAiB,KAAKyB,oBAAL,EAAjB;AACA,SAAOF,GAAP;AACD,CAND;;AAQA3B,aAAa,CAACyB,SAAd,CAAwBH,sBAAxB,GAAiD,UAASlB,UAAT,EAAqB;AACpE,SAAOjB,CAAC,CAACyC,GAAF,CAAMxB,UAAN,EAAkB,UAAS0B,SAAT,EAAoB;AAC3C,QAAI,CAACA,SAAL,EAAgB;AACd,aAAOC,SAAP;AACD;;AACD,WAAO,IAAIhC,oBAAJ,CAAyB+B,SAAzB,CAAP;AACD,GALM,CAAP;AAMD,CAPD;;AASA9B,aAAa,CAACyB,SAAd,CAAwBI,oBAAxB,GAA+C,YAAW;AACxD,SAAO1C,CAAC,CAACyC,GAAF,CAAM,KAAKxB,UAAX,EAAuB,UAAS0B,SAAT,EAAoB;AAChD,QAAI,CAACA,SAAL,EAAgB;AACd,aAAOC,SAAP;AACD;;AACD,WAAOD,SAAS,CAACJ,QAAV,EAAP;AACD,GALM,CAAP;AAMD,CAPD;;AASA1B,aAAa,CAACyB,SAAd,CAAwBO,aAAxB,GAAwC,UAASC,WAAT,EAAsBC,UAAtB,EAAkCb,KAAlC,EAAyCc,OAAzC,EAAkD;AACxF1C,EAAAA,CAAC,CAACqB,UAAF,CAAa,KAAKG,MAAL,YAAuBzB,MAApC;AACA2C,EAAAA,OAAO,GAAGA,OAAO,IAAIxC,SAAS,CAACyC,WAA/B;AAEA,MAAI5B,IAAI,GAAG,IAAX;AACA,MAAI6B,OAAO,GAAG,EAAd;;AACAlD,EAAAA,CAAC,CAACiC,IAAF,CAAO,KAAKX,UAAZ,EAAwB,UAASG,SAAT,EAAoB;AAC1C,QAAIA,SAAS,CAACC,QAAV,OAAyBqB,UAAU,CAACtB,SAAX,CAAqBC,QAArB,EAA7B,EAA8D;AAC5DwB,MAAAA,OAAO,CAACC,IAAR,CAAa,IAAIvC,oBAAJ,CAAyB;AACpCa,QAAAA,SAAS,EAAEsB,UAAU,CAACtB,SADc;AAEpC2B,QAAAA,QAAQ,EAAE/B,IAAI,CAAC+B,QAFqB;AAGpCC,QAAAA,WAAW,EAAEhC,IAAI,CAACgC,WAHkB;AAIpCC,QAAAA,UAAU,EAAEpB,KAJwB;AAKpCS,QAAAA,SAAS,EAAElC,OAAO,CAAC8C,IAAR,CAAaT,WAAb,EAA0BC,UAA1B,EAAsCC,OAAtC,EAA+Cd,KAA/C,EAAsDb,IAAI,CAACS,MAAL,CAAYC,MAAlE,CALyB;AAMpCiB,QAAAA,OAAO,EAAEA;AAN2B,OAAzB,CAAb;AAQD;AACF,GAXD;;AAaA,SAAOE,OAAP;AACD,CApBD;;AAsBArC,aAAa,CAACyB,SAAd,CAAwBkB,YAAxB,GAAuC,UAASV,WAAT,EAAsBH,SAAtB,EAAiC;AACtErC,EAAAA,CAAC,CAACqB,UAAF,CAAa,CAAC,KAAK8B,aAAL,EAAd,EAAoC,+CAApC;AACAnD,EAAAA,CAAC,CAACoD,aAAF,CAAgB,CAAC1D,CAAC,CAAC2D,WAAF,CAAc,KAAK3B,cAAL,CAAoBW,SAAS,CAAClB,SAAV,CAAoBC,QAApB,EAApB,CAAd,CAAjB,EACE,sCADF;AAEApB,EAAAA,CAAC,CAACqB,UAAF,CAAa,KAAKiC,gBAAL,CAAsBd,WAAtB,EAAmCH,SAAnC,CAAb;AACA,OAAK1B,UAAL,CAAgB,KAAKe,cAAL,CAAoBW,SAAS,CAAClB,SAAV,CAAoBC,QAApB,EAApB,CAAhB,IAAuEiB,SAAvE;;AACA,OAAKkB,aAAL;;AACA,SAAO,IAAP;AACD,CARD;;AAUAhD,aAAa,CAACyB,SAAd,CAAwBuB,aAAxB,GAAwC,YAAW;AACjD,OAAKC,SAAL,CAAevD,MAAM,CAACwD,eAAP,CACb,KAAKzC,UADQ,EAEb,KAAKN,SAFQ,EAGb,KAAKgD,iBAAL,EAHa,CAAf;AAKA,SAAO,IAAP;AACD,CAPD;;AASAnD,aAAa,CAACyB,SAAd,CAAwB0B,iBAAxB,GAA4C,YAAW;AACrD,SAAOhE,CAAC,CAACyC,GAAF,CACLzC,CAAC,CAACiE,MAAF,CAAS,KAAKhD,UAAd,EAA0B,UAAS0B,SAAT,EAAoB;AAAE,WAAO,CAAC3C,CAAC,CAAC2D,WAAF,CAAchB,SAAd,CAAR;AAAmC,GAAnF,CADK,EAEL,UAASA,SAAT,EAAoB;AAClB,WAAOhC,UAAU,CAACuD,MAAX,CAAkB,CACvBvB,SAAS,CAACA,SAAV,CAAoBwB,KAApB,EADuB,EAEvBxD,UAAU,CAACyD,yBAAX,CAAqCzB,SAAS,CAACK,OAA/C,CAFuB,CAAlB,CAAP;AAID,GAPI,CAAP;AASD,CAVD;;AAYAnC,aAAa,CAACyB,SAAd,CAAwB+B,eAAxB,GAA0C,YAAW;AACnD,OAAKpD,UAAL,GAAkB,IAAImB,KAAJ,CAAU,KAAKd,UAAL,CAAgBe,MAA1B,CAAlB;;AACA,OAAKwB,aAAL;AACD,CAHD;;AAKAhD,aAAa,CAACyB,SAAd,CAAwBmB,aAAxB,GAAwC,YAAW;AACjD,SAAO,KAAKa,eAAL,OAA2B,KAAKtD,SAAvC;AACD,CAFD;;AAIAH,aAAa,CAACyB,SAAd,CAAwBiC,sBAAxB,GAAiD,YAAW;AAC1D,SAAO,KAAKvD,SAAL,GAAiB,KAAKsD,eAAL,EAAxB;AACD,CAFD;;AAIAzD,aAAa,CAACyB,SAAd,CAAwBgC,eAAxB,GAA0C,YAAW;AACnD,SAAOtE,CAAC,CAACwE,MAAF,CAAS,KAAKvD,UAAd,EAA0B,UAASwD,GAAT,EAAc9B,SAAd,EAAyB;AACxD,WAAO8B,GAAG,GAAI,CAAC,CAAC9B,SAAhB;AACD,GAFM,EAEJ,CAFI,CAAP;AAGD,CAJD;;AAMA9B,aAAa,CAACyB,SAAd,CAAwBoC,0BAAxB,GAAqD,YAAW;AAC9D,MAAIrD,IAAI,GAAG,IAAX;AACA,SAAOrB,CAAC,CAACiE,MAAF,CAAS,KAAK3C,UAAd,EAA0B,UAASG,SAAT,EAAoB;AACnD,WAAO,CAAEJ,IAAI,CAACJ,UAAL,CAAgBI,IAAI,CAACW,cAAL,CAAoBP,SAAS,CAACC,QAAV,EAApB,CAAhB,CAAT;AACD,GAFM,CAAP;AAGD,CALD;;AAOAb,aAAa,CAACyB,SAAd,CAAwBsB,gBAAxB,GAA2C,UAASd,WAAT,EAAsBH,SAAtB,EAAiC;AAC1E;AACAA,EAAAA,SAAS,CAACA,SAAV,CAAoBgC,SAApB,GAAgChC,SAAS,CAACK,OAA1C;AACA,SAAOvC,OAAO,CAACmE,MAAR,CACL9B,WADK,EAELH,SAAS,CAACA,SAFL,EAGLA,SAAS,CAAClB,SAHL,EAILkB,SAAS,CAACW,UAJL,EAKL,KAAKxB,MAAL,CAAYC,MALP,CAAP;AAOD,CAVD;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAlB,aAAa,CAACgE,mBAAd,GAAoC,UAAS/B,WAAT,EAAsBhC,KAAtB,EAA6BwC,UAA7B,EAAyCrC,UAAzC,EAAqDK,UAArD,EAAiE;AACnG,SAAOA,UAAU,CAACmB,GAAX,CAAe,UAAUqC,MAAV,EAAkB;AACtC,QAAIC,cAAc,GAAG,IAArB;AACA9D,IAAAA,UAAU,GAAGA,UAAU,CAACgD,MAAX,CAAkB,UAAUe,eAAV,EAA2B;AACxD,UAAID,cAAJ,EAAoB;AAClB,eAAO,IAAP;AACD;;AAED,UAAIpC,SAAS,GAAG,IAAI/B,oBAAJ,CAAyB;AACvC+B,QAAAA,SAAS,EAAEnC,SAAS,CAACyE,YAAV,CAAuBD,eAAvB,CAD4B;AAEvCvD,QAAAA,SAAS,EAAEqD,MAF4B;AAGvC1B,QAAAA,QAAQ,EAAEtC,KAAK,CAACsC,QAHuB;AAIvCC,QAAAA,WAAW,EAAEvC,KAAK,CAACuC,WAJoB;AAKvCC,QAAAA,UAAU,EAAEA,UAL2B;AAMvCN,QAAAA,OAAO,EAAExC,SAAS,CAACyC;AANoB,OAAzB,CAAhB;AASAN,MAAAA,SAAS,CAACA,SAAV,CAAoBgC,SAApB,GAAgChC,SAAS,CAACK,OAA1C;AACA,UAAIkC,OAAO,GAAGzE,OAAO,CAACmE,MAAR,CACV9B,WADU,EAEVH,SAAS,CAACA,SAFA,EAGVA,SAAS,CAAClB,SAHA,EAIVkB,SAAS,CAACW,UAJA,EAKVxC,KAAK,CAACgB,MAAN,CAAaC,MALH,CAAd;;AAQA,UAAImD,OAAJ,EAAa;AACXH,QAAAA,cAAc,GAAGpC,SAAjB;AACA,eAAO,KAAP;AACD;;AAED,aAAO,IAAP;AACD,KA7BY,CAAb;AA+BA,WAAOoC,cAAc,GAAGA,cAAH,GAAoB,IAAzC;AACD,GAlCM,CAAP;AAmCD,CApCD;;AAsCAlE,aAAa,CAACsE,YAAd,GAA6B,CAA7B,C,CAAgC;;AAChCtE,aAAa,CAACuE,cAAd,GAA+B,EAA/B,C,CAAmC;;AAEnCvE,aAAa,CAACyB,SAAd,CAAwB+C,aAAxB,GAAwC,YAAW;AACjD,SAAOxE,aAAa,CAACsE,YAAd,GACL,KAAKnE,SAAL,GAAiBH,aAAa,CAACuE,cADjC;AAED,CAHD;;AAKAE,MAAM,CAACC,OAAP,GAAiB1E,aAAjB","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar inherits = require('inherits');\nvar Transaction = require('../transaction');\nvar Input = require('./input');\nvar Output = require('../output');\nvar $ = require('../../util/preconditions');\n\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar Sighash = require('../sighash');\nvar PublicKey = require('../../publickey');\nvar BufferUtil = require('../../util/buffer');\nvar TransactionSignature = require('../signature');\n\n/**\n * @constructor\n */\nfunction MultiSigInput(input, pubkeys, threshold, signatures, opts) {\n  opts = opts || {};\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys\n  } else  {\n    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\n  }\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),\n    'Provided public keys don\\'t match to the provided output script');\n  this.publicKeyIndex = {};\n  _.each(this.publicKeys, function(publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n  this.threshold = threshold;\n  // Empty array of signatures\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\ninherits(MultiSigInput, Input);\n\nMultiSigInput.prototype.toObject = function() {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigInput.prototype._deserializeSignatures = function(signatures) {\n  return _.map(signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigInput.prototype._serializeSignatures = function() {\n  return _.map(this.signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return signature.toObject();\n  });\n};\n\nMultiSigInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n\n  var self = this;\n  var results = [];\n  _.each(this.publicKeys, function(publicKey) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: self.prevTxId,\n        outputIndex: self.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script),\n        sigtype: sigtype\n      }));\n    }\n  });\n\n  return results;\n};\n\nMultiSigInput.prototype.addSignature = function(transaction, signature) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]),\n    'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature));\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n  this._updateScript();\n  return this;\n};\n\nMultiSigInput.prototype._updateScript = function() {\n  this.setScript(Script.buildMultisigIn(\n    this.publicKeys,\n    this.threshold,\n    this._createSignatures()\n  ));\n  return this;\n};\n\nMultiSigInput.prototype._createSignatures = function() {\n  return _.map(\n    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),\n    function(signature) {\n      return BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]);\n    }\n  );\n};\n\nMultiSigInput.prototype.clearSignatures = function() {\n  this.signatures = new Array(this.publicKeys.length);\n  this._updateScript();\n};\n\nMultiSigInput.prototype.isFullySigned = function() {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigInput.prototype.countMissingSignatures = function() {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigInput.prototype.countSignatures = function() {\n  return _.reduce(this.signatures, function(sum, signature) {\n    return sum + (!!signature);\n  }, 0);\n};\n\nMultiSigInput.prototype.publicKeysWithoutSignature = function() {\n  var self = this;\n  return _.filter(this.publicKeys, function(publicKey) {\n    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);\n  });\n};\n\nMultiSigInput.prototype.isValidSignature = function(transaction, signature) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(\n    transaction,\n    signature.signature,\n    signature.publicKey,\n    signature.inputIndex,\n    this.output.script\n  );\n};\n\n/**\n *\n * @param {Buffer[]} signatures\n * @param {PublicKey[]} publicKeys\n * @param {Transaction} transaction\n * @param {Integer} inputIndex\n * @param {Input} input\n * @returns {TransactionSignature[]}\n */\nMultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys) {\n  return publicKeys.map(function (pubKey) {\n    var signatureMatch = null;\n    signatures = signatures.filter(function (signatureBuffer) {\n      if (signatureMatch) {\n        return true;\n      }\n\n      var signature = new TransactionSignature({\n        signature: Signature.fromTxFormat(signatureBuffer),\n        publicKey: pubKey,\n        prevTxId: input.prevTxId,\n        outputIndex: input.outputIndex,\n        inputIndex: inputIndex,\n        sigtype: Signature.SIGHASH_ALL\n      });\n\n      signature.signature.nhashtype = signature.sigtype;\n      var isMatch = Sighash.verify(\n          transaction,\n          signature.signature,\n          signature.publicKey,\n          signature.inputIndex,\n          input.output.script\n      );\n\n      if (isMatch) {\n        signatureMatch = signature;\n        return false;\n      }\n\n      return true;\n    });\n\n    return signatureMatch ? signatureMatch : null;\n  });\n};\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\nMultiSigInput.prototype._estimateSize = function() {\n  return MultiSigInput.OPCODES_SIZE +\n    this.threshold * MultiSigInput.SIGNATURE_SIZE;\n};\n\nmodule.exports = MultiSigInput;\n"]},"metadata":{},"sourceType":"script"}