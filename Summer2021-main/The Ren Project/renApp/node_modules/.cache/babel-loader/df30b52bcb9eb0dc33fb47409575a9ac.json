{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.marshalTypedPackValue = exports.marshalPackValue = exports.marshalPackStruct = exports.marshalPackPrimitive = exports.marshalPackTypeDefinition = exports.marshalPackStructType = exports.marshalString = exports.marshalU256 = exports.marshalU128 = exports.marshalU64 = exports.marshalU32 = exports.marshalU16 = exports.marshalU8 = exports.marshalUint = exports.marshalPackType = void 0;\n\nconst utils_1 = require(\"@renproject/utils\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst pack_1 = require(\"./pack\");\n\nconst marshalPackType = type => {\n  switch (type) {\n    case \"nil\":\n      return 0;\n    // KindBool is the kind of all Bool values.\n\n    case pack_1.PackPrimitive.Bool:\n      return 1;\n    // KindU8 is the kind of all U8 values.\n\n    case pack_1.PackPrimitive.U8:\n      return 2;\n    // KindU16 is the kind of all U16 values.\n\n    case pack_1.PackPrimitive.U16:\n      return 3;\n    // KindU32 is the kind of all U32 values.\n\n    case pack_1.PackPrimitive.U32:\n      return 4;\n    // KindU64 is the kind of all U64 values.\n\n    case pack_1.PackPrimitive.U64:\n      return 5;\n    // KindU128 is the kind of all U128 values.\n\n    case pack_1.PackPrimitive.U128:\n      return 6;\n    // KindU256 is the kind of all U256 values.\n\n    case pack_1.PackPrimitive.U256:\n      return 7;\n    // KindString is the kind of all utf8 strings.\n\n    case pack_1.PackPrimitive.Str:\n      return 10;\n    // KindBytes is the kind of all dynamic byte arrays.\n\n    case pack_1.PackPrimitive.Bytes:\n      return 11;\n    // KindBytes32 is the kind of all 32-byte arrays.\n\n    case pack_1.PackPrimitive.Bytes32:\n      return 12;\n    // KindBytes65 is the kind of all 65-byte arrays.\n\n    case pack_1.PackPrimitive.Bytes65:\n      return 13;\n    // KindStruct is the kind of all struct values. It is abstract, because it does\n    // not specify the fields in the struct.\n\n    case \"struct\":\n      return 20;\n    // KindList is the kind of all list values. It is abstract, because it does\n    // not specify the type of the elements in the list.\n\n    case \"list\":\n      return 21;\n  }\n\n  throw new Error(`Unknown type ${String(type)}.`);\n};\n\nexports.marshalPackType = marshalPackType;\n\nconst marshalUint = (value, length) => {\n  try {\n    return new bn_js_1.default(typeof value === \"number\" ? value : value.toString()).toArrayLike(Buffer, \"be\", length);\n  } catch (error) {\n    error.message = `Unable to marshal uint${length * 8} '${value}': ${String(error.message)}`;\n    throw error;\n  }\n};\n\nexports.marshalUint = marshalUint;\n\nconst marshalU = length => value => exports.marshalUint(value, length);\n\nexports.marshalU8 = marshalU(8 / 8);\nexports.marshalU16 = marshalU(16 / 8);\nexports.marshalU32 = marshalU(32 / 8);\nexports.marshalU64 = marshalU(64 / 8);\nexports.marshalU128 = marshalU(128 / 8);\nexports.marshalU256 = marshalU(256 / 8);\n\nconst withLength = value => Buffer.concat([exports.marshalU32(value.length), value]);\n\nconst marshalString = value => {\n  return withLength(Buffer.from(value));\n};\n\nexports.marshalString = marshalString;\n\nconst marshalPackStructType = type => {\n  const length = exports.marshalU32(type.struct.length);\n  return Buffer.concat([length, ...type.struct.map(field => {\n    const keys = Object.keys(field);\n\n    if (keys.length === 0) {\n      throw new Error(`Invalid struct field with no entries.`);\n    }\n\n    if (keys.length > 1) {\n      throw new Error(`Invalid struct field with multiple entries.`);\n    }\n\n    const key = Object.keys(field)[0];\n    const fieldType = field[key];\n    return Buffer.concat([exports.marshalString(key), exports.marshalPackTypeDefinition(fieldType)]);\n  })]);\n};\n\nexports.marshalPackStructType = marshalPackStructType;\n\nconst marshalPackTypeDefinition = type => {\n  if (typeof type === \"object\") {\n    return Buffer.concat([Buffer.from([exports.marshalPackType(\"struct\")]), exports.marshalPackStructType(type)]);\n  } else if (typeof type === \"string\") {\n    return Buffer.from([exports.marshalPackType(type)]);\n  }\n\n  throw new Error(`Unable to marshal type ${String(type)}.`);\n};\n\nexports.marshalPackTypeDefinition = marshalPackTypeDefinition;\n\nconst marshalPackPrimitive = (type, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue) => {\n  switch (type) {\n    // Booleans\n    case pack_1.PackPrimitive.Bool:\n      return exports.marshalU8(value ? 1 : 0);\n    // Integers\n\n    case pack_1.PackPrimitive.U8:\n      return exports.marshalU8(value);\n\n    case pack_1.PackPrimitive.U16:\n      return exports.marshalU16(value);\n\n    case pack_1.PackPrimitive.U32:\n      return exports.marshalU32(value);\n\n    case pack_1.PackPrimitive.U64:\n      return exports.marshalU64(value);\n\n    case pack_1.PackPrimitive.U128:\n      return exports.marshalU128(value);\n\n    case pack_1.PackPrimitive.U256:\n      return exports.marshalU256(value);\n    // Strings\n\n    case pack_1.PackPrimitive.Str:\n      {\n        return exports.marshalString(value);\n      }\n    // Bytes\n\n    case pack_1.PackPrimitive.Bytes:\n      {\n        return withLength(Buffer.isBuffer(value) ? Buffer.from(value) : // Supports base64 url format\n        utils_1.fromBase64(value));\n      }\n\n    case pack_1.PackPrimitive.Bytes32:\n    case pack_1.PackPrimitive.Bytes65:\n      return Buffer.isBuffer(value) ? Buffer.from(value) : // Supports base64 url format\n      utils_1.fromBase64(value);\n  }\n};\n\nexports.marshalPackPrimitive = marshalPackPrimitive; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst marshalPackStruct = (type, value) => {\n  return Buffer.concat(type.struct.map(member => {\n    const keys = Object.keys(member);\n\n    if (keys.length === 0) {\n      throw new Error(`Invalid struct member with no entries.`);\n    }\n\n    if (keys.length > 1) {\n      throw new Error(`Invalid struct member with multiple entries.`);\n    }\n\n    const key = Object.keys(member)[0];\n    const memberType = member[key];\n\n    try {\n      return exports.marshalPackValue(memberType, value[key]);\n    } catch (error) {\n      error.message = `Unable to marshal struct field ${key}: ${String(error.message)}`;\n      throw error;\n    }\n  }));\n};\n\nexports.marshalPackStruct = marshalPackStruct;\n\nconst marshalPackValue = (type, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue) => {\n  if (typeof type === \"object\") {\n    return exports.marshalPackStruct(type, value);\n  } else if (typeof type === \"string\") {\n    if (type === \"nil\") return Buffer.from([]);\n    return exports.marshalPackPrimitive(type, value);\n  }\n\n  throw new Error(`Unknown value type ${String(type)}${!type ? ` for value ${String(value)}` : \"\"}`);\n};\n\nexports.marshalPackValue = marshalPackValue;\n\nconst marshalTypedPackValue = ({\n  t,\n  v\n}) => {\n  const marshalledType = exports.marshalPackTypeDefinition(t);\n  const marshalledValue = exports.marshalPackValue(t, v);\n  return Buffer.concat([marshalledType, marshalledValue]);\n};\n\nexports.marshalTypedPackValue = marshalTypedPackValue;","map":{"version":3,"sources":["../../../../src/v2/pack/marshal.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.marshalTypedPackValue = exports.marshalPackValue = exports.marshalPackStruct = exports.marshalPackPrimitive = exports.marshalPackTypeDefinition = exports.marshalPackStructType = exports.marshalString = exports.marshalU256 = exports.marshalU128 = exports.marshalU64 = exports.marshalU32 = exports.marshalU16 = exports.marshalU8 = exports.marshalUint = exports.marshalPackType = void 0;\nconst utils_1 = require(\"@renproject/utils\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst pack_1 = require(\"./pack\");\nconst marshalPackType = (type) => {\n    switch (type) {\n        case \"nil\":\n            return 0;\n        // KindBool is the kind of all Bool values.\n        case pack_1.PackPrimitive.Bool:\n            return 1;\n        // KindU8 is the kind of all U8 values.\n        case pack_1.PackPrimitive.U8:\n            return 2;\n        // KindU16 is the kind of all U16 values.\n        case pack_1.PackPrimitive.U16:\n            return 3;\n        // KindU32 is the kind of all U32 values.\n        case pack_1.PackPrimitive.U32:\n            return 4;\n        // KindU64 is the kind of all U64 values.\n        case pack_1.PackPrimitive.U64:\n            return 5;\n        // KindU128 is the kind of all U128 values.\n        case pack_1.PackPrimitive.U128:\n            return 6;\n        // KindU256 is the kind of all U256 values.\n        case pack_1.PackPrimitive.U256:\n            return 7;\n        // KindString is the kind of all utf8 strings.\n        case pack_1.PackPrimitive.Str:\n            return 10;\n        // KindBytes is the kind of all dynamic byte arrays.\n        case pack_1.PackPrimitive.Bytes:\n            return 11;\n        // KindBytes32 is the kind of all 32-byte arrays.\n        case pack_1.PackPrimitive.Bytes32:\n            return 12;\n        // KindBytes65 is the kind of all 65-byte arrays.\n        case pack_1.PackPrimitive.Bytes65:\n            return 13;\n        // KindStruct is the kind of all struct values. It is abstract, because it does\n        // not specify the fields in the struct.\n        case \"struct\":\n            return 20;\n        // KindList is the kind of all list values. It is abstract, because it does\n        // not specify the type of the elements in the list.\n        case \"list\":\n            return 21;\n    }\n    throw new Error(`Unknown type ${String(type)}.`);\n};\nexports.marshalPackType = marshalPackType;\nconst marshalUint = (value, length) => {\n    try {\n        return new bn_js_1.default(typeof value === \"number\" ? value : value.toString()).toArrayLike(Buffer, \"be\", length);\n    }\n    catch (error) {\n        error.message = `Unable to marshal uint${length * 8} '${value}': ${String(error.message)}`;\n        throw error;\n    }\n};\nexports.marshalUint = marshalUint;\nconst marshalU = (length) => (value) => exports.marshalUint(value, length);\nexports.marshalU8 = marshalU(8 / 8);\nexports.marshalU16 = marshalU(16 / 8);\nexports.marshalU32 = marshalU(32 / 8);\nexports.marshalU64 = marshalU(64 / 8);\nexports.marshalU128 = marshalU(128 / 8);\nexports.marshalU256 = marshalU(256 / 8);\nconst withLength = (value) => Buffer.concat([exports.marshalU32(value.length), value]);\nconst marshalString = (value) => {\n    return withLength(Buffer.from(value));\n};\nexports.marshalString = marshalString;\nconst marshalPackStructType = (type) => {\n    const length = exports.marshalU32(type.struct.length);\n    return Buffer.concat([\n        length,\n        ...type.struct.map((field) => {\n            const keys = Object.keys(field);\n            if (keys.length === 0) {\n                throw new Error(`Invalid struct field with no entries.`);\n            }\n            if (keys.length > 1) {\n                throw new Error(`Invalid struct field with multiple entries.`);\n            }\n            const key = Object.keys(field)[0];\n            const fieldType = field[key];\n            return Buffer.concat([\n                exports.marshalString(key),\n                exports.marshalPackTypeDefinition(fieldType),\n            ]);\n        }),\n    ]);\n};\nexports.marshalPackStructType = marshalPackStructType;\nconst marshalPackTypeDefinition = (type) => {\n    if (typeof type === \"object\") {\n        return Buffer.concat([\n            Buffer.from([exports.marshalPackType(\"struct\")]),\n            exports.marshalPackStructType(type),\n        ]);\n    }\n    else if (typeof type === \"string\") {\n        return Buffer.from([exports.marshalPackType(type)]);\n    }\n    throw new Error(`Unable to marshal type ${String(type)}.`);\n};\nexports.marshalPackTypeDefinition = marshalPackTypeDefinition;\nconst marshalPackPrimitive = (type, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue) => {\n    switch (type) {\n        // Booleans\n        case pack_1.PackPrimitive.Bool:\n            return exports.marshalU8(value ? 1 : 0);\n        // Integers\n        case pack_1.PackPrimitive.U8:\n            return exports.marshalU8(value);\n        case pack_1.PackPrimitive.U16:\n            return exports.marshalU16(value);\n        case pack_1.PackPrimitive.U32:\n            return exports.marshalU32(value);\n        case pack_1.PackPrimitive.U64:\n            return exports.marshalU64(value);\n        case pack_1.PackPrimitive.U128:\n            return exports.marshalU128(value);\n        case pack_1.PackPrimitive.U256:\n            return exports.marshalU256(value);\n        // Strings\n        case pack_1.PackPrimitive.Str: {\n            return exports.marshalString(value);\n        }\n        // Bytes\n        case pack_1.PackPrimitive.Bytes: {\n            return withLength(Buffer.isBuffer(value)\n                ? Buffer.from(value)\n                : // Supports base64 url format\n                    utils_1.fromBase64(value));\n        }\n        case pack_1.PackPrimitive.Bytes32:\n        case pack_1.PackPrimitive.Bytes65:\n            return Buffer.isBuffer(value)\n                ? Buffer.from(value)\n                : // Supports base64 url format\n                    utils_1.fromBase64(value);\n    }\n};\nexports.marshalPackPrimitive = marshalPackPrimitive;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst marshalPackStruct = (type, value) => {\n    return Buffer.concat(type.struct.map((member) => {\n        const keys = Object.keys(member);\n        if (keys.length === 0) {\n            throw new Error(`Invalid struct member with no entries.`);\n        }\n        if (keys.length > 1) {\n            throw new Error(`Invalid struct member with multiple entries.`);\n        }\n        const key = Object.keys(member)[0];\n        const memberType = member[key];\n        try {\n            return exports.marshalPackValue(memberType, value[key]);\n        }\n        catch (error) {\n            error.message = `Unable to marshal struct field ${key}: ${String(error.message)}`;\n            throw error;\n        }\n    }));\n};\nexports.marshalPackStruct = marshalPackStruct;\nconst marshalPackValue = (type, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue) => {\n    if (typeof type === \"object\") {\n        return exports.marshalPackStruct(type, value);\n    }\n    else if (typeof type === \"string\") {\n        if (type === \"nil\")\n            return Buffer.from([]);\n        return exports.marshalPackPrimitive(type, value);\n    }\n    throw new Error(`Unknown value type ${String(type)}${!type ? ` for value ${String(value)}` : \"\"}`);\n};\nexports.marshalPackValue = marshalPackValue;\nconst marshalTypedPackValue = ({ t, v }) => {\n    const marshalledType = exports.marshalPackTypeDefinition(t);\n    const marshalledValue = exports.marshalPackValue(t, v);\n    return Buffer.concat([marshalledType, marshalledValue]);\n};\nexports.marshalTypedPackValue = marshalTypedPackValue;\n//# sourceMappingURL=marshal.js.map"]},"metadata":{},"sourceType":"script"}