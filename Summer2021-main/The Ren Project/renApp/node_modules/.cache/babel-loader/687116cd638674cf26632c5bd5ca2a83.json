{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unmarshalBurnTx = exports.unmarshalMintTx = void 0;\n\nconst utils_1 = require(\"@renproject/utils\");\n\nconst pack_1 = require(\"./pack/pack\");\n\nconst unmarshalMintTx = response => {\n  // Note: Numbers are decoded and re-encoded to ensure they are in the correct format.\n  utils_1.assert(/\\/to/.exec(response.tx.selector) !== null, `Expected mint details but got back burn details (${response.tx.hash} - ${response.tx.selector})`);\n  let out;\n  const inValue = pack_1.unmarshalTypedPackValue(response.tx.in);\n\n  if (response.tx.out) {\n    out = pack_1.unmarshalTypedPackValue(response.tx.out); // Temporary fix to support v0.4.\n\n    if (out.revert && out.revert.length === 0) {\n      out.revert = undefined;\n    }\n\n    if (out.sig) {\n      const [r, s, v] = [out.sig.slice(0, 32), out.sig.slice(32, 64), out.sig[64] % 27];\n      out.signature = utils_1.signatureToBuffer(utils_1.fixSignatureSimple(r, s, v));\n      out.nhash = inValue.nhash;\n      out.phash = inValue.phash;\n    }\n  }\n\n  return {\n    version: response.tx.version ? parseInt(response.tx.version) : undefined,\n    hash: response.tx.hash,\n    txStatus: response.txStatus,\n    to: response.tx.selector,\n    in: inValue,\n    out\n  };\n};\n\nexports.unmarshalMintTx = unmarshalMintTx;\n\nconst unmarshalBurnTx = response => {\n  utils_1.assert(/\\/from/.exec(response.tx.selector) !== null, `Expected burn details but got back mint details (${response.tx.hash} - ${response.tx.selector})`);\n  let out;\n\n  if (response.tx.out) {\n    out = pack_1.unmarshalTypedPackValue(response.tx.out);\n  }\n\n  return {\n    version: response.tx.version ? parseInt(response.tx.version) : undefined,\n    hash: response.tx.hash,\n    to: response.tx.selector,\n    in: pack_1.unmarshalTypedPackValue(response.tx.in),\n    txStatus: response.txStatus,\n    out\n  };\n};\n\nexports.unmarshalBurnTx = unmarshalBurnTx; // const unmarshalAssetFees = (fees: Fees): RenVMAssetFees => {\n//     const { lock, release, ...tokens } = fees;\n//     // TODO: Fix type errors.\n//     return ({\n//         lock: decodeNumber(lock).toNumber(),\n//         release: decodeNumber(release).toNumber(),\n//         ...Object.keys(tokens).reduce(\n//             (acc, token) => ({\n//                 ...acc,\n//                 [token]: {\n//                     mint: decodeNumber(fees[token].mint).toNumber(),\n//                     burn: decodeNumber(fees[token].burn).toNumber(),\n//                 },\n//             }),\n//             {},\n//         ),\n//     } as unknown) as RenVMAssetFees;\n// };\n// export const unmarshalFees = (response: ResponseQueryFees): RenVMFees => {\n//     const fees = {};\n//     for (const key of Object.keys(response)) {\n//         fees[key] = unmarshalAssetFees(response[key]);\n//     }\n//     return fees;\n// };","map":{"version":3,"sources":["../../../src/v2/unmarshal.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unmarshalBurnTx = exports.unmarshalMintTx = void 0;\nconst utils_1 = require(\"@renproject/utils\");\nconst pack_1 = require(\"./pack/pack\");\nconst unmarshalMintTx = (response) => {\n    // Note: Numbers are decoded and re-encoded to ensure they are in the correct format.\n    utils_1.assert(/\\/to/.exec(response.tx.selector) !== null, `Expected mint details but got back burn details (${response.tx.hash} - ${response.tx.selector})`);\n    let out;\n    const inValue = pack_1.unmarshalTypedPackValue(response.tx.in);\n    if (response.tx.out) {\n        out = pack_1.unmarshalTypedPackValue(response.tx.out);\n        // Temporary fix to support v0.4.\n        if (out.revert && out.revert.length === 0) {\n            out.revert = undefined;\n        }\n        if (out.sig) {\n            const [r, s, v] = [\n                out.sig.slice(0, 32),\n                out.sig.slice(32, 64),\n                out.sig[64] % 27,\n            ];\n            out.signature = utils_1.signatureToBuffer(utils_1.fixSignatureSimple(r, s, v));\n            out.nhash = inValue.nhash;\n            out.phash = inValue.phash;\n        }\n    }\n    return {\n        version: response.tx.version\n            ? parseInt(response.tx.version)\n            : undefined,\n        hash: response.tx.hash,\n        txStatus: response.txStatus,\n        to: response.tx.selector,\n        in: inValue,\n        out,\n    };\n};\nexports.unmarshalMintTx = unmarshalMintTx;\nconst unmarshalBurnTx = (response) => {\n    utils_1.assert(/\\/from/.exec(response.tx.selector) !== null, `Expected burn details but got back mint details (${response.tx.hash} - ${response.tx.selector})`);\n    let out;\n    if (response.tx.out) {\n        out = pack_1.unmarshalTypedPackValue(response.tx.out);\n    }\n    return {\n        version: response.tx.version\n            ? parseInt(response.tx.version)\n            : undefined,\n        hash: response.tx.hash,\n        to: response.tx.selector,\n        in: pack_1.unmarshalTypedPackValue(response.tx.in),\n        txStatus: response.txStatus,\n        out,\n    };\n};\nexports.unmarshalBurnTx = unmarshalBurnTx;\n// const unmarshalAssetFees = (fees: Fees): RenVMAssetFees => {\n//     const { lock, release, ...tokens } = fees;\n//     // TODO: Fix type errors.\n//     return ({\n//         lock: decodeNumber(lock).toNumber(),\n//         release: decodeNumber(release).toNumber(),\n//         ...Object.keys(tokens).reduce(\n//             (acc, token) => ({\n//                 ...acc,\n//                 [token]: {\n//                     mint: decodeNumber(fees[token].mint).toNumber(),\n//                     burn: decodeNumber(fees[token].burn).toNumber(),\n//                 },\n//             }),\n//             {},\n//         ),\n//     } as unknown) as RenVMAssetFees;\n// };\n// export const unmarshalFees = (response: ResponseQueryFees): RenVMFees => {\n//     const fees = {};\n//     for (const key of Object.keys(response)) {\n//         fees[key] = unmarshalAssetFees(response[key]);\n//     }\n//     return fees;\n// };\n//# sourceMappingURL=unmarshal.js.map"]},"metadata":{},"sourceType":"script"}