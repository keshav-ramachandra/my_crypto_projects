{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport BigNumber from \"bignumber.js\";\nimport AbiCoder from \"web3-eth-abi\";\nimport { assertType } from \"./assert\";\n/**\n * Represents 1 second for functions that accept a parameter in milliseconds.\n */\n\nexport const SECONDS = 1000;\n/**\n * Pauses the thread for the specified number of milliseconds.\n *\n * @param ms The number of milliseconds to pause for.\n */\n\nexport const sleep = ms => __awaiter(void 0, void 0, void 0, function* () {\n  return new Promise(resolve => setTimeout(resolve, ms));\n});\n/**\n * Remove 0x prefix from a hex string. If the input doesn't have a 0x prefix,\n * it's returned unchanged.\n *\n * @param hex The hex value to be prefixed.\n */\n\nexport const strip0x = hex => {\n  // Type validation\n  assertType(\"string\", {\n    hex\n  });\n  return hex.substring(0, 2) === \"0x\" ? hex.slice(2) : hex;\n};\n/**\n * Add a 0x prefix to a hex value, converting to a string first. If the input\n * is already prefixed, it's returned unchanged.\n *\n * @param hex The hex value to be prefixed.\n */\n\nexport const Ox = (hex, {\n  prefix\n} = {\n  prefix: \"0x\"\n}) => {\n  const hexString = typeof hex === \"string\" ? hex : hex.toString(\"hex\");\n  return hexString.substring(0, 2) === prefix ? hexString : `${prefix}${hexString}`;\n};\nexport const fromHex = hex => {\n  assertType(\"Buffer | string\", {\n    hex\n  });\n  return Buffer.isBuffer(hex) ? Buffer.from(hex) : Buffer.from(strip0x(hex), \"hex\");\n};\nexport const fromBase64 = base64 => {\n  assertType(\"Buffer | string\", {\n    base64\n  });\n  return Buffer.isBuffer(base64) ? Buffer.from(base64) : Buffer.from(base64, \"base64\");\n};\nexport const toBase64 = input => {\n  assertType(\"Buffer\", {\n    input\n  });\n  return input.toString(\"base64\");\n};\nexport const fromBigNumber = bn => {\n  const bnStr = bn.toString(16); // Pad if necessary\n\n  return Buffer.from(bnStr.length % 2 ? \"0\" + bnStr : bnStr, \"hex\");\n}; // Unpadded alternate base64 encoding defined in RFC 4648, commonly used in\n// URLs.\n\nexport const toURLBase64 = input => {\n  assertType(\"Buffer | string\", {\n    input\n  });\n  return (Buffer.isBuffer(input) ? Buffer.from(input) : fromHex(input)).toString(\"base64\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=+$/, \"\");\n};\nexport const toReadable = (value, decimals) => new BigNumber(value).dividedBy(new BigNumber(10).exponentiatedBy(decimals));\nexport const fromReadable = (value, decimals) => new BigNumber(value).times(new BigNumber(10).exponentiatedBy(decimals)).decimalPlaces(0);\n\nconst hasOwnProperty = ( // eslint-disable-next-line @typescript-eslint/no-explicit-any\nobject, property) => {\n  return object.hasOwnProperty(property);\n};\n\nconst invalidError = errorMessage => errorMessage === \"\" || errorMessage === \"null\" || errorMessage === \"undefined\";\n\nexport const extractError = error => {\n  if (error && typeof error === \"object\") {\n    if (hasOwnProperty(error, \"response\") && error.response) {\n      const extractedError = extractError(error.response);\n\n      if (!invalidError(extractedError)) {\n        return extractedError;\n      }\n    }\n\n    if (hasOwnProperty(error, \"data\") && error.data) {\n      const extractedError = extractError(error.data);\n\n      if (!invalidError(extractedError)) {\n        return extractedError;\n      }\n    }\n\n    if (hasOwnProperty(error, \"error\") && error.error) {\n      const extractedError = extractError(error.error);\n\n      if (!invalidError(extractedError)) {\n        return extractedError;\n      }\n    }\n\n    if (hasOwnProperty(error, \"context\") && error.context) {\n      const extractedError = extractError(error.context);\n\n      if (!invalidError(extractedError)) {\n        return extractedError;\n      }\n    }\n\n    if (hasOwnProperty(error, \"message\") && error.message) {\n      const extractedError = extractError(error.message);\n\n      if (!invalidError(extractedError)) {\n        return extractedError;\n      }\n    }\n\n    if (hasOwnProperty(error, \"statusText\") && error.statusText) {\n      const extractedError = extractError(error.statusText);\n\n      if (!invalidError(extractedError)) {\n        return extractedError;\n      }\n    }\n  }\n\n  try {\n    if (typeof error === \"string\") {\n      if (error.slice(0, 7) === \"Error: \") {\n        error = error.slice(7);\n      }\n\n      return error;\n    }\n\n    return JSON.stringify(error);\n  } catch (innerError) {// Ignore JSON error\n  }\n\n  return String(error);\n};\nexport const retryNTimes = (fnCall, retries, timeout = 1 * SECONDS, // in ms\nlogger) => __awaiter(void 0, void 0, void 0, function* () {\n  let returnError;\n  const errorMessages = new Set();\n\n  for (let i = 0; retries === -1 || i < retries; i++) {\n    try {\n      return yield fnCall();\n    } catch (error) {\n      // Fix error message.\n      const errorMessage = extractError(error);\n      errorMessages.add(errorMessage);\n      returnError = error;\n\n      if (i < retries || retries === -1) {\n        yield sleep(timeout);\n\n        if (logger) {\n          logger.warn(error);\n        }\n      }\n    }\n  }\n\n  returnError.message = Array.from(errorMessages).join(\", \");\n  throw returnError;\n});\n/**\n * Generates a random hex string (prefixed with '0x').\n *\n * @param bytes The number of bytes to generate.\n */\n\nexport const randomBytes = bytes => {\n  try {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (window) {\n      const uints = new Uint32Array(bytes / 4); // 4 bytes (32 bits)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n\n      window.crypto.getRandomValues(uints);\n      let str = \"\";\n\n      for (const uint of uints) {\n        str += \"0\".repeat(8 - uint.toString(16).length) + String(uint.toString(16));\n      }\n\n      return fromHex(str);\n    }\n  } catch (error) {// Ignore error\n  } // eslint-disable-next-line @typescript-eslint/no-var-requires\n\n\n  const crypto = require(\"crypto\");\n\n  return crypto.randomBytes(bytes);\n};\n/**\n * Returns a random 32 byte Buffer.\n */\n\nexport const randomNonce = () => randomBytes(32);\nexport const emptyNonce = () => fromHex(\"00\".repeat(32));\nexport const rawEncode = (types, parameters) => {\n  return fromHex(AbiCoder.encodeParameters(types, parameters));\n};\n/**\n * isDefined returns true if the parameter is defined and not null.\n */\n\nexport const isDefined = x => x !== null && x !== undefined;\n\nconst assert = (input, reason) => {\n  if (!input) {\n    throw new Error(reason || `Assertion failed.`);\n  }\n};\n/**\n * Returns false if the method throws or returns false - returns true otherwise.\n */\n\n\nexport const doesntError = f => {\n  return (...p) => {\n    try {\n      const response = f(...p);\n      return response === undefined || response === true ? true : false;\n    } catch (error) {\n      return false;\n    }\n  };\n};\n/**\n * Returns true if the\n */\n\nexport const isBase64 = doesntError((input, options = {}) => {\n  const buffer = Buffer.from(input, \"base64\");\n  assert(options.length === undefined || buffer.length === options.length, `Expected ${String(options.length)} bytes.`);\n  assert(buffer.toString(\"base64\") === input);\n});\nexport const isURLBase64 = doesntError((input, options = {}) => {\n  const buffer = Buffer.from(input, \"base64\");\n  assert(options.length === undefined || buffer.length === options.length, `Expected ${String(options.length)} bytes.`);\n  assert(toURLBase64(buffer) === input);\n});\nexport const isHex = doesntError((input, options = {}) => {\n  if (options.prefix) {\n    assert(input.slice(0, 2) === \"0x\");\n    input = input.slice(2);\n  }\n\n  const buffer = Buffer.from(input, \"hex\");\n  assert(options.length === undefined || buffer.length === options.length, `Expected ${String(options.length)} bytes.`);\n  assert(buffer.toString(\"hex\") === input);\n});","map":{"version":3,"sources":["../../src/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport BigNumber from \"bignumber.js\";\nimport AbiCoder from \"web3-eth-abi\";\nimport { assertType } from \"./assert\";\n/**\n * Represents 1 second for functions that accept a parameter in milliseconds.\n */\nexport const SECONDS = 1000;\n/**\n * Pauses the thread for the specified number of milliseconds.\n *\n * @param ms The number of milliseconds to pause for.\n */\nexport const sleep = (ms) => __awaiter(void 0, void 0, void 0, function* () { return new Promise((resolve) => setTimeout(resolve, ms)); });\n/**\n * Remove 0x prefix from a hex string. If the input doesn't have a 0x prefix,\n * it's returned unchanged.\n *\n * @param hex The hex value to be prefixed.\n */\nexport const strip0x = (hex) => {\n    // Type validation\n    assertType(\"string\", { hex });\n    return hex.substring(0, 2) === \"0x\" ? hex.slice(2) : hex;\n};\n/**\n * Add a 0x prefix to a hex value, converting to a string first. If the input\n * is already prefixed, it's returned unchanged.\n *\n * @param hex The hex value to be prefixed.\n */\nexport const Ox = (hex, { prefix } = { prefix: \"0x\" }) => {\n    const hexString = typeof hex === \"string\" ? hex : hex.toString(\"hex\");\n    return hexString.substring(0, 2) === prefix\n        ? hexString\n        : `${prefix}${hexString}`;\n};\nexport const fromHex = (hex) => {\n    assertType(\"Buffer | string\", { hex });\n    return Buffer.isBuffer(hex)\n        ? Buffer.from(hex)\n        : Buffer.from(strip0x(hex), \"hex\");\n};\nexport const fromBase64 = (base64) => {\n    assertType(\"Buffer | string\", {\n        base64,\n    });\n    return Buffer.isBuffer(base64)\n        ? Buffer.from(base64)\n        : Buffer.from(base64, \"base64\");\n};\nexport const toBase64 = (input) => {\n    assertType(\"Buffer\", { input });\n    return input.toString(\"base64\");\n};\nexport const fromBigNumber = (bn) => {\n    const bnStr = bn.toString(16);\n    // Pad if necessary\n    return Buffer.from(bnStr.length % 2 ? \"0\" + bnStr : bnStr, \"hex\");\n};\n// Unpadded alternate base64 encoding defined in RFC 4648, commonly used in\n// URLs.\nexport const toURLBase64 = (input) => {\n    assertType(\"Buffer | string\", {\n        input,\n    });\n    return (Buffer.isBuffer(input) ? Buffer.from(input) : fromHex(input))\n        .toString(\"base64\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\")\n        .replace(/\\=+$/, \"\");\n};\nexport const toReadable = (value, decimals) => new BigNumber(value).dividedBy(new BigNumber(10).exponentiatedBy(decimals));\nexport const fromReadable = (value, decimals) => new BigNumber(value)\n    .times(new BigNumber(10).exponentiatedBy(decimals))\n    .decimalPlaces(0);\nconst hasOwnProperty = (\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nobject, property) => {\n    return object.hasOwnProperty(property);\n};\nconst invalidError = (errorMessage) => errorMessage === \"\" ||\n    errorMessage === \"null\" ||\n    errorMessage === \"undefined\";\nexport const extractError = (error) => {\n    if (error && typeof error === \"object\") {\n        if (hasOwnProperty(error, \"response\") && error.response) {\n            const extractedError = extractError(error.response);\n            if (!invalidError(extractedError)) {\n                return extractedError;\n            }\n        }\n        if (hasOwnProperty(error, \"data\") && error.data) {\n            const extractedError = extractError(error.data);\n            if (!invalidError(extractedError)) {\n                return extractedError;\n            }\n        }\n        if (hasOwnProperty(error, \"error\") && error.error) {\n            const extractedError = extractError(error.error);\n            if (!invalidError(extractedError)) {\n                return extractedError;\n            }\n        }\n        if (hasOwnProperty(error, \"context\") && error.context) {\n            const extractedError = extractError(error.context);\n            if (!invalidError(extractedError)) {\n                return extractedError;\n            }\n        }\n        if (hasOwnProperty(error, \"message\") && error.message) {\n            const extractedError = extractError(error.message);\n            if (!invalidError(extractedError)) {\n                return extractedError;\n            }\n        }\n        if (hasOwnProperty(error, \"statusText\") && error.statusText) {\n            const extractedError = extractError(error.statusText);\n            if (!invalidError(extractedError)) {\n                return extractedError;\n            }\n        }\n    }\n    try {\n        if (typeof error === \"string\") {\n            if (error.slice(0, 7) === \"Error: \") {\n                error = error.slice(7);\n            }\n            return error;\n        }\n        return JSON.stringify(error);\n    }\n    catch (innerError) {\n        // Ignore JSON error\n    }\n    return String(error);\n};\nexport const retryNTimes = (fnCall, retries, timeout = 1 * SECONDS, // in ms\nlogger) => __awaiter(void 0, void 0, void 0, function* () {\n    let returnError;\n    const errorMessages = new Set();\n    for (let i = 0; retries === -1 || i < retries; i++) {\n        try {\n            return yield fnCall();\n        }\n        catch (error) {\n            // Fix error message.\n            const errorMessage = extractError(error);\n            errorMessages.add(errorMessage);\n            returnError = error;\n            if (i < retries || retries === -1) {\n                yield sleep(timeout);\n                if (logger) {\n                    logger.warn(error);\n                }\n            }\n        }\n    }\n    returnError.message = Array.from(errorMessages).join(\", \");\n    throw returnError;\n});\n/**\n * Generates a random hex string (prefixed with '0x').\n *\n * @param bytes The number of bytes to generate.\n */\nexport const randomBytes = (bytes) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        if (window) {\n            const uints = new Uint32Array(bytes / 4); // 4 bytes (32 bits)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            window.crypto.getRandomValues(uints);\n            let str = \"\";\n            for (const uint of uints) {\n                str +=\n                    \"0\".repeat(8 - uint.toString(16).length) +\n                        String(uint.toString(16));\n            }\n            return fromHex(str);\n        }\n    }\n    catch (error) {\n        // Ignore error\n    }\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const crypto = require(\"crypto\");\n    return crypto.randomBytes(bytes);\n};\n/**\n * Returns a random 32 byte Buffer.\n */\nexport const randomNonce = () => randomBytes(32);\nexport const emptyNonce = () => fromHex(\"00\".repeat(32));\nexport const rawEncode = (types, parameters) => {\n    return fromHex(AbiCoder.encodeParameters(types, parameters));\n};\n/**\n * isDefined returns true if the parameter is defined and not null.\n */\nexport const isDefined = (x) => x !== null && x !== undefined;\nconst assert = (input, reason) => {\n    if (!input) {\n        throw new Error(reason || `Assertion failed.`);\n    }\n};\n/**\n * Returns false if the method throws or returns false - returns true otherwise.\n */\nexport const doesntError = (f) => {\n    return (...p) => {\n        try {\n            const response = f(...p);\n            return response === undefined || response === true ? true : false;\n        }\n        catch (error) {\n            return false;\n        }\n    };\n};\n/**\n * Returns true if the\n */\nexport const isBase64 = doesntError((input, options = {}) => {\n    const buffer = Buffer.from(input, \"base64\");\n    assert(options.length === undefined || buffer.length === options.length, `Expected ${String(options.length)} bytes.`);\n    assert(buffer.toString(\"base64\") === input);\n});\nexport const isURLBase64 = doesntError((input, options = {}) => {\n    const buffer = Buffer.from(input, \"base64\");\n    assert(options.length === undefined || buffer.length === options.length, `Expected ${String(options.length)} bytes.`);\n    assert(toURLBase64(buffer) === input);\n});\nexport const isHex = doesntError((input, options = {}) => {\n    if (options.prefix) {\n        assert(input.slice(0, 2) === \"0x\");\n        input = input.slice(2);\n    }\n    const buffer = Buffer.from(input, \"hex\");\n    assert(options.length === undefined || buffer.length === options.length, `Expected ${String(options.length)} bytes.`);\n    assert(buffer.toString(\"hex\") === input);\n});\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}