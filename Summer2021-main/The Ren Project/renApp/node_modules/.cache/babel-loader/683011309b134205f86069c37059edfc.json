{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Callable } from \"@renproject/utils\";\nimport axios from \"axios\";\nimport { sortUTXOs, DEFAULT_TIMEOUT } from \"./API\";\nexport var BlockchairNetwork;\n\n(function (BlockchairNetwork) {\n  BlockchairNetwork[\"BITCOIN\"] = \"bitcoin\";\n  BlockchairNetwork[\"BITCOIN_CASH\"] = \"bitcoin-cash\";\n  BlockchairNetwork[\"LITECOIN\"] = \"litecoin\";\n  BlockchairNetwork[\"BITCOIN_SV\"] = \"bitcoin-sv\";\n  BlockchairNetwork[\"DOGECOIN\"] = \"dogecoin\";\n  BlockchairNetwork[\"DASH\"] = \"dash\";\n  BlockchairNetwork[\"GROESTLCOIN\"] = \"groestlcoin\";\n  BlockchairNetwork[\"BITCOIN_TESTNET\"] = \"bitcoin/testnet\";\n})(BlockchairNetwork || (BlockchairNetwork = {}));\n\nexport class BlockchairClass {\n  constructor(network = BlockchairNetwork.BITCOIN) {\n    this.endpoint = () => `https://api.blockchair.com/${this.network}`;\n\n    this.fetchUTXO = (txHash, vOut) => __awaiter(this, void 0, void 0, function* () {\n      const url = `${this.endpoint()}/dashboards/transaction/${txHash}`;\n      const response = (yield axios.get(`${url}`, {\n        timeout: DEFAULT_TIMEOUT\n      })).data;\n\n      if (!response.data[txHash]) {\n        throw new Error(`Transaction not found.`);\n      }\n\n      const tx = response.data[txHash];\n      let latestBlock = response.context.state;\n\n      if (latestBlock === 0) {\n        const statsUrl = `${this.endpoint()}/stats`;\n        const statsResponse = (yield axios.get(statsUrl, {\n          timeout: DEFAULT_TIMEOUT\n        })).data;\n        latestBlock = statsResponse.data.blocks - 1;\n      }\n\n      const confirmations = tx.transaction.block_id === -1 ? 0 : Math.max(latestBlock - tx.transaction.block_id + 1, 0);\n      return {\n        txHash,\n        vOut,\n        amount: tx.outputs[vOut].value.toString(),\n        confirmations\n      };\n    });\n\n    this.fetchUTXOs = (address, confirmations = 0) => __awaiter(this, void 0, void 0, function* () {\n      const url = `${this.endpoint()}/dashboards/address/${address}?limit=0,100`;\n      const response = (yield axios.get(url, {\n        timeout: DEFAULT_TIMEOUT\n      })).data;\n      let latestBlock = response.context.state;\n\n      if (latestBlock === 0) {\n        const statsUrl = `${this.endpoint()}/stats`;\n        const statsResponse = (yield axios.get(statsUrl, {\n          timeout: DEFAULT_TIMEOUT\n        })).data;\n        latestBlock = statsResponse.data.blocks - 1;\n      }\n\n      return response.data[address].utxo.map(utxo => ({\n        txHash: utxo.transaction_hash,\n        amount: utxo.value.toString(),\n        vOut: utxo.index,\n        confirmations: utxo.block_id === -1 ? 0 : latestBlock - utxo.block_id + 1\n      })).filter(utxo => confirmations === 0 || utxo.confirmations >= confirmations).sort(sortUTXOs);\n    });\n\n    this.fetchTXs = (address, confirmations = 0, limit = 25) => __awaiter(this, void 0, void 0, function* () {\n      const url = `${this.endpoint()}/dashboards/address/${address}?limit=${limit},0`;\n      const response = (yield axios.get(url, {\n        timeout: DEFAULT_TIMEOUT\n      })).data;\n      let latestBlock = response.context.state;\n\n      if (latestBlock === 0) {\n        const statsUrl = `${this.endpoint()}/stats`;\n        const statsResponse = (yield axios.get(statsUrl, {\n          timeout: DEFAULT_TIMEOUT\n        })).data;\n        latestBlock = statsResponse.data.blocks - 1;\n      }\n\n      const txHashes = response.data[address].transactions;\n      let txDetails = {}; // Fetch in sets of 10\n\n      for (let i = 0; i < Math.ceil(txHashes.length / 10); i++) {\n        const txUrl = `${this.endpoint()}/dashboards/transactions/${txHashes.slice(i * 10, (i + 1) * 10).join(\",\")}`;\n        const txResponse = (yield axios.get(txUrl, {\n          timeout: DEFAULT_TIMEOUT\n        })).data;\n        txDetails = Object.assign(Object.assign({}, txDetails), txResponse.data);\n      }\n\n      const received = [];\n\n      for (const txHash of txHashes) {\n        const tx = txDetails[txHash];\n        const txConfirmations = tx.transaction.block_id === -1 ? 0 : Math.max(latestBlock - tx.transaction.block_id + 1, 0);\n\n        for (let i = 0; i < tx.outputs.length; i++) {\n          const output = tx.outputs[i];\n\n          if (output.recipient === address) {\n            received.push({\n              txHash: tx.transaction.hash,\n              amount: output.value.toString(),\n              vOut: i,\n              confirmations: txConfirmations\n            });\n          }\n        }\n      }\n\n      return received.filter(utxo => confirmations === 0 || utxo.confirmations >= confirmations).sort(sortUTXOs);\n    });\n\n    this.broadcastTransaction = txHex => __awaiter(this, void 0, void 0, function* () {\n      const url = `${this.endpoint()}/push/transaction`;\n      const response = yield axios.post(url, {\n        data: txHex\n      }, {\n        timeout: DEFAULT_TIMEOUT\n      });\n\n      if (response.data.error) {\n        throw new Error(response.data.error);\n      }\n\n      return response.data.data.transaction_hash;\n    });\n\n    this.network = network;\n  }\n\n}\nexport const Blockchair = Callable(BlockchairClass);","map":{"version":3,"sources":["../../../src/APIs/blockchair.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Callable } from \"@renproject/utils\";\nimport axios from \"axios\";\nimport { sortUTXOs, DEFAULT_TIMEOUT } from \"./API\";\nexport var BlockchairNetwork;\n(function (BlockchairNetwork) {\n    BlockchairNetwork[\"BITCOIN\"] = \"bitcoin\";\n    BlockchairNetwork[\"BITCOIN_CASH\"] = \"bitcoin-cash\";\n    BlockchairNetwork[\"LITECOIN\"] = \"litecoin\";\n    BlockchairNetwork[\"BITCOIN_SV\"] = \"bitcoin-sv\";\n    BlockchairNetwork[\"DOGECOIN\"] = \"dogecoin\";\n    BlockchairNetwork[\"DASH\"] = \"dash\";\n    BlockchairNetwork[\"GROESTLCOIN\"] = \"groestlcoin\";\n    BlockchairNetwork[\"BITCOIN_TESTNET\"] = \"bitcoin/testnet\";\n})(BlockchairNetwork || (BlockchairNetwork = {}));\nexport class BlockchairClass {\n    constructor(network = BlockchairNetwork.BITCOIN) {\n        this.endpoint = () => `https://api.blockchair.com/${this.network}`;\n        this.fetchUTXO = (txHash, vOut) => __awaiter(this, void 0, void 0, function* () {\n            const url = `${this.endpoint()}/dashboards/transaction/${txHash}`;\n            const response = (yield axios.get(`${url}`, {\n                timeout: DEFAULT_TIMEOUT,\n            })).data;\n            if (!response.data[txHash]) {\n                throw new Error(`Transaction not found.`);\n            }\n            const tx = response.data[txHash];\n            let latestBlock = response.context.state;\n            if (latestBlock === 0) {\n                const statsUrl = `${this.endpoint()}/stats`;\n                const statsResponse = (yield axios.get(statsUrl, { timeout: DEFAULT_TIMEOUT })).data;\n                latestBlock = statsResponse.data.blocks - 1;\n            }\n            const confirmations = tx.transaction.block_id === -1\n                ? 0\n                : Math.max(latestBlock - tx.transaction.block_id + 1, 0);\n            return {\n                txHash,\n                vOut,\n                amount: tx.outputs[vOut].value.toString(),\n                confirmations,\n            };\n        });\n        this.fetchUTXOs = (address, confirmations = 0) => __awaiter(this, void 0, void 0, function* () {\n            const url = `${this.endpoint()}/dashboards/address/${address}?limit=0,100`;\n            const response = (yield axios.get(url, { timeout: DEFAULT_TIMEOUT })).data;\n            let latestBlock = response.context.state;\n            if (latestBlock === 0) {\n                const statsUrl = `${this.endpoint()}/stats`;\n                const statsResponse = (yield axios.get(statsUrl, { timeout: DEFAULT_TIMEOUT })).data;\n                latestBlock = statsResponse.data.blocks - 1;\n            }\n            return response.data[address].utxo\n                .map((utxo) => ({\n                txHash: utxo.transaction_hash,\n                amount: utxo.value.toString(),\n                vOut: utxo.index,\n                confirmations: utxo.block_id === -1 ? 0 : latestBlock - utxo.block_id + 1,\n            }))\n                .filter((utxo) => confirmations === 0 || utxo.confirmations >= confirmations)\n                .sort(sortUTXOs);\n        });\n        this.fetchTXs = (address, confirmations = 0, limit = 25) => __awaiter(this, void 0, void 0, function* () {\n            const url = `${this.endpoint()}/dashboards/address/${address}?limit=${limit},0`;\n            const response = (yield axios.get(url, { timeout: DEFAULT_TIMEOUT })).data;\n            let latestBlock = response.context.state;\n            if (latestBlock === 0) {\n                const statsUrl = `${this.endpoint()}/stats`;\n                const statsResponse = (yield axios.get(statsUrl, { timeout: DEFAULT_TIMEOUT })).data;\n                latestBlock = statsResponse.data.blocks - 1;\n            }\n            const txHashes = response.data[address].transactions;\n            let txDetails = {};\n            // Fetch in sets of 10\n            for (let i = 0; i < Math.ceil(txHashes.length / 10); i++) {\n                const txUrl = `${this.endpoint()}/dashboards/transactions/${txHashes\n                    .slice(i * 10, (i + 1) * 10)\n                    .join(\",\")}`;\n                const txResponse = (yield axios.get(txUrl, {\n                    timeout: DEFAULT_TIMEOUT,\n                })).data;\n                txDetails = Object.assign(Object.assign({}, txDetails), txResponse.data);\n            }\n            const received = [];\n            for (const txHash of txHashes) {\n                const tx = txDetails[txHash];\n                const txConfirmations = tx.transaction.block_id === -1\n                    ? 0\n                    : Math.max(latestBlock - tx.transaction.block_id + 1, 0);\n                for (let i = 0; i < tx.outputs.length; i++) {\n                    const output = tx.outputs[i];\n                    if (output.recipient === address) {\n                        received.push({\n                            txHash: tx.transaction.hash,\n                            amount: output.value.toString(),\n                            vOut: i,\n                            confirmations: txConfirmations,\n                        });\n                    }\n                }\n            }\n            return received\n                .filter((utxo) => confirmations === 0 || utxo.confirmations >= confirmations)\n                .sort(sortUTXOs);\n        });\n        this.broadcastTransaction = (txHex) => __awaiter(this, void 0, void 0, function* () {\n            const url = `${this.endpoint()}/push/transaction`;\n            const response = yield axios.post(url, { data: txHex }, { timeout: DEFAULT_TIMEOUT });\n            if (response.data.error) {\n                throw new Error(response.data.error);\n            }\n            return response.data.data.transaction_hash;\n        });\n        this.network = network;\n    }\n}\nexport const Blockchair = Callable(BlockchairClass);\n//# sourceMappingURL=blockchair.js.map"]},"metadata":{},"sourceType":"module"}