{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { SimpleLogger } from \"@renproject/interfaces\";\nimport { Callable, doesntError, keccak256 } from \"@renproject/utils\";\nimport { PublicKey, Transaction, TransactionInstruction, SYSVAR_RENT_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY, SystemProgram, sendAndConfirmRawTransaction } from \"@solana/web3.js\";\nimport { TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\nimport { createAssociatedTokenAccount, getAssociatedTokenAddress } from \"@project-serum/associated-token\";\nimport { BN } from \"bn.js\";\nimport BigNumber from \"bignumber.js\";\nimport base58 from \"bs58\";\nimport { createInstructionWithEthAddress2 } from \"./util\";\nimport { renMainnet, resolveNetwork } from \"./networks\";\nimport { BurnLogLayout, GatewayLayout, GatewayStateKey, GatewayRegistryLayout, GatewayRegistryStateKey, MintLogLayout, RenVmMsgLayout } from \"./layouts\"; // FIXME: Typings are out of date, so lets fall back to good old any\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst ActualToken = Token;\nexport class SolanaClass {\n  constructor(provider, renNetwork, options) {\n    this.chain = Solana.chain;\n    this.name = Solana.chain;\n    this._logger = new SimpleLogger();\n    this.burnPayloadConfig = {\n      bytes: true\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    this.utils = SolanaClass.utils;\n    /**\n     * `initialize` allows RenJS to pass in parameters after the user has\n     * initialized the Chain. This allows the user to pass in network\n     * parameters such as the network only once.\n     *\n     * If the Chain's constructor has an optional network parameter and the\n     * user has explicitly initialized it, the Chain should ignore the\n     * network passed in to `initialize`. This is to allow different network\n     * combinations, such as working with testnet Bitcoin and a local Ethereum\n     * chain - whereas the default `testnet` configuration would use testnet\n     * Bitcoin and Ethereum's Kovan testnet.\n     */\n\n    this.initialize = network => __awaiter(this, void 0, void 0, function* () {\n      this.renNetwork = SolanaClass.utils.resolveChainNetwork(network); // Load registry state to find programs\n\n      const pubk = new PublicKey(this.renNetworkDetails.addresses.GatewayRegistry);\n      const stateKey = yield PublicKey.findProgramAddress([Buffer.from(GatewayRegistryStateKey)], pubk);\n      const gatewayData = yield this.provider.connection.getAccountInfo(stateKey[0]);\n\n      if (!gatewayData) {\n        throw new Error(\"Failed to load program state\");\n      } // Persist registry data\n      // TODO: Consider if we want to handle the edge case of programs being\n      // updated during the lifecyle of the chain pbject\n\n\n      this.gatewayRegistryData = GatewayRegistryLayout.decode(gatewayData.data);\n      return this;\n    }); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    this.withProvider = provider => {\n      this.provider = provider;\n      return this;\n    };\n\n    this.assetIsNative = asset => {\n      return asset === \"SOL\";\n    };\n    /**\n     * `assetIsSupported` should return true if the the asset is native to the\n     * chain or if the asset can be minted onto the chain.\n     *\n     * ```ts\n     * ethereum.assetIsSupported = asset => asset === \"ETH\" || asset === \"BTC\" || ...;\n     * ```\n     */\n\n\n    this.assetIsSupported = asset => __awaiter(this, void 0, void 0, function* () {\n      yield this.waitForInitialization();\n\n      if (this.assetIsNative(asset)) {\n        return true;\n      }\n\n      const sHash = Uint8Array.from(keccak256(Buffer.from(`${asset}/toSolana`)));\n\n      if (this.gatewayRegistryData && this.gatewayRegistryData.selectors.find(x => x.toString() === sHash.toString())) {\n        return true;\n      }\n\n      return false;\n    });\n\n    this.assetDecimals = asset => __awaiter(this, void 0, void 0, function* () {\n      yield this.waitForInitialization();\n      const address = yield this.getSPLTokenPubkey(asset);\n      const res = yield this.provider.connection.getTokenSupply(new PublicKey(address));\n      return res.value.decimals;\n    });\n\n    this.transactionID = transaction => {\n      this._logger.debug(\"tx\", transaction); // TODO: use the transaction signature for both?\n\n\n      return transaction;\n    };\n\n    this.transactionConfidence = transaction => __awaiter(this, void 0, void 0, function* () {\n      yield this.waitForInitialization(); // NOTE: Solana has a built in submit and wait until target confirmations\n      // function; so it might not make sense to use this?\n\n      const tx = yield this.provider.connection.getConfirmedTransaction(transaction);\n      const currentSlot = yield this.provider.connection.getSlot();\n      return {\n        current: currentSlot - (tx && tx.slot ? tx.slot : 0),\n        target: this.renNetworkDetails.isTestnet ? 1 : 2\n      };\n    });\n\n    this.transactionRPCFormat = transaction => {\n      this._logger.debug(\"tx\", transaction);\n\n      return {\n        txid: base58.decode(transaction),\n        txindex: \"0\"\n      };\n    };\n\n    this.transactionRPCTxidFromID = transactionID => base58.decode(transactionID);\n\n    this.transactionIDFromRPCFormat = (txid, txindex) => this.transactionID(this.transactionFromRPCFormat(txid, txindex));\n\n    this.transactionFromRPCFormat = (txid, _txindex, _reversed) => {\n      if (typeof txid == \"string\") return txid;\n      return base58.encode(txid);\n    };\n    /**\n     * @deprecated Renamed to `transactionFromRPCFormat`.\n     * Will be removed in 3.0.0.\n     */\n\n\n    this.transactionFromID = this.transactionFromRPCFormat;\n\n    this.resolveTokenGatewayContract = asset => {\n      if (!this.gatewayRegistryData) {\n        throw new Error(\"chain not initialized\");\n      }\n\n      const sHash = Uint8Array.from(keccak256(Buffer.from(`${asset}/toSolana`)));\n      let idx = -1;\n      const contract = this.gatewayRegistryData && this.gatewayRegistryData.selectors.find((x, i) => x.toString() === sHash.toString() && (() => {\n        idx = i;\n        return true;\n      })());\n      if (!contract) throw new Error(\"unsupported asset\");\n      return this.gatewayRegistryData.gateways[idx].toBase58();\n    };\n\n    this.constructRenVMMsg = (p_hash, amount, token, to, n_hash) => {\n      try {\n        const renvmmsg = Buffer.from(new Array(160));\n        const preencode = {\n          p_hash: new Uint8Array(p_hash),\n          amount: new Uint8Array(new BN(amount.toString()).toArray(\"be\", 32)),\n          token: new Uint8Array(token),\n          to: new Uint8Array(base58.decode(to)),\n          n_hash: new Uint8Array(n_hash)\n        };\n\n        this._logger.debug(\"renvmmsg preencode\", JSON.stringify({\n          s_hash: token,\n          p_hash,\n          to: base58.decode(to),\n          n_hash,\n          amount: new Uint8Array(new BN(amount.toString()).toArray(\"be\", 32))\n        }));\n\n        const renvmMsgSlice = Buffer.from([...preencode.p_hash, ...preencode.amount, ...preencode.token, ...preencode.to, ...preencode.n_hash]);\n        RenVmMsgLayout.encode(preencode, renvmmsg);\n\n        this._logger.debug(\"renvmmsg encoded\", renvmmsg);\n\n        return [renvmmsg, renvmMsgSlice];\n      } catch (e) {\n        this._logger.debug(\"failed to encoded renvmmsg\", e);\n\n        throw e;\n      }\n    };\n    /**\n     * `submitMint` should take the completed mint transaction from RenVM and\n     * submit its signature to the mint chain to finalize the mint.\n     */\n\n\n    this.submitMint = (asset, contractCalls, mintTx, eventEmitter) => __awaiter(this, void 0, void 0, function* () {\n      yield this.waitForInitialization();\n\n      this._logger.debug(\"submitting mintTx:\", mintTx);\n\n      if (mintTx.out && mintTx.out.revert) throw new Error(`Transaction reverted: ${mintTx.out.revert.toString()}`);\n      if (!mintTx.out || !mintTx.out.signature) throw new Error(\"Missing signature\");\n      let sig = mintTx.out.signature; // FIXME: Not sure why this happens when retrieving the tx by polling for submission result\n\n      if (typeof sig === \"string\") {\n        sig = Buffer.from(sig, \"hex\");\n      }\n\n      const program = new PublicKey(this.resolveTokenGatewayContract(asset));\n      const gatewayAccountId = yield PublicKey.findProgramAddress([new Uint8Array(Buffer.from(GatewayStateKey))], program);\n      const s_hash = keccak256(Buffer.from(`${asset}/toSolana`));\n      const tokenMintId = yield this.getSPLTokenPubkey(asset);\n      const isSigner = false;\n      const isWritable = false;\n      const mintAuthorityId = yield PublicKey.findProgramAddress([tokenMintId.toBuffer()], program);\n      const [renvmmsg, renvmMsgSlice] = this.constructRenVMMsg(Buffer.from(mintTx.out.phash.toString(\"hex\"), \"hex\"), mintTx.out.amount.toString(), Buffer.from(s_hash.toString(\"hex\"), \"hex\"), contractCalls[0].sendTo, Buffer.from(mintTx.out.nhash.toString(\"hex\"), \"hex\"));\n      const mintLogAccountId = yield PublicKey.findProgramAddress([keccak256(renvmmsg)], program);\n\n      this._logger.debug(\"mint log account\", mintLogAccountId[0].toString());\n\n      const recipient = new PublicKey(contractCalls[0].sendTo);\n      const recipientAccount = yield this.provider.connection.getAccountInfo(recipient);\n\n      if (!recipientAccount) {\n        throw new Error(\"Recipient account not found\");\n      }\n\n      const instruction = new TransactionInstruction({\n        keys: [{\n          pubkey: this.provider.wallet.publicKey,\n          isSigner: true,\n          isWritable\n        }, {\n          pubkey: gatewayAccountId[0],\n          isSigner,\n          isWritable\n        }, {\n          pubkey: tokenMintId,\n          isSigner,\n          isWritable: true\n        }, {\n          pubkey: recipient,\n          isSigner,\n          isWritable: true\n        }, {\n          pubkey: mintLogAccountId[0],\n          isSigner,\n          isWritable: true\n        }, {\n          pubkey: mintAuthorityId[0],\n          isSigner,\n          isWritable\n        }, {\n          pubkey: SystemProgram.programId,\n          isSigner,\n          isWritable\n        }, {\n          pubkey: SYSVAR_INSTRUCTIONS_PUBKEY,\n          isSigner,\n          isWritable\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner,\n          isWritable\n        }, {\n          pubkey: TOKEN_PROGRAM_ID,\n          isSigner,\n          isWritable\n        }],\n        programId: program,\n        data: Buffer.from([1])\n      });\n\n      this._logger.debug(\"mint instruction\", JSON.stringify(instruction));\n\n      const gatewayInfo = yield this.provider.connection.getAccountInfo(gatewayAccountId[0]);\n      if (!gatewayInfo) throw new Error(\"incorrect gateway program address\");\n      const gatewayState = GatewayLayout.decode(gatewayInfo.data);\n      const tx = new Transaction();\n      const secpParams = {\n        ethAddress: Buffer.from(gatewayState.renvm_authority),\n        message: renvmMsgSlice,\n        signature: sig.slice(0, 64),\n        recoveryId: sig[64] - 27\n      };\n\n      this._logger.debug(\"authority address\", secpParams.ethAddress.toString(\"hex\"));\n\n      this._logger.debug(\"secp params\", secpParams);\n\n      const secPInstruction = createInstructionWithEthAddress2(secpParams);\n      secPInstruction.data = Buffer.from([...secPInstruction.data]);\n      tx.add(instruction, secPInstruction);\n      tx.recentBlockhash = (yield this.provider.connection.getRecentBlockhash(\"max\")).blockhash;\n      tx.feePayer = this.provider.wallet.publicKey;\n      const simulationResult = yield this.provider.connection.simulateTransaction(tx);\n\n      if (simulationResult.value.err) {\n        throw new Error(\"transaction simulation failed: \" + JSON.stringify(simulationResult));\n      }\n\n      const signed = yield this.provider.wallet.signTransaction(tx);\n      const signature = signed.signature;\n      if (!signature) throw new Error(\"failed to sign\"); // FIXME: we need to generalize these events\n\n      eventEmitter.emit(\"transactionHash\", base58.encode(signature));\n\n      this._logger.debug(\"signed with signature\", signature);\n\n      const confirmOpts = {\n        commitment: \"finalized\"\n      };\n      const r = yield sendAndConfirmRawTransaction(this.provider.connection, signed.serialize(), confirmOpts);\n\n      this._logger.debug(\"sent and confirmed\", r);\n\n      eventEmitter.emit(\"confirmation\", {}, {\n        status: true\n      });\n      return r;\n    });\n\n    this.findTransactionByDepositDetails = (asset, sHash, nHash, pHash, to, amount) => __awaiter(this, void 0, void 0, function* () {\n      yield this.waitForInitialization();\n      const program = new PublicKey(this.resolveTokenGatewayContract(asset));\n      const [renvmmsg] = this.constructRenVMMsg(pHash, amount, sHash, to, nHash);\n      const mintLogAccountId = yield PublicKey.findProgramAddress([keccak256(renvmmsg)], program);\n      const mintData = yield this.provider.connection.getAccountInfo(mintLogAccountId[0]);\n\n      if (!mintData) {\n        this._logger.debug(\"no mint for mint:\", mintLogAccountId[0].toString());\n\n        return undefined;\n      }\n\n      this._logger.debug(\"found mint:\", mintData);\n\n      const mintLogData = MintLogLayout.decode(mintData.data);\n      if (!mintLogData.is_initialized) return undefined;\n\n      try {\n        const mintSigs = yield this.provider.connection.getSignaturesForAddress(mintLogAccountId[0]);\n        return mintSigs[0] && mintSigs[0].signature || \"\";\n      } catch (error) {\n        // If getSignaturesForAddress threw an error, the network may be\n        // on a version before 1.7, so this second method should be tried.\n        // Once all relevant networks have been updated, this can be removed.\n        try {\n          const mintSigs = yield this.provider.connection.getConfirmedSignaturesForAddress2(mintLogAccountId[0]);\n          return mintSigs[0].signature;\n        } catch (errorInner) {\n          // If both threw, throw the error returned from\n          // `getSignaturesForAddress`.\n          throw error;\n        }\n      }\n    });\n    /*\n     * Generates the mint parameters.\n     * NOTE: We need to ensure that the destination address is initialized,\n     * so be sure to call createAssociatedTokenAccount(asset) first\n     */\n\n\n    this.getMintParams = asset => __awaiter(this, void 0, void 0, function* () {\n      yield this.waitForInitialization();\n\n      if (!this.renNetworkDetails || !this.provider) {\n        throw new Error(`Solana must be initialized before calling 'getContractCalls'.`);\n      }\n\n      const contract = this.resolveTokenGatewayContract(asset);\n      const program = new PublicKey(contract); // TODO: check that the gpubkey matches\n\n      const gatewayAccountId = yield PublicKey.findProgramAddress([new Uint8Array(Buffer.from(GatewayStateKey))], program);\n      const gatewayInfo = yield this.provider.connection.getAccountInfo(gatewayAccountId[0]);\n      if (!gatewayInfo) throw new Error(\"incorrect gateway program address\");\n      const s_hash = keccak256(Buffer.from(asset + \"/toSolana\"));\n      const tokenMintId = yield PublicKey.findProgramAddress([s_hash], program);\n      const destination = yield getAssociatedTokenAddress(this.provider.wallet.publicKey, tokenMintId[0]);\n      const calls = {\n        contractCalls: [{\n          sendTo: destination.toString(),\n          contractFn: \"mint\",\n          contractParams: []\n        }]\n      };\n      return calls;\n    });\n\n    this.getBurnParams = (_asset, burnPayload) => {\n      if (!this._getParams || !burnPayload) return undefined;\n      return this._getParams(burnPayload);\n    };\n    /**\n     * Read a burn reference from an Ethereum transaction - or submit a\n     * transaction first if the transaction details have been provided.\n     */\n\n\n    this.findBurnTransaction = (asset, burn, eventEmitter, logger, _networkDelay) => __awaiter(this, void 0, void 0, function* () {\n      yield this.waitForInitialization();\n      const program = new PublicKey(this.resolveTokenGatewayContract(asset));\n\n      if (burn.burnNonce !== undefined) {\n        let leNonce;\n\n        if (typeof burn.burnNonce == \"number\") {\n          leNonce = new BN(burn.burnNonce).toBuffer(\"le\", 8);\n        } else if (typeof burn.burnNonce == \"string\") {\n          leNonce = Buffer.from(burn.burnNonce);\n        } else {\n          leNonce = burn.burnNonce;\n        }\n\n        const burnId = yield PublicKey.findProgramAddress([leNonce], program);\n        const burnInfo = yield this.provider.connection.getAccountInfo(burnId[0]);\n\n        if (burnInfo) {\n          const burnData = BurnLogLayout.decode(burnInfo.data);\n          const txes = yield this.provider.connection.getConfirmedSignaturesForAddress2(burnId[0]); // Concatenate four u64s into a u256 value.\n\n          const burnAmount = new BN(Buffer.concat([new BN(burnData.amount_section_1).toArrayLike(Buffer, \"le\", 8), new BN(burnData.amount_section_2).toArrayLike(Buffer, \"le\", 8), new BN(burnData.amount_section_3).toArrayLike(Buffer, \"le\", 8), new BN(burnData.amount_section_4).toArrayLike(Buffer, \"le\", 8)])); // Convert borsh `Number` to built-in number\n\n          const recipientLength = parseInt(burnData.recipient_len.toString());\n          const burnDetails = {\n            transaction: txes[0].signature,\n            amount: new BigNumber(burnAmount.toString()),\n            to: base58.encode(burnData.recipient.slice(0, recipientLength)),\n            nonce: new BigNumber(new BN(leNonce, undefined, \"le\").toString())\n          };\n          return burnDetails;\n        } else {\n          this._logger.info(\"missing burn:\", burn.burnNonce);\n\n          logger.info(\"missing burn:\", burn.burnNonce);\n        }\n      } // We didn't find a burn, so create one instead\n\n\n      if (!burn.contractCalls || !burn.contractCalls[0] || !burn.contractCalls[0].contractParams) throw new Error(\"missing burn calls\");\n\n      this._logger.debug(\"burn contract calls:\", burn.contractCalls);\n\n      const amount = burn.contractCalls[0].contractParams[0].value;\n      const recipient = burn.contractCalls[0].contractParams[1].value;\n      const tokenMintId = yield this.getSPLTokenPubkey(asset);\n      const source = yield getAssociatedTokenAddress(this.provider.wallet.publicKey, tokenMintId);\n      const checkedBurnInst = ActualToken.createBurnCheckedInstruction(TOKEN_PROGRAM_ID, tokenMintId, source, this.provider.wallet.publicKey, [], amount, yield this.assetDecimals(asset));\n      const gatewayAccountId = yield PublicKey.findProgramAddress([new Uint8Array(Buffer.from(GatewayStateKey))], program);\n      const gatewayInfo = yield this.provider.connection.getAccountInfo(gatewayAccountId[0]);\n      if (!gatewayInfo) throw new Error(\"incorrect gateway program address\");\n      const gatewayState = GatewayLayout.decode(gatewayInfo.data);\n      const nonceBN = new BN(gatewayState.burn_count).add(new BN(1));\n\n      this._logger.debug(\"burn nonce: \", nonceBN.toString());\n\n      const burnLogAccountId = yield PublicKey.findProgramAddress([Buffer.from(nonceBN.toArray(\"le\", 8))], program); // sensible defaults\n\n      const isSigner = false;\n      const isWritable = false;\n      const renBurnInst = new TransactionInstruction({\n        keys: [{\n          isSigner: true,\n          isWritable,\n          pubkey: this.provider.wallet.publicKey\n        }, {\n          isSigner,\n          isWritable: true,\n          pubkey: source\n        }, {\n          isSigner,\n          isWritable: true,\n          pubkey: gatewayAccountId[0]\n        }, {\n          isSigner,\n          isWritable: true,\n          pubkey: tokenMintId\n        }, {\n          isSigner,\n          isWritable: true,\n          pubkey: burnLogAccountId[0]\n        }, {\n          pubkey: SystemProgram.programId,\n          isSigner,\n          isWritable\n        }, {\n          pubkey: SYSVAR_INSTRUCTIONS_PUBKEY,\n          isSigner,\n          isWritable\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner,\n          isWritable\n        }],\n        data: Buffer.from([2, recipient.length, ...recipient]),\n        programId: program\n      });\n\n      this._logger.debug(\"burn tx: \", renBurnInst);\n\n      const tx = new Transaction();\n      tx.add(checkedBurnInst, renBurnInst);\n      tx.recentBlockhash = (yield this.provider.connection.getRecentBlockhash()).blockhash;\n      tx.feePayer = this.provider.wallet.publicKey;\n      const signed = yield this.provider.wallet.signTransaction(tx);\n\n      if (!signed.signature) {\n        throw new Error(\"missing signature\");\n      }\n\n      const confirmOpts = {\n        commitment: \"finalized\"\n      };\n      const res = yield sendAndConfirmRawTransaction(this.provider.connection, signed.serialize(), confirmOpts); // We unfortunatley cannot send the hash before the program has the tx.\n      // burnAndRelease status assumes it is burned as soon as hash is available,\n      // and submits the tx at that point; but the lightnode/darknode will fail to validate\n      // because it is not present in the cluster yet\n      // FIXME: this is not great, because it will be stuck in state where it is expecting a signature\n\n      eventEmitter.emit(\"txHash\", base58.encode(signed.signature));\n      eventEmitter.emit(\"confirmation\", base58.encode(signed.signature));\n      const x = {\n        transaction: res,\n        amount: new BigNumber(amount),\n        to: base58.encode(recipient),\n        nonce: new BigNumber(nonceBN.toString())\n      };\n      return x;\n    });\n\n    this.provider = provider;\n\n    if (!this.provider.connection) {\n      throw new Error(\"No connection to provider\");\n    }\n\n    this.initialize = this.initialize.bind(this);\n    this.waitForInitialization = this.waitForInitialization.bind(this); // Default to mainnet if not specified\n\n    if (renNetwork) {\n      this.renNetworkDetails = resolveNetwork(renNetwork);\n    } else {\n      this.renNetworkDetails = renMainnet;\n    }\n\n    if (options) {\n      this._logger = options.logger;\n    }\n\n    this.initialize(this.renNetworkDetails.name).catch(console.error);\n  }\n\n  waitForInitialization() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._initialized === undefined) {\n        this._initialized = this.initialize(this.renNetworkDetails.name).then(() => true);\n      }\n\n      return this._initialized;\n    });\n  }\n\n  getSPLTokenPubkey(asset) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.waitForInitialization();\n      const program = new PublicKey(this.resolveTokenGatewayContract(asset));\n      const s_hash = keccak256(Buffer.from(`${asset}/toSolana`));\n      const tokenMintId = yield PublicKey.findProgramAddress([s_hash], program);\n      return tokenMintId[0];\n    });\n  }\n  /**\n   * Fetch the mint and burn fees for an asset.\n   */\n\n\n  getFees(_asset) {\n    // TODO: add getFees RPC endpoint; use RPC to provide fees\n    return {\n      burn: 15,\n      mint: 15\n    };\n  }\n  /**\n   * Fetch the addresses' balance of the asset's representation on the chain.\n   */\n\n\n  getBalance(asset, address) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const tokenMintId = yield this.getSPLTokenPubkey(asset);\n      const source = yield getAssociatedTokenAddress(new PublicKey(address), tokenMintId);\n      return new BigNumber((yield this.provider.connection.getTokenAccountBalance(source)).value.amount);\n    });\n  }\n\n  Account({\n    amount\n  }) {\n    this._getParams = burnPayload => {\n      const recipientBytes = Buffer.from(burnPayload, \"hex\");\n      const params = {\n        contractCalls: [{\n          sendTo: burnPayload,\n          contractFn: \"\",\n          contractParams: [{\n            name: \"amount\",\n            value: amount,\n            type: \"string\"\n          }, {\n            name: \"recipient\",\n            value: recipientBytes,\n            type: \"bytes\"\n          }]\n        }]\n      };\n\n      this._logger.debug(\"burn params:\", params);\n\n      return params;\n    };\n\n    return this;\n  }\n  /*\n   * Solana specific utility for checking whether a token account has been\n   * instantiated for the selected asset\n   */\n\n\n  getAssociatedTokenAccount(asset) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.waitForInitialization();\n      const tokenMintId = yield this.getSPLTokenPubkey(asset);\n      const destination = yield getAssociatedTokenAddress(this.provider.wallet.publicKey, tokenMintId);\n      const tokenAccount = yield this.provider.connection.getAccountInfo(destination);\n\n      if (!tokenAccount || !tokenAccount.data) {\n        return false;\n      }\n\n      return destination;\n    });\n  }\n  /*\n   * Solana specific utility for creating a token account for a given user\n   */\n\n\n  createAssociatedTokenAccount(asset) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.waitForInitialization();\n      const tokenMintId = yield this.getSPLTokenPubkey(asset);\n      const existingTokenAccount = yield this.getAssociatedTokenAccount(asset);\n\n      if (!existingTokenAccount) {\n        const createTxInstruction = yield createAssociatedTokenAccount(this.provider.wallet.publicKey, this.provider.wallet.publicKey, tokenMintId);\n        const createTx = new Transaction();\n        createTx.add(createTxInstruction);\n        createTx.feePayer = this.provider.wallet.publicKey;\n        createTx.recentBlockhash = (yield this.provider.connection.getRecentBlockhash()).blockhash;\n        const signedTx = yield this.provider.wallet.signTransaction(createTx); // Only wait until solana has seen the tx\n\n        const confirmOpts = {\n          commitment: \"confirmed\"\n        };\n        return sendAndConfirmRawTransaction(this.provider.connection, signedTx.serialize(), confirmOpts);\n      } else {\n        // Already generated, but we aren't guarenteed to get the tx\n        return \"\";\n      }\n    });\n  }\n\n}\nSolanaClass.chain = \"Solana\";\nSolanaClass.utils = {\n  resolveChainNetwork: resolveNetwork,\n\n  /**\n   * A Solana address is a base58-encoded 32-byte ed25519 public key.\n   */\n  addressIsValid: doesntError(address => base58.decode(address).length === 32),\n\n  /**\n   * A Solana transaction's ID is a base58-encoded 64-byte signature.\n   */\n  transactionIsValid: doesntError(transaction => base58.decode(transaction).length === 64),\n  addressExplorerLink: (address, network) => {\n    const resolvedNetwork = SolanaClass.utils.resolveChainNetwork(network) || renMainnet;\n    return `${resolvedNetwork.chainExplorer}/address/${address}?cluster=${resolvedNetwork.chain}`;\n  },\n  transactionExplorerLink: (transaction, network = renMainnet) => {\n    const resolvedNetwork = SolanaClass.utils.resolveChainNetwork(network) || renMainnet;\n    return `${resolvedNetwork.chainExplorer}/tx/${transaction}?cluster=${resolvedNetwork.chain}`;\n  }\n}; // @dev Removes any static fields, except `utils`.\n\nexport const Solana = Callable(SolanaClass);","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SimpleLogger, } from \"@renproject/interfaces\";\nimport { Callable, doesntError, keccak256 } from \"@renproject/utils\";\nimport { PublicKey, Transaction, TransactionInstruction, SYSVAR_RENT_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY, SystemProgram, sendAndConfirmRawTransaction, } from \"@solana/web3.js\";\nimport { TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\nimport { createAssociatedTokenAccount, getAssociatedTokenAddress, } from \"@project-serum/associated-token\";\nimport { BN } from \"bn.js\";\nimport BigNumber from \"bignumber.js\";\nimport base58 from \"bs58\";\nimport { createInstructionWithEthAddress2 } from \"./util\";\nimport { renMainnet, resolveNetwork } from \"./networks\";\nimport { BurnLogLayout, GatewayLayout, GatewayStateKey, GatewayRegistryLayout, GatewayRegistryStateKey, MintLogLayout, RenVmMsgLayout, } from \"./layouts\";\n// FIXME: Typings are out of date, so lets fall back to good old any\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst ActualToken = Token;\nexport class SolanaClass {\n    constructor(provider, renNetwork, options) {\n        this.chain = Solana.chain;\n        this.name = Solana.chain;\n        this._logger = new SimpleLogger();\n        this.burnPayloadConfig = {\n            bytes: true,\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.utils = SolanaClass.utils;\n        /**\n         * `initialize` allows RenJS to pass in parameters after the user has\n         * initialized the Chain. This allows the user to pass in network\n         * parameters such as the network only once.\n         *\n         * If the Chain's constructor has an optional network parameter and the\n         * user has explicitly initialized it, the Chain should ignore the\n         * network passed in to `initialize`. This is to allow different network\n         * combinations, such as working with testnet Bitcoin and a local Ethereum\n         * chain - whereas the default `testnet` configuration would use testnet\n         * Bitcoin and Ethereum's Kovan testnet.\n         */\n        this.initialize = (network) => __awaiter(this, void 0, void 0, function* () {\n            this.renNetwork = SolanaClass.utils.resolveChainNetwork(network);\n            // Load registry state to find programs\n            const pubk = new PublicKey(this.renNetworkDetails.addresses.GatewayRegistry);\n            const stateKey = yield PublicKey.findProgramAddress([Buffer.from(GatewayRegistryStateKey)], pubk);\n            const gatewayData = yield this.provider.connection.getAccountInfo(stateKey[0]);\n            if (!gatewayData) {\n                throw new Error(\"Failed to load program state\");\n            }\n            // Persist registry data\n            // TODO: Consider if we want to handle the edge case of programs being\n            // updated during the lifecyle of the chain pbject\n            this.gatewayRegistryData = GatewayRegistryLayout.decode(gatewayData.data);\n            return this;\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.withProvider = (provider) => {\n            this.provider = provider;\n            return this;\n        };\n        this.assetIsNative = (asset) => {\n            return asset === \"SOL\";\n        };\n        /**\n         * `assetIsSupported` should return true if the the asset is native to the\n         * chain or if the asset can be minted onto the chain.\n         *\n         * ```ts\n         * ethereum.assetIsSupported = asset => asset === \"ETH\" || asset === \"BTC\" || ...;\n         * ```\n         */\n        this.assetIsSupported = (asset) => __awaiter(this, void 0, void 0, function* () {\n            yield this.waitForInitialization();\n            if (this.assetIsNative(asset)) {\n                return true;\n            }\n            const sHash = Uint8Array.from(keccak256(Buffer.from(`${asset}/toSolana`)));\n            if (this.gatewayRegistryData &&\n                this.gatewayRegistryData.selectors.find((x) => x.toString() === sHash.toString())) {\n                return true;\n            }\n            return false;\n        });\n        this.assetDecimals = (asset) => __awaiter(this, void 0, void 0, function* () {\n            yield this.waitForInitialization();\n            const address = yield this.getSPLTokenPubkey(asset);\n            const res = yield this.provider.connection.getTokenSupply(new PublicKey(address));\n            return res.value.decimals;\n        });\n        this.transactionID = (transaction) => {\n            this._logger.debug(\"tx\", transaction);\n            // TODO: use the transaction signature for both?\n            return transaction;\n        };\n        this.transactionConfidence = (transaction) => __awaiter(this, void 0, void 0, function* () {\n            yield this.waitForInitialization();\n            // NOTE: Solana has a built in submit and wait until target confirmations\n            // function; so it might not make sense to use this?\n            const tx = yield this.provider.connection.getConfirmedTransaction(transaction);\n            const currentSlot = yield this.provider.connection.getSlot();\n            return {\n                current: currentSlot - (tx && tx.slot ? tx.slot : 0),\n                target: this.renNetworkDetails.isTestnet ? 1 : 2,\n            };\n        });\n        this.transactionRPCFormat = (transaction) => {\n            this._logger.debug(\"tx\", transaction);\n            return {\n                txid: base58.decode(transaction),\n                txindex: \"0\",\n            };\n        };\n        this.transactionRPCTxidFromID = (transactionID) => base58.decode(transactionID);\n        this.transactionIDFromRPCFormat = (txid, txindex) => this.transactionID(this.transactionFromRPCFormat(txid, txindex));\n        this.transactionFromRPCFormat = (txid, _txindex, _reversed) => {\n            if (typeof txid == \"string\")\n                return txid;\n            return base58.encode(txid);\n        };\n        /**\n         * @deprecated Renamed to `transactionFromRPCFormat`.\n         * Will be removed in 3.0.0.\n         */\n        this.transactionFromID = this.transactionFromRPCFormat;\n        this.resolveTokenGatewayContract = (asset) => {\n            if (!this.gatewayRegistryData) {\n                throw new Error(\"chain not initialized\");\n            }\n            const sHash = Uint8Array.from(keccak256(Buffer.from(`${asset}/toSolana`)));\n            let idx = -1;\n            const contract = this.gatewayRegistryData &&\n                this.gatewayRegistryData.selectors.find((x, i) => x.toString() === sHash.toString() &&\n                    (() => {\n                        idx = i;\n                        return true;\n                    })());\n            if (!contract)\n                throw new Error(\"unsupported asset\");\n            return this.gatewayRegistryData.gateways[idx].toBase58();\n        };\n        this.constructRenVMMsg = (p_hash, amount, token, to, n_hash) => {\n            try {\n                const renvmmsg = Buffer.from(new Array(160));\n                const preencode = {\n                    p_hash: new Uint8Array(p_hash),\n                    amount: new Uint8Array(new BN(amount.toString()).toArray(\"be\", 32)),\n                    token: new Uint8Array(token),\n                    to: new Uint8Array(base58.decode(to)),\n                    n_hash: new Uint8Array(n_hash),\n                };\n                this._logger.debug(\"renvmmsg preencode\", JSON.stringify({\n                    s_hash: token,\n                    p_hash,\n                    to: base58.decode(to),\n                    n_hash,\n                    amount: new Uint8Array(new BN(amount.toString()).toArray(\"be\", 32)),\n                }));\n                const renvmMsgSlice = Buffer.from([\n                    ...preencode.p_hash,\n                    ...preencode.amount,\n                    ...preencode.token,\n                    ...preencode.to,\n                    ...preencode.n_hash,\n                ]);\n                RenVmMsgLayout.encode(preencode, renvmmsg);\n                this._logger.debug(\"renvmmsg encoded\", renvmmsg);\n                return [renvmmsg, renvmMsgSlice];\n            }\n            catch (e) {\n                this._logger.debug(\"failed to encoded renvmmsg\", e);\n                throw e;\n            }\n        };\n        /**\n         * `submitMint` should take the completed mint transaction from RenVM and\n         * submit its signature to the mint chain to finalize the mint.\n         */\n        this.submitMint = (asset, contractCalls, mintTx, eventEmitter) => __awaiter(this, void 0, void 0, function* () {\n            yield this.waitForInitialization();\n            this._logger.debug(\"submitting mintTx:\", mintTx);\n            if (mintTx.out && mintTx.out.revert)\n                throw new Error(`Transaction reverted: ${mintTx.out.revert.toString()}`);\n            if (!mintTx.out || !mintTx.out.signature)\n                throw new Error(\"Missing signature\");\n            let sig = mintTx.out.signature;\n            // FIXME: Not sure why this happens when retrieving the tx by polling for submission result\n            if (typeof sig === \"string\") {\n                sig = Buffer.from(sig, \"hex\");\n            }\n            const program = new PublicKey(this.resolveTokenGatewayContract(asset));\n            const gatewayAccountId = yield PublicKey.findProgramAddress([new Uint8Array(Buffer.from(GatewayStateKey))], program);\n            const s_hash = keccak256(Buffer.from(`${asset}/toSolana`));\n            const tokenMintId = yield this.getSPLTokenPubkey(asset);\n            const isSigner = false;\n            const isWritable = false;\n            const mintAuthorityId = yield PublicKey.findProgramAddress([tokenMintId.toBuffer()], program);\n            const [renvmmsg, renvmMsgSlice] = this.constructRenVMMsg(Buffer.from(mintTx.out.phash.toString(\"hex\"), \"hex\"), mintTx.out.amount.toString(), Buffer.from(s_hash.toString(\"hex\"), \"hex\"), contractCalls[0].sendTo, Buffer.from(mintTx.out.nhash.toString(\"hex\"), \"hex\"));\n            const mintLogAccountId = yield PublicKey.findProgramAddress([keccak256(renvmmsg)], program);\n            this._logger.debug(\"mint log account\", mintLogAccountId[0].toString());\n            const recipient = new PublicKey(contractCalls[0].sendTo);\n            const recipientAccount = yield this.provider.connection.getAccountInfo(recipient);\n            if (!recipientAccount) {\n                throw new Error(\"Recipient account not found\");\n            }\n            const instruction = new TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: this.provider.wallet.publicKey,\n                        isSigner: true,\n                        isWritable,\n                    },\n                    { pubkey: gatewayAccountId[0], isSigner, isWritable },\n                    { pubkey: tokenMintId, isSigner, isWritable: true },\n                    {\n                        pubkey: recipient,\n                        isSigner,\n                        isWritable: true,\n                    },\n                    {\n                        pubkey: mintLogAccountId[0],\n                        isSigner,\n                        isWritable: true,\n                    },\n                    {\n                        pubkey: mintAuthorityId[0],\n                        isSigner,\n                        isWritable,\n                    },\n                    {\n                        pubkey: SystemProgram.programId,\n                        isSigner,\n                        isWritable,\n                    },\n                    {\n                        pubkey: SYSVAR_INSTRUCTIONS_PUBKEY,\n                        isSigner,\n                        isWritable,\n                    },\n                    {\n                        pubkey: SYSVAR_RENT_PUBKEY,\n                        isSigner,\n                        isWritable,\n                    },\n                    {\n                        pubkey: TOKEN_PROGRAM_ID,\n                        isSigner,\n                        isWritable,\n                    },\n                ],\n                programId: program,\n                data: Buffer.from([1]),\n            });\n            this._logger.debug(\"mint instruction\", JSON.stringify(instruction));\n            const gatewayInfo = yield this.provider.connection.getAccountInfo(gatewayAccountId[0]);\n            if (!gatewayInfo)\n                throw new Error(\"incorrect gateway program address\");\n            const gatewayState = GatewayLayout.decode(gatewayInfo.data);\n            const tx = new Transaction();\n            const secpParams = {\n                ethAddress: Buffer.from(gatewayState.renvm_authority),\n                message: renvmMsgSlice,\n                signature: sig.slice(0, 64),\n                recoveryId: sig[64] - 27,\n            };\n            this._logger.debug(\"authority address\", secpParams.ethAddress.toString(\"hex\"));\n            this._logger.debug(\"secp params\", secpParams);\n            const secPInstruction = createInstructionWithEthAddress2(secpParams);\n            secPInstruction.data = Buffer.from([...secPInstruction.data]);\n            tx.add(instruction, secPInstruction);\n            tx.recentBlockhash = (yield this.provider.connection.getRecentBlockhash(\"max\")).blockhash;\n            tx.feePayer = this.provider.wallet.publicKey;\n            const simulationResult = yield this.provider.connection.simulateTransaction(tx);\n            if (simulationResult.value.err) {\n                throw new Error(\"transaction simulation failed: \" +\n                    JSON.stringify(simulationResult));\n            }\n            const signed = yield this.provider.wallet.signTransaction(tx);\n            const signature = signed.signature;\n            if (!signature)\n                throw new Error(\"failed to sign\");\n            // FIXME: we need to generalize these events\n            eventEmitter.emit(\"transactionHash\", base58.encode(signature));\n            this._logger.debug(\"signed with signature\", signature);\n            const confirmOpts = {\n                commitment: \"finalized\",\n            };\n            const r = yield sendAndConfirmRawTransaction(this.provider.connection, signed.serialize(), confirmOpts);\n            this._logger.debug(\"sent and confirmed\", r);\n            eventEmitter.emit(\"confirmation\", {}, { status: true });\n            return r;\n        });\n        this.findTransactionByDepositDetails = (asset, sHash, nHash, pHash, to, amount) => __awaiter(this, void 0, void 0, function* () {\n            yield this.waitForInitialization();\n            const program = new PublicKey(this.resolveTokenGatewayContract(asset));\n            const [renvmmsg] = this.constructRenVMMsg(pHash, amount, sHash, to, nHash);\n            const mintLogAccountId = yield PublicKey.findProgramAddress([keccak256(renvmmsg)], program);\n            const mintData = yield this.provider.connection.getAccountInfo(mintLogAccountId[0]);\n            if (!mintData) {\n                this._logger.debug(\"no mint for mint:\", mintLogAccountId[0].toString());\n                return undefined;\n            }\n            this._logger.debug(\"found mint:\", mintData);\n            const mintLogData = MintLogLayout.decode(mintData.data);\n            if (!mintLogData.is_initialized)\n                return undefined;\n            try {\n                const mintSigs = yield this.provider.connection.getSignaturesForAddress(mintLogAccountId[0]);\n                return (mintSigs[0] && mintSigs[0].signature) || \"\";\n            }\n            catch (error) {\n                // If getSignaturesForAddress threw an error, the network may be\n                // on a version before 1.7, so this second method should be tried.\n                // Once all relevant networks have been updated, this can be removed.\n                try {\n                    const mintSigs = yield this.provider.connection.getConfirmedSignaturesForAddress2(mintLogAccountId[0]);\n                    return mintSigs[0].signature;\n                }\n                catch (errorInner) {\n                    // If both threw, throw the error returned from\n                    // `getSignaturesForAddress`.\n                    throw error;\n                }\n            }\n        });\n        /*\n         * Generates the mint parameters.\n         * NOTE: We need to ensure that the destination address is initialized,\n         * so be sure to call createAssociatedTokenAccount(asset) first\n         */\n        this.getMintParams = (asset) => __awaiter(this, void 0, void 0, function* () {\n            yield this.waitForInitialization();\n            if (!this.renNetworkDetails || !this.provider) {\n                throw new Error(`Solana must be initialized before calling 'getContractCalls'.`);\n            }\n            const contract = this.resolveTokenGatewayContract(asset);\n            const program = new PublicKey(contract);\n            // TODO: check that the gpubkey matches\n            const gatewayAccountId = yield PublicKey.findProgramAddress([new Uint8Array(Buffer.from(GatewayStateKey))], program);\n            const gatewayInfo = yield this.provider.connection.getAccountInfo(gatewayAccountId[0]);\n            if (!gatewayInfo)\n                throw new Error(\"incorrect gateway program address\");\n            const s_hash = keccak256(Buffer.from(asset + \"/toSolana\"));\n            const tokenMintId = yield PublicKey.findProgramAddress([s_hash], program);\n            const destination = yield getAssociatedTokenAddress(this.provider.wallet.publicKey, tokenMintId[0]);\n            const calls = {\n                contractCalls: [\n                    {\n                        sendTo: destination.toString(),\n                        contractFn: \"mint\",\n                        contractParams: [],\n                    },\n                ],\n            };\n            return calls;\n        });\n        this.getBurnParams = (_asset, burnPayload) => {\n            if (!this._getParams || !burnPayload)\n                return undefined;\n            return this._getParams(burnPayload);\n        };\n        /**\n         * Read a burn reference from an Ethereum transaction - or submit a\n         * transaction first if the transaction details have been provided.\n         */\n        this.findBurnTransaction = (asset, burn, eventEmitter, logger, _networkDelay) => __awaiter(this, void 0, void 0, function* () {\n            yield this.waitForInitialization();\n            const program = new PublicKey(this.resolveTokenGatewayContract(asset));\n            if (burn.burnNonce !== undefined) {\n                let leNonce;\n                if (typeof burn.burnNonce == \"number\") {\n                    leNonce = new BN(burn.burnNonce).toBuffer(\"le\", 8);\n                }\n                else if (typeof burn.burnNonce == \"string\") {\n                    leNonce = Buffer.from(burn.burnNonce);\n                }\n                else {\n                    leNonce = burn.burnNonce;\n                }\n                const burnId = yield PublicKey.findProgramAddress([leNonce], program);\n                const burnInfo = yield this.provider.connection.getAccountInfo(burnId[0]);\n                if (burnInfo) {\n                    const burnData = BurnLogLayout.decode(burnInfo.data);\n                    const txes = yield this.provider.connection.getConfirmedSignaturesForAddress2(burnId[0]);\n                    // Concatenate four u64s into a u256 value.\n                    const burnAmount = new BN(Buffer.concat([\n                        new BN(burnData.amount_section_1).toArrayLike(Buffer, \"le\", 8),\n                        new BN(burnData.amount_section_2).toArrayLike(Buffer, \"le\", 8),\n                        new BN(burnData.amount_section_3).toArrayLike(Buffer, \"le\", 8),\n                        new BN(burnData.amount_section_4).toArrayLike(Buffer, \"le\", 8),\n                    ]));\n                    // Convert borsh `Number` to built-in number\n                    const recipientLength = parseInt(burnData.recipient_len.toString());\n                    const burnDetails = {\n                        transaction: txes[0].signature,\n                        amount: new BigNumber(burnAmount.toString()),\n                        to: base58.encode(burnData.recipient.slice(0, recipientLength)),\n                        nonce: new BigNumber(new BN(leNonce, undefined, \"le\").toString()),\n                    };\n                    return burnDetails;\n                }\n                else {\n                    this._logger.info(\"missing burn:\", burn.burnNonce);\n                    logger.info(\"missing burn:\", burn.burnNonce);\n                }\n            }\n            // We didn't find a burn, so create one instead\n            if (!burn.contractCalls ||\n                !burn.contractCalls[0] ||\n                !burn.contractCalls[0].contractParams)\n                throw new Error(\"missing burn calls\");\n            this._logger.debug(\"burn contract calls:\", burn.contractCalls);\n            const amount = burn.contractCalls[0].contractParams[0].value;\n            const recipient = burn.contractCalls[0].contractParams[1].value;\n            const tokenMintId = yield this.getSPLTokenPubkey(asset);\n            const source = yield getAssociatedTokenAddress(this.provider.wallet.publicKey, tokenMintId);\n            const checkedBurnInst = ActualToken.createBurnCheckedInstruction(TOKEN_PROGRAM_ID, tokenMintId, source, this.provider.wallet.publicKey, [], amount, yield this.assetDecimals(asset));\n            const gatewayAccountId = yield PublicKey.findProgramAddress([new Uint8Array(Buffer.from(GatewayStateKey))], program);\n            const gatewayInfo = yield this.provider.connection.getAccountInfo(gatewayAccountId[0]);\n            if (!gatewayInfo)\n                throw new Error(\"incorrect gateway program address\");\n            const gatewayState = GatewayLayout.decode(gatewayInfo.data);\n            const nonceBN = new BN(gatewayState.burn_count).add(new BN(1));\n            this._logger.debug(\"burn nonce: \", nonceBN.toString());\n            const burnLogAccountId = yield PublicKey.findProgramAddress([Buffer.from(nonceBN.toArray(\"le\", 8))], program);\n            // sensible defaults\n            const isSigner = false;\n            const isWritable = false;\n            const renBurnInst = new TransactionInstruction({\n                keys: [\n                    {\n                        isSigner: true,\n                        isWritable,\n                        pubkey: this.provider.wallet.publicKey,\n                    },\n                    { isSigner, isWritable: true, pubkey: source },\n                    { isSigner, isWritable: true, pubkey: gatewayAccountId[0] },\n                    { isSigner, isWritable: true, pubkey: tokenMintId },\n                    { isSigner, isWritable: true, pubkey: burnLogAccountId[0] },\n                    {\n                        pubkey: SystemProgram.programId,\n                        isSigner,\n                        isWritable,\n                    },\n                    {\n                        pubkey: SYSVAR_INSTRUCTIONS_PUBKEY,\n                        isSigner,\n                        isWritable,\n                    },\n                    {\n                        pubkey: SYSVAR_RENT_PUBKEY,\n                        isSigner,\n                        isWritable,\n                    },\n                ],\n                data: Buffer.from([2, recipient.length, ...recipient]),\n                programId: program,\n            });\n            this._logger.debug(\"burn tx: \", renBurnInst);\n            const tx = new Transaction();\n            tx.add(checkedBurnInst, renBurnInst);\n            tx.recentBlockhash = (yield this.provider.connection.getRecentBlockhash()).blockhash;\n            tx.feePayer = this.provider.wallet.publicKey;\n            const signed = yield this.provider.wallet.signTransaction(tx);\n            if (!signed.signature) {\n                throw new Error(\"missing signature\");\n            }\n            const confirmOpts = {\n                commitment: \"finalized\",\n            };\n            const res = yield sendAndConfirmRawTransaction(this.provider.connection, signed.serialize(), confirmOpts);\n            // We unfortunatley cannot send the hash before the program has the tx.\n            // burnAndRelease status assumes it is burned as soon as hash is available,\n            // and submits the tx at that point; but the lightnode/darknode will fail to validate\n            // because it is not present in the cluster yet\n            // FIXME: this is not great, because it will be stuck in state where it is expecting a signature\n            eventEmitter.emit(\"txHash\", base58.encode(signed.signature));\n            eventEmitter.emit(\"confirmation\", base58.encode(signed.signature));\n            const x = {\n                transaction: res,\n                amount: new BigNumber(amount),\n                to: base58.encode(recipient),\n                nonce: new BigNumber(nonceBN.toString()),\n            };\n            return x;\n        });\n        this.provider = provider;\n        if (!this.provider.connection) {\n            throw new Error(\"No connection to provider\");\n        }\n        this.initialize = this.initialize.bind(this);\n        this.waitForInitialization = this.waitForInitialization.bind(this);\n        // Default to mainnet if not specified\n        if (renNetwork) {\n            this.renNetworkDetails = resolveNetwork(renNetwork);\n        }\n        else {\n            this.renNetworkDetails = renMainnet;\n        }\n        if (options) {\n            this._logger = options.logger;\n        }\n        this.initialize(this.renNetworkDetails.name).catch(console.error);\n    }\n    waitForInitialization() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._initialized === undefined) {\n                this._initialized = this.initialize(this.renNetworkDetails.name).then(() => true);\n            }\n            return this._initialized;\n        });\n    }\n    getSPLTokenPubkey(asset) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.waitForInitialization();\n            const program = new PublicKey(this.resolveTokenGatewayContract(asset));\n            const s_hash = keccak256(Buffer.from(`${asset}/toSolana`));\n            const tokenMintId = yield PublicKey.findProgramAddress([s_hash], program);\n            return tokenMintId[0];\n        });\n    }\n    /**\n     * Fetch the mint and burn fees for an asset.\n     */\n    getFees(_asset) {\n        // TODO: add getFees RPC endpoint; use RPC to provide fees\n        return { burn: 15, mint: 15 };\n    }\n    /**\n     * Fetch the addresses' balance of the asset's representation on the chain.\n     */\n    getBalance(asset, address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokenMintId = yield this.getSPLTokenPubkey(asset);\n            const source = yield getAssociatedTokenAddress(new PublicKey(address), tokenMintId);\n            return new BigNumber((yield this.provider.connection.getTokenAccountBalance(source)).value.amount);\n        });\n    }\n    Account({ amount }) {\n        this._getParams = (burnPayload) => {\n            const recipientBytes = Buffer.from(burnPayload, \"hex\");\n            const params = {\n                contractCalls: [\n                    {\n                        sendTo: burnPayload,\n                        contractFn: \"\",\n                        contractParams: [\n                            {\n                                name: \"amount\",\n                                value: amount,\n                                type: \"string\",\n                            },\n                            {\n                                name: \"recipient\",\n                                value: recipientBytes,\n                                type: \"bytes\",\n                            },\n                        ],\n                    },\n                ],\n            };\n            this._logger.debug(\"burn params:\", params);\n            return params;\n        };\n        return this;\n    }\n    /*\n     * Solana specific utility for checking whether a token account has been\n     * instantiated for the selected asset\n     */\n    getAssociatedTokenAccount(asset) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.waitForInitialization();\n            const tokenMintId = yield this.getSPLTokenPubkey(asset);\n            const destination = yield getAssociatedTokenAddress(this.provider.wallet.publicKey, tokenMintId);\n            const tokenAccount = yield this.provider.connection.getAccountInfo(destination);\n            if (!tokenAccount || !tokenAccount.data) {\n                return false;\n            }\n            return destination;\n        });\n    }\n    /*\n     * Solana specific utility for creating a token account for a given user\n     */\n    createAssociatedTokenAccount(asset) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.waitForInitialization();\n            const tokenMintId = yield this.getSPLTokenPubkey(asset);\n            const existingTokenAccount = yield this.getAssociatedTokenAccount(asset);\n            if (!existingTokenAccount) {\n                const createTxInstruction = yield createAssociatedTokenAccount(this.provider.wallet.publicKey, this.provider.wallet.publicKey, tokenMintId);\n                const createTx = new Transaction();\n                createTx.add(createTxInstruction);\n                createTx.feePayer = this.provider.wallet.publicKey;\n                createTx.recentBlockhash = (yield this.provider.connection.getRecentBlockhash()).blockhash;\n                const signedTx = yield this.provider.wallet.signTransaction(createTx);\n                // Only wait until solana has seen the tx\n                const confirmOpts = {\n                    commitment: \"confirmed\",\n                };\n                return sendAndConfirmRawTransaction(this.provider.connection, signedTx.serialize(), confirmOpts);\n            }\n            else {\n                // Already generated, but we aren't guarenteed to get the tx\n                return \"\";\n            }\n        });\n    }\n}\nSolanaClass.chain = \"Solana\";\nSolanaClass.utils = {\n    resolveChainNetwork: resolveNetwork,\n    /**\n     * A Solana address is a base58-encoded 32-byte ed25519 public key.\n     */\n    addressIsValid: doesntError((address) => base58.decode(address).length === 32),\n    /**\n     * A Solana transaction's ID is a base58-encoded 64-byte signature.\n     */\n    transactionIsValid: doesntError((transaction) => base58.decode(transaction).length === 64),\n    addressExplorerLink: (address, network) => {\n        const resolvedNetwork = SolanaClass.utils.resolveChainNetwork(network) || renMainnet;\n        return `${resolvedNetwork.chainExplorer}/address/${address}?cluster=${resolvedNetwork.chain}`;\n    },\n    transactionExplorerLink: (transaction, network = renMainnet) => {\n        const resolvedNetwork = SolanaClass.utils.resolveChainNetwork(network) || renMainnet;\n        return `${resolvedNetwork.chainExplorer}/tx/${transaction}?cluster=${resolvedNetwork.chain}`;\n    },\n};\n// @dev Removes any static fields, except `utils`.\nexport const Solana = Callable(SolanaClass);\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}