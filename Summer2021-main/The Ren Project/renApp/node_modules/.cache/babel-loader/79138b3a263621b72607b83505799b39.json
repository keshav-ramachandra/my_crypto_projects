{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as leb from 'leb128';\nimport { blake2b } from 'blakejs';\nimport { base32 as base32Function } from './base32';\nimport * as uint8arrays from 'uint8arrays';\nimport { Protocol } from './protocol';\nimport { Network } from './network';\nexport * from './network';\nexport * from './protocol';\nvar defaultNetwork = Network.MAIN;\nvar base32 = base32Function('abcdefghijklmnopqrstuvwxyz234567'); // PayloadHashLength defines the hash length taken over addresses using the\n// Actor and SECP256K1 protocols.\n\nvar payloadHashLength = 20;\n\nfunction addressHash(ingest) {\n  return blake2b(ingest, null, payloadHashLength);\n}\n\nexport var Address = /*#__PURE__*/function () {\n  function Address(str) {\n    var network = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultNetwork;\n\n    _classCallCheck(this, Address);\n\n    _defineProperty(this, \"str\", void 0);\n\n    _defineProperty(this, \"_protocol\", void 0);\n\n    _defineProperty(this, \"_network\", void 0);\n\n    if (!str || str.length < 1) throw new Error('Missing str in address');\n    this.str = str;\n    this._protocol = this.str[0];\n\n    if (!Protocol[this._protocol]) {\n      throw new Error(\"Invalid protocol \".concat(this._protocol));\n    }\n\n    this._network = network;\n  }\n\n  _createClass(Address, [{\n    key: \"network\",\n    value: function network() {\n      return this._network;\n    }\n  }, {\n    key: \"protocol\",\n    value: function protocol() {\n      return this._protocol;\n    }\n  }, {\n    key: \"payload\",\n    value: function payload() {\n      return this.str.slice(1, this.str.length);\n    }\n    /**\n     * toString returns a string representation of this address. If no \"network\"\n     * parameter was passed to the constructor the address will be prefixed with\n     * the default network prefix \"f\" (mainnet).\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return encode(this._network, this);\n    }\n    /**\n     * equals determines if this address is the \"same\" address as the passed\n     * address. Two addresses are considered equal if they are the same instance\n     * OR if their \"str\" property matches byte for byte.\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(addr) {\n      if (this === addr) {\n        return true;\n      }\n\n      return uint8arrays.equals(this.str, addr.str);\n    }\n  }]);\n\n  return Address;\n}();\nexport function bigintToArray(v) {\n  var tmp = BigInt(v).toString(16);\n  if (tmp.length % 2 === 1) tmp = \"0\".concat(tmp);\n  return uint8arrays.fromString(tmp, 'base16');\n}\nexport function getChecksum(ingest) {\n  return blake2b(ingest, null, 4);\n}\nexport function validateChecksum(ingest, expect) {\n  var digest = getChecksum(ingest);\n  return uint8arrays.compare(digest, expect);\n}\nexport function newAddress(protocol, payload) {\n  var network = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultNetwork;\n  var protocolByte = new Uint8Array([protocol]);\n  return new Address(uint8arrays.concat([protocolByte, payload]), network);\n}\nexport function newIDAddress(id) {\n  var network = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultNetwork;\n  return newAddress(Protocol.ID, leb.unsigned.encode(id), network);\n}\n/**\n * newActorAddress returns an address using the Actor protocol.\n */\n\nexport function newActorAddress(data) {\n  return newAddress(Protocol.ACTOR, addressHash(data));\n}\n/**\n * newSecp256k1Address returns an address using the SECP256K1 protocol.\n */\n\nexport function newSecp256k1Address(pubkey) {\n  return newAddress(Protocol.SECP256K1, addressHash(pubkey));\n}\n/**\n * newBLSAddress returns an address using the BLS protocol.\n */\n\nexport function newBLSAddress(pubkey) {\n  return newAddress(Protocol.BLS, pubkey);\n}\nexport function decode(address) {\n  checkAddressString(address);\n  var network = address.slice(0, 1);\n  /* tslint:disable-next-line:radix */\n\n  var protocol = parseInt(address.slice(1, 2));\n  var raw = address.substring(2, address.length);\n  var protocolByte = new Uint8Array([protocol]);\n\n  if (protocol === Protocol.ID) {\n    return newIDAddress(raw, network);\n  }\n\n  var payloadChecksum = base32.decode(raw);\n  var length = payloadChecksum.length;\n  var payload = payloadChecksum.slice(0, length - 4);\n  var checksum = payloadChecksum.slice(length - 4, length);\n\n  if (validateChecksum(uint8arrays.concat([protocolByte, payload]), checksum)) {\n    throw Error(\"Checksums don't match\");\n  }\n\n  var addressObj = newAddress(protocol, payload, network);\n  if (encode(network, addressObj) !== address) throw Error(\"Did not encode this address properly: \".concat(address));\n  return addressObj;\n}\nexport function encode(network, address) {\n  if (!address || !address.str) throw Error('Invalid address');\n  var payload = address.payload();\n\n  switch (address.protocol()) {\n    case 0:\n      {\n        return network + String(address.protocol()) + leb.unsigned.decode(address.payload());\n      }\n\n    default:\n      {\n        var protocolByte = new Uint8Array([address.protocol()]);\n        var checksum = getChecksum(uint8arrays.concat([protocolByte, payload]));\n        var bytes = uint8arrays.concat([payload, checksum]);\n        return String(network) + String(address.protocol()) + base32.encode(bytes);\n      }\n  }\n}\nexport function newFromString(address) {\n  return decode(address);\n}\nexport function validateAddressString(addressString) {\n  try {\n    checkAddressString(addressString);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\nexport function checkAddressString(address) {\n  if (!address) throw Error('No bytes to validate.');\n  if (address.length < 3) throw Error('Address is too short to validate.');\n\n  if (address[0] !== 'f' && address[0] !== 't') {\n    throw Error('Unknown address network.');\n  }\n  /* tslint:disable-next-line:radix */\n\n\n  var protocol = parseInt(address[1]);\n\n  switch (protocol) {\n    case Protocol.ID:\n      {\n        if (address.length > 22) throw Error('Invalid ID address length.');\n        break;\n      }\n\n    case Protocol.SECP256K1:\n      {\n        if (address.length !== 41) throw Error('Invalid secp256k1 address length.');\n        break;\n      }\n\n    case Protocol.ACTOR:\n      {\n        if (address.length !== 41) throw Error('Invalid Actor address length.');\n        break;\n      }\n\n    case Protocol.BLS:\n      {\n        if (address.length !== 86) throw Error('Invalid BLS address length.');\n        break;\n      }\n\n    default:\n      {\n        throw new Error('Invalid address protocol.');\n      }\n  }\n}\n/**\n * idFromAddress extracts the ID from an ID address.\n */\n\nexport function idFromAddress(address) {\n  if (address.protocol() !== Protocol.ID) throw new Error('Cannot get ID from non ID address'); // An unsigned varint should be less than 2^63 which is < Number.MAX_VALUE.\n  // So this number SHOULD be representable in JS and safe to parseInt.\n  // https://github.com/multiformats/unsigned-varint\n  // TODO: does leb128 enforce the max value?\n\n  return parseInt(leb.unsigned.decode(address.payload()), 10);\n}\nexport default {\n  Address: Address,\n  newAddress: newAddress,\n  newIDAddress: newIDAddress,\n  newActorAddress: newActorAddress,\n  newSecp256k1Address: newSecp256k1Address,\n  newBLSAddress: newBLSAddress,\n  newFromString: newFromString,\n  bigintToArray: bigintToArray,\n  decode: decode,\n  encode: encode,\n  getChecksum: getChecksum,\n  validateChecksum: validateChecksum,\n  validateAddressString: validateAddressString,\n  checkAddressString: checkAddressString,\n  idFromAddress: idFromAddress,\n  Network: Network,\n  Protocol: Protocol\n};","map":{"version":3,"sources":["../src/index.ts"],"names":["base32","defaultNetwork","Network","base32Function","payloadHashLength","blake2b","Address","network","str","Protocol","encode","uint8arrays","addr","tmp","BigInt","digest","getChecksum","protocolByte","newAddress","leb","addressHash","checkAddressString","address","protocol","parseInt","raw","newIDAddress","payloadChecksum","length","payload","checksum","validateChecksum","Error","addressObj","String","bytes","decode","newActorAddress","newSecp256k1Address","newBLSAddress","newFromString","bigintToArray","validateAddressString","idFromAddress"],"mappings":"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","sourcesContent":["import * as leb from 'leb128'\nimport { blake2b } from 'blakejs'\nimport { base32 as base32Function } from './base32'\nimport * as uint8arrays from 'uint8arrays'\nimport { Protocol } from './protocol'\nimport { Network } from './network'\n\nexport * from './network'\nexport * from './protocol'\n\nconst defaultNetwork = Network.MAIN\nconst base32 = base32Function('abcdefghijklmnopqrstuvwxyz234567')\n\n// PayloadHashLength defines the hash length taken over addresses using the\n// Actor and SECP256K1 protocols.\nconst payloadHashLength = 20\n\nfunction addressHash (ingest: Uint8Array): Uint8Array {\n  return blake2b(ingest, null, payloadHashLength)\n}\n\nexport class Address {\n  readonly str: Uint8Array\n  readonly _protocol: Protocol\n  readonly _network: Network\n\n  constructor(str: Uint8Array, network: Network = defaultNetwork) {\n    if (!str || str.length < 1) throw new Error('Missing str in address')\n    this.str = str\n    this._protocol = this.str[0] as Protocol\n    if (!Protocol[this._protocol]) {\n      throw new Error(`Invalid protocol ${this._protocol}`)\n    }\n    this._network = network\n  }\n\n  network(): Network {\n    return this._network\n  }\n\n  protocol(): Protocol {\n    return this._protocol\n  }\n\n  payload(): Uint8Array {\n    return this.str.slice(1, this.str.length)\n  }\n\n  /**\n   * toString returns a string representation of this address. If no \"network\"\n   * parameter was passed to the constructor the address will be prefixed with\n   * the default network prefix \"f\" (mainnet).\n   */\n  toString (): string {\n    return encode(this._network, this)\n  }\n\n  /**\n   * equals determines if this address is the \"same\" address as the passed\n   * address. Two addresses are considered equal if they are the same instance\n   * OR if their \"str\" property matches byte for byte.\n   */\n  equals (addr: Address): boolean {\n    if (this === addr) {\n      return true\n    }\n    return uint8arrays.equals(this.str, addr.str)\n  }\n}\n\nexport function bigintToArray(v: string | BigInt | number): Uint8Array {\n  let tmp = BigInt(v).toString(16)\n  if (tmp.length % 2 === 1) tmp = `0${tmp}`\n  return uint8arrays.fromString(tmp, 'base16')\n}\n\nexport function getChecksum(ingest: string | Uint8Array): Uint8Array {\n  return blake2b(ingest, null, 4)\n}\n\nexport function validateChecksum(\n  ingest: string | Uint8Array,\n  expect: Uint8Array\n) {\n  const digest = getChecksum(ingest)\n  return uint8arrays.compare(digest, expect)\n}\n\nexport function newAddress(protocol: Protocol, payload: Uint8Array, network: Network = defaultNetwork): Address {\n  const protocolByte = new Uint8Array([protocol])\n  return new Address(uint8arrays.concat([protocolByte, payload]), network)\n}\n\nexport function newIDAddress(id: number|string, network: Network = defaultNetwork): Address {\n  return newAddress(Protocol.ID, leb.unsigned.encode(id), network)\n}\n\n/**\n * newActorAddress returns an address using the Actor protocol.\n */\nexport function newActorAddress (data: Uint8Array): Address {\n  return newAddress(Protocol.ACTOR, addressHash(data))\n}\n\n/**\n * newSecp256k1Address returns an address using the SECP256K1 protocol.\n */\nexport function newSecp256k1Address (pubkey: Uint8Array): Address {\n  return newAddress(Protocol.SECP256K1, addressHash(pubkey))\n}\n\n/**\n * newBLSAddress returns an address using the BLS protocol.\n */\nexport function newBLSAddress (pubkey: Uint8Array): Address {\n  return newAddress(Protocol.BLS, pubkey)\n}\n\nexport function decode(address: string): Address {\n  checkAddressString(address)\n\n  const network = address.slice(0, 1) as Network\n  /* tslint:disable-next-line:radix */\n  const protocol = parseInt(address.slice(1, 2)) as Protocol\n  const raw = address.substring(2, address.length)\n  const protocolByte = new Uint8Array([protocol])\n\n  if (protocol === Protocol.ID) {\n    return newIDAddress(raw, network)\n  }\n\n  const payloadChecksum = base32.decode(raw)\n  const length = payloadChecksum.length\n  const payload = payloadChecksum.slice(0, length - 4)\n  const checksum = payloadChecksum.slice(length - 4, length)\n  if (validateChecksum(uint8arrays.concat([protocolByte, payload]), checksum)) {\n    throw Error(\"Checksums don't match\")\n  }\n\n  const addressObj = newAddress(protocol, payload, network)\n  if (encode(network, addressObj) !== address)\n    throw Error(`Did not encode this address properly: ${address}`)\n\n  return addressObj\n}\n\nexport function encode(network: string, address: Address): string {\n  if (!address || !address.str) throw Error('Invalid address')\n  const payload = address.payload()\n\n  switch (address.protocol()) {\n    case 0: {\n      return (\n        network +\n        String(address.protocol()) +\n        leb.unsigned.decode(address.payload())\n      )\n    }\n    default: {\n      const protocolByte = new Uint8Array([address.protocol()])\n      const checksum = getChecksum(uint8arrays.concat([protocolByte, payload]))\n      const bytes = uint8arrays.concat([payload, checksum])\n      return String(network) + String(address.protocol()) + base32.encode(bytes)\n    }\n  }\n}\n\nexport function newFromString(address: string): Address {\n  return decode(address)\n}\n\nexport function validateAddressString(addressString: string): boolean {\n  try {\n    checkAddressString(addressString)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\nexport function checkAddressString(address: string) {\n  if (!address) throw Error('No bytes to validate.')\n  if (address.length < 3) throw Error('Address is too short to validate.')\n  if (address[0] !== 'f' && address[0] !== 't') {\n    throw Error('Unknown address network.')\n  }\n\n  /* tslint:disable-next-line:radix */\n  const protocol = parseInt(address[1]) as Protocol\n  switch (protocol) {\n    case Protocol.ID: {\n      if (address.length > 22) throw Error('Invalid ID address length.')\n      break\n    }\n    case Protocol.SECP256K1: {\n      if (address.length !== 41)\n        throw Error('Invalid secp256k1 address length.')\n      break\n    }\n    case Protocol.ACTOR: {\n      if (address.length !== 41) throw Error('Invalid Actor address length.')\n      break\n    }\n    case Protocol.BLS: {\n      if (address.length !== 86) throw Error('Invalid BLS address length.')\n      break\n    }\n    default: {\n      throw new Error('Invalid address protocol.')\n    }\n  }\n}\n\n/**\n * idFromAddress extracts the ID from an ID address.\n */\nexport function idFromAddress (address: Address): number {\n  if (address.protocol() !== Protocol.ID)\n    throw new Error('Cannot get ID from non ID address')\n  // An unsigned varint should be less than 2^63 which is < Number.MAX_VALUE.\n  // So this number SHOULD be representable in JS and safe to parseInt.\n  // https://github.com/multiformats/unsigned-varint\n  // TODO: does leb128 enforce the max value?\n  return parseInt(leb.unsigned.decode(address.payload()), 10)\n}\n\nexport default {\n  Address,\n  newAddress,\n  newIDAddress,\n  newActorAddress,\n  newSecp256k1Address,\n  newBLSAddress,\n  newFromString,\n  bigintToArray,\n  decode,\n  encode,\n  getChecksum,\n  validateChecksum,\n  validateAddressString,\n  checkAddressString,\n  idFromAddress,\n  Network,\n  Protocol\n}\n"]},"metadata":{},"sourceType":"module"}