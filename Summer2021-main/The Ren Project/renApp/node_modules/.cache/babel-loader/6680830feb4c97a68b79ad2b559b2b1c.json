{"ast":null,"code":"// MIT License\n// Copyright (c) 2018-2020 Emilio Almansi\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { InvalidAddressError } from \"bchaddrjs\";\nimport cashaddr, { ValidationError } from \"cashaddrjs\";\nimport bs58check from \"bs58check\";\nvar Format;\n\n(function (Format) {\n  Format[\"Legacy\"] = \"legacy\";\n  Format[\"Bitpay\"] = \"bitpay\";\n  Format[\"Cashaddr\"] = \"cashaddr\";\n})(Format || (Format = {}));\n\nvar Network;\n\n(function (Network) {\n  Network[\"Mainnet\"] = \"mainnet\";\n  Network[\"Testnet\"] = \"testnet\";\n})(Network || (Network = {}));\n\nvar Type;\n\n(function (Type) {\n  Type[\"P2PKH\"] = \"p2pkh\";\n  Type[\"P2SH\"] = \"p2sh\";\n})(Type || (Type = {}));\n\nconst VERSION_BYTE = {\n  [Format.Legacy]: {\n    [Network.Mainnet]: {\n      [Type.P2PKH]: 0,\n      [Type.P2SH]: 5\n    },\n    [Network.Testnet]: {\n      [Type.P2PKH]: 111,\n      [Type.P2SH]: 196\n    }\n  },\n  [Format.Bitpay]: {\n    [Network.Mainnet]: {\n      [Type.P2PKH]: 28,\n      [Type.P2SH]: 40\n    },\n    [Network.Testnet]: {\n      [Type.P2PKH]: 111,\n      [Type.P2SH]: 196\n    }\n  }\n};\nconst BASE_58_CHECK_PAYLOAD_LENGTH = 21;\n\nconst decodeBase58Address = address => {\n  try {\n    const payload = bs58check.decode(address);\n\n    if (payload.length !== BASE_58_CHECK_PAYLOAD_LENGTH) {\n      throw new InvalidAddressError();\n    }\n\n    const versionByte = payload[0];\n    const hash = Array.prototype.slice.call(payload, 1);\n\n    switch (versionByte) {\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Mainnet,\n          type: Type.P2PKH\n        };\n\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Mainnet,\n          type: Type.P2SH\n        };\n\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Testnet,\n          type: Type.P2PKH\n        };\n\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Testnet,\n          type: Type.P2SH\n        };\n\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Bitpay,\n          network: Network.Mainnet,\n          type: Type.P2PKH\n        };\n\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Bitpay,\n          network: Network.Mainnet,\n          type: Type.P2SH\n        };\n    }\n  } catch (error) {// Ignore error.\n  }\n\n  throw new InvalidAddressError();\n};\n\nconst decodeCashAddressWithPrefix = address => {\n  try {\n    const decoded = cashaddr.decode(address);\n    const hash = Array.prototype.slice.call(decoded.hash, 0);\n    const type = decoded.type === \"P2PKH\" ? Type.P2PKH : Type.P2SH;\n\n    switch (decoded.prefix) {\n      case \"bitcoincash\":\n        return {\n          hash: hash,\n          format: Format.Cashaddr,\n          network: Network.Mainnet,\n          type: type\n        };\n\n      case \"bchtest\":\n      case \"bchreg\":\n        return {\n          hash: hash,\n          format: Format.Cashaddr,\n          network: Network.Testnet,\n          type: type\n        };\n    }\n  } catch (error) {// Ignore error.\n  }\n\n  throw new InvalidAddressError();\n};\n\nconst decodeCashAddress = address => {\n  if (address.indexOf(\":\") !== -1) {\n    try {\n      return decodeCashAddressWithPrefix(address);\n    } catch (error) {// Ignore error.\n    }\n  } else {\n    const prefixes = [\"bitcoincash\", \"bchtest\", \"bchreg\"];\n\n    for (let i = 0; i < prefixes.length; ++i) {\n      try {\n        const prefix = prefixes[i];\n        return decodeCashAddressWithPrefix(prefix + \":\" + address);\n      } catch (error) {// Ignore error.\n      }\n    }\n  }\n\n  throw new InvalidAddressError();\n};\n\nconst getTypeBits = type => {\n  switch (type.toLowerCase()) {\n    case Type.P2PKH:\n      return 0;\n\n    case Type.P2SH:\n      return 8;\n\n    default:\n      throw new ValidationError(\"Invalid type: \" + type + \".\");\n  }\n};\n\nexport const decodeBitcoinCashAddress = address => {\n  try {\n    return Buffer.from(decodeBase58Address(address).hash);\n  } catch (error) {// Ignore error.\n  }\n\n  try {\n    const {\n      hash,\n      type\n    } = decodeCashAddress(address);\n    return Buffer.concat([Buffer.from([getTypeBits(type)]), Buffer.from(hash)]);\n  } catch (error) {// Ignore error.\n  }\n\n  throw new InvalidAddressError();\n};","map":{"version":3,"sources":["../../src/bchaddrjs.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// MIT License\n// Copyright (c) 2018-2020 Emilio Almansi\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { InvalidAddressError } from \"bchaddrjs\";\nimport cashaddr, { ValidationError } from \"cashaddrjs\";\nimport bs58check from \"bs58check\";\nvar Format;\n(function (Format) {\n    Format[\"Legacy\"] = \"legacy\";\n    Format[\"Bitpay\"] = \"bitpay\";\n    Format[\"Cashaddr\"] = \"cashaddr\";\n})(Format || (Format = {}));\nvar Network;\n(function (Network) {\n    Network[\"Mainnet\"] = \"mainnet\";\n    Network[\"Testnet\"] = \"testnet\";\n})(Network || (Network = {}));\nvar Type;\n(function (Type) {\n    Type[\"P2PKH\"] = \"p2pkh\";\n    Type[\"P2SH\"] = \"p2sh\";\n})(Type || (Type = {}));\nconst VERSION_BYTE = {\n    [Format.Legacy]: {\n        [Network.Mainnet]: {\n            [Type.P2PKH]: 0,\n            [Type.P2SH]: 5,\n        },\n        [Network.Testnet]: {\n            [Type.P2PKH]: 111,\n            [Type.P2SH]: 196,\n        },\n    },\n    [Format.Bitpay]: {\n        [Network.Mainnet]: {\n            [Type.P2PKH]: 28,\n            [Type.P2SH]: 40,\n        },\n        [Network.Testnet]: {\n            [Type.P2PKH]: 111,\n            [Type.P2SH]: 196,\n        },\n    },\n};\nconst BASE_58_CHECK_PAYLOAD_LENGTH = 21;\nconst decodeBase58Address = (address) => {\n    try {\n        const payload = bs58check.decode(address);\n        if (payload.length !== BASE_58_CHECK_PAYLOAD_LENGTH) {\n            throw new InvalidAddressError();\n        }\n        const versionByte = payload[0];\n        const hash = Array.prototype.slice.call(payload, 1);\n        switch (versionByte) {\n            case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH]:\n                return {\n                    hash: hash,\n                    format: Format.Legacy,\n                    network: Network.Mainnet,\n                    type: Type.P2PKH,\n                };\n            case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH]:\n                return {\n                    hash: hash,\n                    format: Format.Legacy,\n                    network: Network.Mainnet,\n                    type: Type.P2SH,\n                };\n            case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH]:\n                return {\n                    hash: hash,\n                    format: Format.Legacy,\n                    network: Network.Testnet,\n                    type: Type.P2PKH,\n                };\n            case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH]:\n                return {\n                    hash: hash,\n                    format: Format.Legacy,\n                    network: Network.Testnet,\n                    type: Type.P2SH,\n                };\n            case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH]:\n                return {\n                    hash: hash,\n                    format: Format.Bitpay,\n                    network: Network.Mainnet,\n                    type: Type.P2PKH,\n                };\n            case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH]:\n                return {\n                    hash: hash,\n                    format: Format.Bitpay,\n                    network: Network.Mainnet,\n                    type: Type.P2SH,\n                };\n        }\n    }\n    catch (error) {\n        // Ignore error.\n    }\n    throw new InvalidAddressError();\n};\nconst decodeCashAddressWithPrefix = (address) => {\n    try {\n        const decoded = cashaddr.decode(address);\n        const hash = Array.prototype.slice.call(decoded.hash, 0);\n        const type = decoded.type === \"P2PKH\" ? Type.P2PKH : Type.P2SH;\n        switch (decoded.prefix) {\n            case \"bitcoincash\":\n                return {\n                    hash: hash,\n                    format: Format.Cashaddr,\n                    network: Network.Mainnet,\n                    type: type,\n                };\n            case \"bchtest\":\n            case \"bchreg\":\n                return {\n                    hash: hash,\n                    format: Format.Cashaddr,\n                    network: Network.Testnet,\n                    type: type,\n                };\n        }\n    }\n    catch (error) {\n        // Ignore error.\n    }\n    throw new InvalidAddressError();\n};\nconst decodeCashAddress = (address) => {\n    if (address.indexOf(\":\") !== -1) {\n        try {\n            return decodeCashAddressWithPrefix(address);\n        }\n        catch (error) {\n            // Ignore error.\n        }\n    }\n    else {\n        const prefixes = [\"bitcoincash\", \"bchtest\", \"bchreg\"];\n        for (let i = 0; i < prefixes.length; ++i) {\n            try {\n                const prefix = prefixes[i];\n                return decodeCashAddressWithPrefix(prefix + \":\" + address);\n            }\n            catch (error) {\n                // Ignore error.\n            }\n        }\n    }\n    throw new InvalidAddressError();\n};\nconst getTypeBits = (type) => {\n    switch (type.toLowerCase()) {\n        case Type.P2PKH:\n            return 0;\n        case Type.P2SH:\n            return 8;\n        default:\n            throw new ValidationError(\"Invalid type: \" + type + \".\");\n    }\n};\nexport const decodeBitcoinCashAddress = (address) => {\n    try {\n        return Buffer.from(decodeBase58Address(address).hash);\n    }\n    catch (error) {\n        // Ignore error.\n    }\n    try {\n        const { hash, type } = decodeCashAddress(address);\n        return Buffer.concat([\n            Buffer.from([getTypeBits(type)]),\n            Buffer.from(hash),\n        ]);\n    }\n    catch (error) {\n        // Ignore error.\n    }\n    throw new InvalidAddressError();\n};\n//# sourceMappingURL=bchaddrjs.js.map"]},"metadata":{},"sourceType":"module"}