{"ast":null,"code":"import { Callable, isHex, utilsWithChainNetwork } from \"@renproject/utils\";\nimport { Networks, Opcode, Script } from \"@CoinSpace/bitcore-lib-dogecoin\";\nimport base58 from \"bs58\";\nimport { Blockchair, BlockchairNetwork } from \"./APIs/blockchair\";\nimport { SoChain, SoChainNetwork } from \"./APIs/sochain\";\nimport { BitcoinClass } from \"./bitcoin\";\nimport { createAddress, pubKeyScript } from \"./script\";\nimport { validateAddress } from \"./utils\";\nexport class DogecoinClass extends BitcoinClass {\n  constructor() {\n    super(...arguments);\n    this.chain = DogecoinClass.chain;\n    this.name = DogecoinClass.chain;\n    this.legacyName = undefined; // APIs\n\n    this.withDefaultAPIs = network => {\n      switch (network) {\n        case \"mainnet\":\n          // prettier-ignore\n          return this.withAPI(Blockchair(BlockchairNetwork.DOGECOIN)).withAPI(SoChain(SoChainNetwork.DOGE), {\n            priority: 15\n          });\n\n        case \"testnet\":\n          // prettier-ignore\n          return this.withAPI(SoChain(SoChainNetwork.DOGETEST), {\n            priority: 15\n          });\n\n        case \"regtest\":\n          throw new Error(`Regtest is currently not supported.`);\n      }\n    };\n\n    this.asset = \"DOGE\";\n    this.utils = utilsWithChainNetwork(DogecoinClass.utils, () => this.chainNetwork);\n  }\n\n}\nDogecoinClass.chain = \"Dogecoin\";\nDogecoinClass.asset = \"DOGE\";\nDogecoinClass.utils = {\n  resolveChainNetwork: BitcoinClass.utils.resolveChainNetwork,\n  p2shPrefix: {\n    mainnet: Buffer.from([0x16]),\n    testnet: Buffer.from([0xc4])\n  },\n  createAddress: createAddress(base58.encode, Networks, Opcode, Script),\n  calculatePubKeyScript: pubKeyScript(Networks, Opcode, Script),\n  addressIsValid: (address, network = \"mainnet\") => validateAddress(address, DogecoinClass.asset, Dogecoin.utils.resolveChainNetwork(network)),\n  transactionIsValid: (transaction, _network = \"mainnet\") => isHex(typeof transaction === \"string\" ? transaction : transaction.txHash, {\n    length: 32\n  }),\n  addressExplorerLink: (address, network = \"mainnet\") => {\n    switch (Dogecoin.utils.resolveChainNetwork(network)) {\n      case \"mainnet\":\n        return `https://sochain.com/address/DOGE/${address}/`;\n\n      case \"testnet\":\n        return `https://sochain.com/address/DOGETEST/${address}/`;\n\n      case \"regtest\":\n        return undefined;\n    }\n  },\n  transactionExplorerLink: (tx, network = \"mainnet\") => {\n    const txHash = typeof tx === \"string\" ? tx : tx.txHash;\n\n    switch (Dogecoin.utils.resolveChainNetwork(network)) {\n      case \"mainnet\":\n        return `https://sochain.com/tx/DOGE/${txHash}/`;\n\n      case \"testnet\":\n        return `https://sochain.com/tx/DOGETEST/${txHash}/`;\n\n      case \"regtest\":\n        return undefined;\n    }\n  }\n};\nexport const Dogecoin = Callable(DogecoinClass);\nconst _ = Dogecoin;","map":{"version":3,"sources":["../../src/dogecoin.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Callable, isHex, utilsWithChainNetwork } from \"@renproject/utils\";\nimport { Networks, Opcode, Script } from \"@CoinSpace/bitcore-lib-dogecoin\";\nimport base58 from \"bs58\";\nimport { Blockchair, BlockchairNetwork } from \"./APIs/blockchair\";\nimport { SoChain, SoChainNetwork } from \"./APIs/sochain\";\nimport { BitcoinClass } from \"./bitcoin\";\nimport { createAddress, pubKeyScript } from \"./script\";\nimport { validateAddress } from \"./utils\";\nexport class DogecoinClass extends BitcoinClass {\n    constructor() {\n        super(...arguments);\n        this.chain = DogecoinClass.chain;\n        this.name = DogecoinClass.chain;\n        this.legacyName = undefined;\n        // APIs\n        this.withDefaultAPIs = (network) => {\n            switch (network) {\n                case \"mainnet\":\n                    // prettier-ignore\n                    return this\n                        .withAPI(Blockchair(BlockchairNetwork.DOGECOIN))\n                        .withAPI(SoChain(SoChainNetwork.DOGE), { priority: 15 });\n                case \"testnet\":\n                    // prettier-ignore\n                    return this\n                        .withAPI(SoChain(SoChainNetwork.DOGETEST), { priority: 15 });\n                case \"regtest\":\n                    throw new Error(`Regtest is currently not supported.`);\n            }\n        };\n        this.asset = \"DOGE\";\n        this.utils = utilsWithChainNetwork(DogecoinClass.utils, () => this.chainNetwork);\n    }\n}\nDogecoinClass.chain = \"Dogecoin\";\nDogecoinClass.asset = \"DOGE\";\nDogecoinClass.utils = {\n    resolveChainNetwork: BitcoinClass.utils.resolveChainNetwork,\n    p2shPrefix: {\n        mainnet: Buffer.from([0x16]),\n        testnet: Buffer.from([0xc4]),\n    },\n    createAddress: createAddress(base58.encode, Networks, Opcode, Script),\n    calculatePubKeyScript: pubKeyScript(Networks, Opcode, Script),\n    addressIsValid: (address, network = \"mainnet\") => validateAddress(address, DogecoinClass.asset, Dogecoin.utils.resolveChainNetwork(network)),\n    transactionIsValid: (transaction, _network = \"mainnet\") => isHex(typeof transaction === \"string\"\n        ? transaction\n        : transaction.txHash, { length: 32 }),\n    addressExplorerLink: (address, network = \"mainnet\") => {\n        switch (Dogecoin.utils.resolveChainNetwork(network)) {\n            case \"mainnet\":\n                return `https://sochain.com/address/DOGE/${address}/`;\n            case \"testnet\":\n                return `https://sochain.com/address/DOGETEST/${address}/`;\n            case \"regtest\":\n                return undefined;\n        }\n    },\n    transactionExplorerLink: (tx, network = \"mainnet\") => {\n        const txHash = typeof tx === \"string\" ? tx : tx.txHash;\n        switch (Dogecoin.utils.resolveChainNetwork(network)) {\n            case \"mainnet\":\n                return `https://sochain.com/tx/DOGE/${txHash}/`;\n            case \"testnet\":\n                return `https://sochain.com/tx/DOGETEST/${txHash}/`;\n            case \"regtest\":\n                return undefined;\n        }\n    },\n};\nexport const Dogecoin = Callable(DogecoinClass);\nconst _ = Dogecoin;\n//# sourceMappingURL=dogecoin.js.map"]},"metadata":{},"sourceType":"module"}