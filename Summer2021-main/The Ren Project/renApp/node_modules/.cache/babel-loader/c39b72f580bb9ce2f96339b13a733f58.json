{"ast":null,"code":"'use strict';\n/* jshint maxparams:5 */\n\nvar Signature = require('../crypto/signature');\n\nvar Script = require('../script');\n\nvar Output = require('./output');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar BN = require('../crypto/bn');\n\nvar Hash = require('../crypto/hash');\n\nvar ECDSA = require('../crypto/ecdsa');\n\nvar $ = require('../util/preconditions');\n\nvar _ = require('lodash');\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for witness programs as defined by:\n * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Buffer} scriptCode\n * @param {Buffer} satoshisBuffer\n */\n\n\nvar sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {\n  /* jshint maxstatements: 50 */\n  var hashPrevouts;\n  var hashSequence;\n  var hashOutputs;\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    var buffers = [];\n\n    for (var n = 0; n < transaction.inputs.length; n++) {\n      var input = transaction.inputs[n];\n      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();\n      buffers.push(prevTxIdBuffer);\n      var outputIndexBuffer = Buffer.from(new Array(4));\n      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);\n      buffers.push(outputIndexBuffer);\n    }\n\n    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    var sequenceBuffers = [];\n\n    for (var m = 0; m < transaction.inputs.length; m++) {\n      var sequenceBuffer = Buffer.from(new Array(4));\n      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);\n      sequenceBuffers.push(sequenceBuffer);\n    }\n\n    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));\n  }\n\n  var outputWriter = new BufferWriter();\n\n  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    for (var p = 0; p < transaction.outputs.length; p++) {\n      transaction.outputs[p].toBufferWriter(outputWriter);\n    }\n\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    transaction.outputs[inputNumber].toBufferWriter(outputWriter);\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } // Version\n\n\n  var writer = new BufferWriter();\n  writer.writeUInt32LE(transaction.version); // Input prevouts/nSequence (none/all, depending on flags)\n\n  writer.write(hashPrevouts);\n  writer.write(hashSequence); // The input being signed (replacing the scriptSig with scriptCode + amount)\n  // The prevout may already be contained in hashPrevout, and the nSequence\n  // may already be contain in hashSequence.\n\n  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();\n  writer.write(outpointId);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);\n  writer.write(scriptCode);\n  writer.write(satoshisBuffer);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber); // Outputs (none/one/all, depending on flags)\n\n  writer.write(hashOutputs); // Locktime\n\n  writer.writeUInt32LE(transaction.nLockTime); // Sighash type\n\n  writer.writeInt32LE(sighashType);\n  return Hash.sha256sha256(writer.toBuffer());\n};\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {Signature}\n */\n\n\nfunction sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer) {\n  var hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);\n  var sig = ECDSA.sign(hashbuf, privateKey).set({\n    nhashtype: sighashType\n  });\n  return sig;\n}\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {boolean}\n */\n\n\nfunction verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);\n  return ECDSA.verify(hashbuf, signature, publicKey);\n}\n/**\n * @namespace Signing\n */\n\n\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};","map":{"version":3,"sources":["/home/kesha/Downloads/ren-main/renApp/node_modules/@CoinSpace/bitcore-lib-dogecoin/lib/transaction/sighashwitness.js"],"names":["Signature","require","Script","Output","BufferReader","BufferWriter","BN","Hash","ECDSA","$","_","sighash","transaction","sighashType","inputNumber","scriptCode","satoshisBuffer","hashPrevouts","hashSequence","hashOutputs","SIGHASH_ANYONECANPAY","buffers","n","inputs","length","input","prevTxIdBuffer","prevTxId","readReverse","push","outputIndexBuffer","Buffer","from","Array","writeUInt32LE","outputIndex","sha256sha256","concat","SIGHASH_SINGLE","SIGHASH_NONE","sequenceBuffers","m","sequenceBuffer","sequenceNumber","outputWriter","p","outputs","toBufferWriter","toBuffer","writer","version","write","outpointId","nLockTime","writeInt32LE","sign","privateKey","inputIndex","hashbuf","sig","set","nhashtype","verify","signature","publicKey","checkArgument","isUndefined","module","exports"],"mappings":"AAAA;AAEA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,qBAAD,CAAvB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAApB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIG,YAAY,GAAGH,OAAO,CAAC,0BAAD,CAA1B;;AACA,IAAII,YAAY,GAAGJ,OAAO,CAAC,0BAAD,CAA1B;;AACA,IAAIK,EAAE,GAAGL,OAAO,CAAC,cAAD,CAAhB;;AACA,IAAIM,IAAI,GAAGN,OAAO,CAAC,gBAAD,CAAlB;;AACA,IAAIO,KAAK,GAAGP,OAAO,CAAC,iBAAD,CAAnB;;AACA,IAAIQ,CAAC,GAAGR,OAAO,CAAC,uBAAD,CAAf;;AACA,IAAIS,CAAC,GAAGT,OAAO,CAAC,QAAD,CAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIU,OAAO,GAAG,SAASA,OAAT,CAAiBC,WAAjB,EAA8BC,WAA9B,EAA2CC,WAA3C,EAAwDC,UAAxD,EAAoEC,cAApE,EAAoF;AAChG;AAEA,MAAIC,YAAJ;AACA,MAAIC,YAAJ;AACA,MAAIC,WAAJ;;AAEA,MAAI,EAAEN,WAAW,GAAGb,SAAS,CAACoB,oBAA1B,CAAJ,EAAqD;AACnD,QAAIC,OAAO,GAAG,EAAd;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,WAAW,CAACW,MAAZ,CAAmBC,MAAvC,EAA+CF,CAAC,EAAhD,EAAoD;AAClD,UAAIG,KAAK,GAAGb,WAAW,CAACW,MAAZ,CAAmBD,CAAnB,CAAZ;AACA,UAAII,cAAc,GAAG,IAAItB,YAAJ,CAAiBqB,KAAK,CAACE,QAAvB,EAAiCC,WAAjC,EAArB;AACAP,MAAAA,OAAO,CAACQ,IAAR,CAAaH,cAAb;AACA,UAAII,iBAAiB,GAAGC,MAAM,CAACC,IAAP,CAAY,IAAIC,KAAJ,CAAU,CAAV,CAAZ,CAAxB;AACAH,MAAAA,iBAAiB,CAACI,aAAlB,CAAgCT,KAAK,CAACU,WAAtC,EAAmD,CAAnD;AACAd,MAAAA,OAAO,CAACQ,IAAR,CAAaC,iBAAb;AACD;;AACDb,IAAAA,YAAY,GAAGV,IAAI,CAAC6B,YAAL,CAAkBL,MAAM,CAACM,MAAP,CAAchB,OAAd,CAAlB,CAAf;AACD;;AAED,MAAI,EAAER,WAAW,GAAGb,SAAS,CAACoB,oBAA1B,KACA,CAACP,WAAW,GAAG,IAAf,MAAyBb,SAAS,CAACsC,cADnC,IACqD,CAACzB,WAAW,GAAG,IAAf,MAAyBb,SAAS,CAACuC,YAD5F,EAC0G;AAExG,QAAIC,eAAe,GAAG,EAAtB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7B,WAAW,CAACW,MAAZ,CAAmBC,MAAvC,EAA+CiB,CAAC,EAAhD,EAAoD;AAClD,UAAIC,cAAc,GAAGX,MAAM,CAACC,IAAP,CAAY,IAAIC,KAAJ,CAAU,CAAV,CAAZ,CAArB;AACAS,MAAAA,cAAc,CAACR,aAAf,CAA6BtB,WAAW,CAACW,MAAZ,CAAmBkB,CAAnB,EAAsBE,cAAnD,EAAmE,CAAnE;AACAH,MAAAA,eAAe,CAACX,IAAhB,CAAqBa,cAArB;AACD;;AACDxB,IAAAA,YAAY,GAAGX,IAAI,CAAC6B,YAAL,CAAkBL,MAAM,CAACM,MAAP,CAAcG,eAAd,CAAlB,CAAf;AACD;;AAED,MAAII,YAAY,GAAG,IAAIvC,YAAJ,EAAnB;;AACA,MAAI,CAACQ,WAAW,GAAG,IAAf,MAAyBb,SAAS,CAACsC,cAAnC,IAAqD,CAACzB,WAAW,GAAG,IAAf,MAAyBb,SAAS,CAACuC,YAA5F,EAA0G;AACxG,SAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,WAAW,CAACkC,OAAZ,CAAoBtB,MAAxC,EAAgDqB,CAAC,EAAjD,EAAqD;AACnDjC,MAAAA,WAAW,CAACkC,OAAZ,CAAoBD,CAApB,EAAuBE,cAAvB,CAAsCH,YAAtC;AACD;;AACDzB,IAAAA,WAAW,GAAGZ,IAAI,CAAC6B,YAAL,CAAkBQ,YAAY,CAACI,QAAb,EAAlB,CAAd;AACD,GALD,MAKO,IAAI,CAACnC,WAAW,GAAG,IAAf,MAAyBb,SAAS,CAACsC,cAAnC,IAAqDxB,WAAW,GAAGF,WAAW,CAACkC,OAAZ,CAAoBtB,MAA3F,EAAmG;AACxGZ,IAAAA,WAAW,CAACkC,OAAZ,CAAoBhC,WAApB,EAAiCiC,cAAjC,CAAgDH,YAAhD;AACAzB,IAAAA,WAAW,GAAGZ,IAAI,CAAC6B,YAAL,CAAkBQ,YAAY,CAACI,QAAb,EAAlB,CAAd;AACD,GAzC+F,CA2ChG;;;AACA,MAAIC,MAAM,GAAG,IAAI5C,YAAJ,EAAb;AACA4C,EAAAA,MAAM,CAACf,aAAP,CAAqBtB,WAAW,CAACsC,OAAjC,EA7CgG,CA+ChG;;AACAD,EAAAA,MAAM,CAACE,KAAP,CAAalC,YAAb;AACAgC,EAAAA,MAAM,CAACE,KAAP,CAAajC,YAAb,EAjDgG,CAmDhG;AACA;AACA;;AACA,MAAIkC,UAAU,GAAG,IAAIhD,YAAJ,CAAiBQ,WAAW,CAACW,MAAZ,CAAmBT,WAAnB,EAAgCa,QAAjD,EAA2DC,WAA3D,EAAjB;AACAqB,EAAAA,MAAM,CAACE,KAAP,CAAaC,UAAb;AACAH,EAAAA,MAAM,CAACf,aAAP,CAAqBtB,WAAW,CAACW,MAAZ,CAAmBT,WAAnB,EAAgCqB,WAArD;AAEAc,EAAAA,MAAM,CAACE,KAAP,CAAapC,UAAb;AAEAkC,EAAAA,MAAM,CAACE,KAAP,CAAanC,cAAb;AAEAiC,EAAAA,MAAM,CAACf,aAAP,CAAqBtB,WAAW,CAACW,MAAZ,CAAmBT,WAAnB,EAAgC6B,cAArD,EA9DgG,CAgEhG;;AACAM,EAAAA,MAAM,CAACE,KAAP,CAAahC,WAAb,EAjEgG,CAmEhG;;AACA8B,EAAAA,MAAM,CAACf,aAAP,CAAqBtB,WAAW,CAACyC,SAAjC,EApEgG,CAsEhG;;AACAJ,EAAAA,MAAM,CAACK,YAAP,CAAoBzC,WAApB;AAEA,SAAON,IAAI,CAAC6B,YAAL,CAAkBa,MAAM,CAACD,QAAP,EAAlB,CAAP;AAED,CA3ED;AA6EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASO,IAAT,CAAc3C,WAAd,EAA2B4C,UAA3B,EAAuC3C,WAAvC,EAAoD4C,UAApD,EAAgE1C,UAAhE,EAA4EC,cAA5E,EAA4F;AAC1F,MAAI0C,OAAO,GAAG/C,OAAO,CAACC,WAAD,EAAcC,WAAd,EAA2B4C,UAA3B,EAAuC1C,UAAvC,EAAmDC,cAAnD,CAArB;AACA,MAAI2C,GAAG,GAAGnD,KAAK,CAAC+C,IAAN,CAAWG,OAAX,EAAoBF,UAApB,EAAgCI,GAAhC,CAAoC;AAC5CC,IAAAA,SAAS,EAAEhD;AADiC,GAApC,CAAV;AAGA,SAAO8C,GAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,MAAT,CAAgBlD,WAAhB,EAA6BmD,SAA7B,EAAwCC,SAAxC,EAAmDP,UAAnD,EAA+D1C,UAA/D,EAA2EC,cAA3E,EAA2F;AACzFP,EAAAA,CAAC,CAACwD,aAAF,CAAgB,CAACvD,CAAC,CAACwD,WAAF,CAActD,WAAd,CAAjB;AACAH,EAAAA,CAAC,CAACwD,aAAF,CAAgB,CAACvD,CAAC,CAACwD,WAAF,CAAcH,SAAd,CAAD,IAA6B,CAACrD,CAAC,CAACwD,WAAF,CAAcH,SAAS,CAACF,SAAxB,CAA9C;AACA,MAAIH,OAAO,GAAG/C,OAAO,CAACC,WAAD,EAAcmD,SAAS,CAACF,SAAxB,EAAmCJ,UAAnC,EAA+C1C,UAA/C,EAA2DC,cAA3D,CAArB;AACA,SAAOR,KAAK,CAACsD,MAAN,CAAaJ,OAAb,EAAsBK,SAAtB,EAAiCC,SAAjC,CAAP;AACD;AAED;AACA;AACA;;;AACAG,MAAM,CAACC,OAAP,GAAiB;AACfzD,EAAAA,OAAO,EAAEA,OADM;AAEf4C,EAAAA,IAAI,EAAEA,IAFS;AAGfO,EAAAA,MAAM,EAAEA;AAHO,CAAjB","sourcesContent":["'use strict';\n\n/* jshint maxparams:5 */\n\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for witness programs as defined by:\n * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Buffer} scriptCode\n * @param {Buffer} satoshisBuffer\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {\n  /* jshint maxstatements: 50 */\n\n  var hashPrevouts;\n  var hashSequence;\n  var hashOutputs;\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    var buffers = [];\n    for (var n = 0; n < transaction.inputs.length; n++) {\n      var input = transaction.inputs[n];\n      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();\n      buffers.push(prevTxIdBuffer);\n      var outputIndexBuffer = Buffer.from(new Array(4));\n      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);\n      buffers.push(outputIndexBuffer);\n    }\n    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&\n      (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n\n    var sequenceBuffers = [];\n    for (var m = 0; m < transaction.inputs.length; m++) {\n      var sequenceBuffer = Buffer.from(new Array(4));\n      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);\n      sequenceBuffers.push(sequenceBuffer);\n    }\n    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));\n  }\n\n  var outputWriter = new BufferWriter();\n  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    for (var p = 0; p < transaction.outputs.length; p++) {\n      transaction.outputs[p].toBufferWriter(outputWriter);\n    }\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    transaction.outputs[inputNumber].toBufferWriter(outputWriter);\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  }\n\n  // Version\n  var writer = new BufferWriter();\n  writer.writeUInt32LE(transaction.version);\n\n  // Input prevouts/nSequence (none/all, depending on flags)\n  writer.write(hashPrevouts);\n  writer.write(hashSequence);\n\n  // The input being signed (replacing the scriptSig with scriptCode + amount)\n  // The prevout may already be contained in hashPrevout, and the nSequence\n  // may already be contain in hashSequence.\n  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();\n  writer.write(outpointId);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);\n\n  writer.write(scriptCode);\n\n  writer.write(satoshisBuffer);\n\n  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\n\n  // Outputs (none/one/all, depending on flags)\n  writer.write(hashOutputs);\n\n  // Locktime\n  writer.writeUInt32LE(transaction.nLockTime);\n\n  // Sighash type\n  writer.writeInt32LE(sighashType);\n\n  return Hash.sha256sha256(writer.toBuffer());\n\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer) {\n  var hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);\n  var sig = ECDSA.sign(hashbuf, privateKey).set({\n    nhashtype: sighashType\n  });\n  return sig;\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);\n  return ECDSA.verify(hashbuf, signature, publicKey);\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n"]},"metadata":{},"sourceType":"script"}