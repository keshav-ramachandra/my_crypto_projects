{"ast":null,"code":"import { Callable, isHex, utilsWithChainNetwork } from \"@renproject/utils\";\nimport { createAddress, pubKeyScript as calculatePubKeyScript } from \"./script\";\nimport { Networks, Opcode, Script } from \"bitcore-lib\";\nimport { BitcoinBaseChain } from \"./base\";\nimport { validateAddress } from \"./utils\";\nimport { Blockstream } from \"./APIs/blockstream\";\nimport { Blockchair, BlockchairNetwork } from \"./APIs/blockchair\";\nimport { SoChain, SoChainNetwork } from \"./APIs/sochain\";\nimport base58 from \"bs58\";\n/**\n * The Bitcoin class adds support for the asset BTC.\n */\n\nexport class BitcoinClass extends BitcoinBaseChain {\n  constructor() {\n    super(...arguments);\n    this.chain = BitcoinClass.chain;\n    this.name = BitcoinClass.chain;\n    this.legacyName = \"Btc\";\n    this.asset = \"BTC\"; // APIs\n\n    this.withDefaultAPIs = network => {\n      switch (network) {\n        case \"mainnet\":\n          // prettier-ignore\n          return this.withAPI(Blockstream()).withAPI(Blockchair()).withAPI(SoChain(), {\n            priority: 15\n          });\n\n        case \"testnet\":\n          // prettier-ignore\n          return this.withAPI(Blockstream({\n            testnet: true\n          })).withAPI(Blockchair(BlockchairNetwork.BITCOIN_TESTNET)).withAPI(SoChain(SoChainNetwork.BTCTEST), {\n            priority: 15\n          });\n\n        case \"regtest\":\n          // Will be supported when Electrum is added as an API.\n          throw new Error(`Regtest is currently not supported.`);\n      }\n    };\n\n    this.utils = utilsWithChainNetwork(BitcoinClass.utils, () => this.chainNetwork);\n  }\n\n}\nBitcoinClass.chain = \"Bitcoin\"; // Asset\n\nBitcoinClass.asset = \"BTC\";\nBitcoinClass.utils = {\n  resolveChainNetwork: BitcoinBaseChain.utils.resolveChainNetwork,\n  p2shPrefix: {\n    mainnet: Buffer.from([0x05]),\n    testnet: Buffer.from([0xc4])\n  },\n  createAddress: createAddress(base58.encode, Networks, Opcode, Script),\n  calculatePubKeyScript: calculatePubKeyScript(Networks, Opcode, Script),\n  addressIsValid: (address, network = \"mainnet\") => validateAddress(address, BitcoinBaseChain.asset, Bitcoin.utils.resolveChainNetwork(network)),\n  transactionIsValid: (transaction, _network = \"mainnet\") => isHex(typeof transaction === \"string\" ? transaction : transaction.txHash, {\n    length: 32\n  }),\n  addressExplorerLink: (address, network = \"mainnet\") => {\n    switch (Bitcoin.utils.resolveChainNetwork(network)) {\n      case \"mainnet\":\n        return BlockCypher.Address(BlockCypherNetwork.BitcoinMainnet, address);\n\n      case \"testnet\":\n        return BlockCypher.Address(BlockCypherNetwork.BitcoinTestnet, address);\n\n      case \"regtest\":\n        return undefined;\n    }\n  },\n  transactionExplorerLink: (tx, network = \"mainnet\") => {\n    const txHash = typeof tx === \"string\" ? tx : tx.txHash;\n\n    switch (Bitcoin.utils.resolveChainNetwork(network)) {\n      case \"mainnet\":\n        return BlockCypher.Transaction(BlockCypherNetwork.BitcoinMainnet, txHash);\n\n      case \"testnet\":\n        return BlockCypher.Transaction(BlockCypherNetwork.BitcoinTestnet, txHash);\n\n      case \"regtest\":\n        return undefined;\n    }\n  }\n};\nexport const Bitcoin = Callable(BitcoinClass);\nconst _ = Bitcoin; // Explorers ///////////////////////////////////////////////////////////////////\n\nexport var BlockCypherNetwork;\n\n(function (BlockCypherNetwork) {\n  BlockCypherNetwork[\"BitcoinMainnet\"] = \"btc\";\n  BlockCypherNetwork[\"BitcoinTestnet\"] = \"btc-testnet\";\n})(BlockCypherNetwork || (BlockCypherNetwork = {}));\n\nexport const BlockCypher = {\n  Address: (network, address) => `https://live.blockcypher.com/${network}/address/${address}/`,\n  Transaction: (network, txHash) => `https://live.blockcypher.com/${network}/tx/${txHash}/`\n};","map":{"version":3,"sources":["../../src/bitcoin.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Callable, isHex, utilsWithChainNetwork } from \"@renproject/utils\";\nimport { createAddress, pubKeyScript as calculatePubKeyScript } from \"./script\";\nimport { Networks, Opcode, Script } from \"bitcore-lib\";\nimport { BitcoinBaseChain, } from \"./base\";\nimport { validateAddress } from \"./utils\";\nimport { Blockstream } from \"./APIs/blockstream\";\nimport { Blockchair, BlockchairNetwork } from \"./APIs/blockchair\";\nimport { SoChain, SoChainNetwork } from \"./APIs/sochain\";\nimport base58 from \"bs58\";\n/**\n * The Bitcoin class adds support for the asset BTC.\n */\nexport class BitcoinClass extends BitcoinBaseChain {\n    constructor() {\n        super(...arguments);\n        this.chain = BitcoinClass.chain;\n        this.name = BitcoinClass.chain;\n        this.legacyName = \"Btc\";\n        this.asset = \"BTC\";\n        // APIs\n        this.withDefaultAPIs = (network) => {\n            switch (network) {\n                case \"mainnet\":\n                    // prettier-ignore\n                    return this\n                        .withAPI(Blockstream())\n                        .withAPI(Blockchair())\n                        .withAPI(SoChain(), { priority: 15 });\n                case \"testnet\":\n                    // prettier-ignore\n                    return this\n                        .withAPI(Blockstream({ testnet: true }))\n                        .withAPI(Blockchair(BlockchairNetwork.BITCOIN_TESTNET))\n                        .withAPI(SoChain(SoChainNetwork.BTCTEST), { priority: 15 });\n                case \"regtest\":\n                    // Will be supported when Electrum is added as an API.\n                    throw new Error(`Regtest is currently not supported.`);\n            }\n        };\n        this.utils = utilsWithChainNetwork(BitcoinClass.utils, () => this.chainNetwork);\n    }\n}\nBitcoinClass.chain = \"Bitcoin\";\n// Asset\nBitcoinClass.asset = \"BTC\";\nBitcoinClass.utils = {\n    resolveChainNetwork: BitcoinBaseChain.utils.resolveChainNetwork,\n    p2shPrefix: {\n        mainnet: Buffer.from([0x05]),\n        testnet: Buffer.from([0xc4]),\n    },\n    createAddress: createAddress(base58.encode, Networks, Opcode, Script),\n    calculatePubKeyScript: calculatePubKeyScript(Networks, Opcode, Script),\n    addressIsValid: (address, network = \"mainnet\") => validateAddress(address, BitcoinBaseChain.asset, Bitcoin.utils.resolveChainNetwork(network)),\n    transactionIsValid: (transaction, _network = \"mainnet\") => isHex(typeof transaction === \"string\"\n        ? transaction\n        : transaction.txHash, { length: 32 }),\n    addressExplorerLink: (address, network = \"mainnet\") => {\n        switch (Bitcoin.utils.resolveChainNetwork(network)) {\n            case \"mainnet\":\n                return BlockCypher.Address(BlockCypherNetwork.BitcoinMainnet, address);\n            case \"testnet\":\n                return BlockCypher.Address(BlockCypherNetwork.BitcoinTestnet, address);\n            case \"regtest\":\n                return undefined;\n        }\n    },\n    transactionExplorerLink: (tx, network = \"mainnet\") => {\n        const txHash = typeof tx === \"string\" ? tx : tx.txHash;\n        switch (Bitcoin.utils.resolveChainNetwork(network)) {\n            case \"mainnet\":\n                return BlockCypher.Transaction(BlockCypherNetwork.BitcoinMainnet, txHash);\n            case \"testnet\":\n                return BlockCypher.Transaction(BlockCypherNetwork.BitcoinTestnet, txHash);\n            case \"regtest\":\n                return undefined;\n        }\n    },\n};\nexport const Bitcoin = Callable(BitcoinClass);\nconst _ = Bitcoin;\n// Explorers ///////////////////////////////////////////////////////////////////\nexport var BlockCypherNetwork;\n(function (BlockCypherNetwork) {\n    BlockCypherNetwork[\"BitcoinMainnet\"] = \"btc\";\n    BlockCypherNetwork[\"BitcoinTestnet\"] = \"btc-testnet\";\n})(BlockCypherNetwork || (BlockCypherNetwork = {}));\nexport const BlockCypher = {\n    Address: (network, address) => `https://live.blockcypher.com/${network}/address/${address}/`,\n    Transaction: (network, txHash) => `https://live.blockcypher.com/${network}/tx/${txHash}/`,\n};\n//# sourceMappingURL=bitcoin.js.map"]},"metadata":{},"sourceType":"module"}