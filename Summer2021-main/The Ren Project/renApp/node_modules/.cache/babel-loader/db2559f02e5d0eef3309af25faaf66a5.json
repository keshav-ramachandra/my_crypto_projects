{"ast":null,"code":"import { NullLogger } from \"@renproject/interfaces\";\nimport { assertType } from \"./assert\";\nimport { fromBase64, fromHex, Ox, rawEncode, toBase64, toURLBase64 } from \"./common\";\nimport { keccak256 } from \"./hash\"; // export const generateNHash = (tx: Tx): Buffer => {\n//     const encoded = rawEncode(\n//         [\"bytes32\", \"bytes32\"],\n//         [Ox(tx.hash), Ox(tx.args.n)],\n//     );\n//     return keccak256(encoded);\n// };\n\n/**\n * Hash the payloads associated with a RenVM cross-chain transaction.\n *\n * @param zip An array (or spread) of parameters with with types defined.\n */\n\nexport const generatePHash = (zip, logger = NullLogger) => {\n  // Check if they called as hashPayload([...]) instead of hashPayload(...)\n  const args = (Array.isArray(zip[0]) ? zip[0] : zip).filter(arg => !arg.notInPayload);\n  const types = args.map(param => param.type);\n  const values = args.map(param => param.value);\n  const message = rawEncode(types, values);\n  const digest = keccak256(message);\n  logger.debug(\"pHash\", toBase64(digest), Ox(message), args);\n  return digest; // sha3 can accept a Buffer\n};\nexport const generateSHash = selector => {\n  const toSelector = selector.replace(/\\/.*To/, \"/to\");\n  return keccak256(Buffer.from(toSelector));\n};\nexport const generateGHash = (payload, to, tokenIdentifier, nonce, v2, logger = NullLogger) => {\n  // Type validation\n  assertType(\"Buffer\", {\n    nonce\n  });\n  assertType(\"string\", {\n    to,\n    token: tokenIdentifier\n  });\n  const pHash = generatePHash(payload, logger);\n  const sHash = fromHex(tokenIdentifier);\n  const toBytes = fromHex(to);\n  const encoded = v2 ? Buffer.concat([pHash, sHash, toBytes, nonce]) : rawEncode([\"bytes32\", \"address\", \"address\", \"bytes32\"], [pHash, tokenIdentifier, to, nonce]);\n  const digest = keccak256(encoded);\n  logger.debug(\"gHash\", toBase64(digest), Ox(encoded));\n  return digest;\n};\nexport const generateNHash = (nonce, txid, txindex, v2, logger = NullLogger) => {\n  const encoded = v2 ? Buffer.concat([nonce, txid, rawEncode([\"uint32\"], [txindex]).slice(-4)]) : rawEncode([\"bytes32\", \"bytes32\", \"uint32\"], [nonce, txid, txindex]);\n  const digest = keccak256(encoded);\n  logger.debug(\"nHash\", toBase64(digest), Ox(encoded));\n  return digest;\n};\nexport const generateSighash = (pHash, amount, to, tokenIdentifier, nonceHash, v2, logger = NullLogger) => {\n  // Type validation\n  assertType(\"string\", {\n    to,\n    tokenIdentifier\n  });\n  assertType(\"Buffer\", {\n    pHash,\n    nonceHash\n  });\n  const encoded = rawEncode([\"bytes32\", \"uint256\", v2 ? \"bytes32\" : \"address\", \"address\", \"bytes32\"], [pHash, amount, Ox(tokenIdentifier), Ox(to), nonceHash]);\n  const digest = keccak256(encoded);\n  logger.debug(\"sigHash\", toBase64(digest), Ox(encoded));\n  return digest;\n};\nexport const renVMHashToBase64 = (txHash, v2) => {\n  // Type validation\n  assertType(\"string\", {\n    txHash\n  }); // Hex\n\n  if (/^(0x)?[0-9a-fA-Z]{64}$/.exec(txHash)) {\n    return (v2 ? toURLBase64 : toBase64)(fromHex(txHash));\n  } // Already base64. For v2, ensure it's in URL-base64 format.\n\n\n  return v2 ? toURLBase64(fromBase64(txHash)) : txHash;\n};\nexport const generateBurnTxHash = (selector, encodedID, logger = NullLogger) => {\n  // Type validation\n  assertType(\"string\", {\n    encodedID\n  });\n  const message = `txHash_${selector}_${encodedID}`;\n  const digest = keccak256(Buffer.from(message));\n  logger.debug(\"Burn txHash\", toBase64(digest), message);\n  return digest;\n};","map":{"version":3,"sources":["../../src/renVMHashes.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { NullLogger } from \"@renproject/interfaces\";\nimport { assertType } from \"./assert\";\nimport { fromBase64, fromHex, Ox, rawEncode, toBase64, toURLBase64, } from \"./common\";\nimport { keccak256 } from \"./hash\";\n// export const generateNHash = (tx: Tx): Buffer => {\n//     const encoded = rawEncode(\n//         [\"bytes32\", \"bytes32\"],\n//         [Ox(tx.hash), Ox(tx.args.n)],\n//     );\n//     return keccak256(encoded);\n// };\n/**\n * Hash the payloads associated with a RenVM cross-chain transaction.\n *\n * @param zip An array (or spread) of parameters with with types defined.\n */\nexport const generatePHash = (zip, logger = NullLogger) => {\n    // Check if they called as hashPayload([...]) instead of hashPayload(...)\n    const args = (Array.isArray(zip[0]) ? zip[0] : zip).filter((arg) => !arg.notInPayload);\n    const types = args.map((param) => param.type);\n    const values = args.map((param) => param.value);\n    const message = rawEncode(types, values);\n    const digest = keccak256(message);\n    logger.debug(\"pHash\", toBase64(digest), Ox(message), args);\n    return digest; // sha3 can accept a Buffer\n};\nexport const generateSHash = (selector) => {\n    const toSelector = selector.replace(/\\/.*To/, \"/to\");\n    return keccak256(Buffer.from(toSelector));\n};\nexport const generateGHash = (payload, to, tokenIdentifier, nonce, v2, logger = NullLogger) => {\n    // Type validation\n    assertType(\"Buffer\", { nonce });\n    assertType(\"string\", { to, token: tokenIdentifier });\n    const pHash = generatePHash(payload, logger);\n    const sHash = fromHex(tokenIdentifier);\n    const toBytes = fromHex(to);\n    const encoded = v2\n        ? Buffer.concat([pHash, sHash, toBytes, nonce])\n        : rawEncode([\"bytes32\", \"address\", \"address\", \"bytes32\"], [pHash, tokenIdentifier, to, nonce]);\n    const digest = keccak256(encoded);\n    logger.debug(\"gHash\", toBase64(digest), Ox(encoded));\n    return digest;\n};\nexport const generateNHash = (nonce, txid, txindex, v2, logger = NullLogger) => {\n    const encoded = v2\n        ? Buffer.concat([\n            nonce,\n            txid,\n            rawEncode([\"uint32\"], [txindex]).slice(-4),\n        ])\n        : rawEncode([\"bytes32\", \"bytes32\", \"uint32\"], [nonce, txid, txindex]);\n    const digest = keccak256(encoded);\n    logger.debug(\"nHash\", toBase64(digest), Ox(encoded));\n    return digest;\n};\nexport const generateSighash = (pHash, amount, to, tokenIdentifier, nonceHash, v2, logger = NullLogger) => {\n    // Type validation\n    assertType(\"string\", { to, tokenIdentifier });\n    assertType(\"Buffer\", { pHash, nonceHash });\n    const encoded = rawEncode([\n        \"bytes32\",\n        \"uint256\",\n        v2 ? \"bytes32\" : \"address\",\n        \"address\",\n        \"bytes32\",\n    ], [pHash, amount, Ox(tokenIdentifier), Ox(to), nonceHash]);\n    const digest = keccak256(encoded);\n    logger.debug(\"sigHash\", toBase64(digest), Ox(encoded));\n    return digest;\n};\nexport const renVMHashToBase64 = (txHash, v2) => {\n    // Type validation\n    assertType(\"string\", { txHash });\n    // Hex\n    if (/^(0x)?[0-9a-fA-Z]{64}$/.exec(txHash)) {\n        return (v2 ? toURLBase64 : toBase64)(fromHex(txHash));\n    }\n    // Already base64. For v2, ensure it's in URL-base64 format.\n    return v2 ? toURLBase64(fromBase64(txHash)) : txHash;\n};\nexport const generateBurnTxHash = (selector, encodedID, logger = NullLogger) => {\n    // Type validation\n    assertType(\"string\", { encodedID });\n    const message = `txHash_${selector}_${encodedID}`;\n    const digest = keccak256(Buffer.from(message));\n    logger.debug(\"Burn txHash\", toBase64(digest), message);\n    return digest;\n};\n//# sourceMappingURL=renVMHashes.js.map"]},"metadata":{},"sourceType":"module"}