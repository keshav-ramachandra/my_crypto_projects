{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { NullLogger } from \"@renproject/interfaces\";\nimport { assert, fixSignature, fromBase64, Ox, signatureToBuffer, toBase64 } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport { RenVMType } from \"./value\";\n\nconst decodeString = input => fromBase64(input).toString();\n\nconst decodeBytes = input => fromBase64(input);\n\nconst decodeNumber = input => new BigNumber(input);\n/**\n * Validate an argument returned from RenVM.\n *\n * @param name The expected name.\n * @param type The expected type.\n * @param arg The actual argument returned.\n */\n\n\nconst assertArgumentType = (name, type, arg) => {\n  assert(arg.type === type, `Expected argument ${name} of type ${type} but got ${arg.name} of type ${arg.type}`);\n  return arg.value;\n};\n\nconst assertAndDecodeBytes = (name, type, arg) => {\n  try {\n    return decodeBytes( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    assertArgumentType(name, type, arg));\n  } catch (error) {\n    error.message = `Unable to decode parameter ${name} with value ${String(arg.value)} (type ${typeof arg.value}): ${String(error.message)}`;\n    throw error;\n  }\n};\n\nconst assertAndDecodeNumber = (name, type, arg) => {\n  try {\n    return decodeNumber( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    assertArgumentType(name, type, arg));\n  } catch (error) {\n    error.message = `Unable to decode parameter ${name} with value ${String(arg.value)} (type ${typeof arg.value}): ${String(error.message)}`;\n    throw error;\n  }\n};\n\nconst assertAndDecodeAddress = (name, type, arg) => {\n  try {\n    return Ox( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    assertArgumentType(name, type, arg));\n  } catch (error) {\n    error.message = `Unable to decode parameter ${name} with value ${String(arg.value)} (type ${typeof arg.value}): ${String(error.message)}`;\n    throw error;\n  }\n};\n\nconst defaultPayload = {\n  name: \"p\",\n  type: RenVMType.ExtEthCompatPayload,\n  value: {\n    abi: \"W10=\",\n    value: \"\",\n    fn: \"\"\n  }\n};\n\nconst findField = (field, response) => {\n  for (const outField of response.tx.out || []) {\n    if (outField.name === field) {\n      return outField;\n    }\n  }\n\n  for (const outField of response.tx.autogen) {\n    if (outField.name === field) {\n      return outField;\n    }\n  }\n\n  for (const outField of response.tx.in) {\n    if (outField.name === field) {\n      return outField;\n    }\n  }\n\n  throw new Error(`Unable to find field ${field} in response from RenVM.`);\n};\n\nconst onError = (getP, defaultP) => {\n  try {\n    return getP();\n  } catch (error) {\n    return defaultP;\n  }\n};\n\nexport const unmarshalMintTx = (response, logger = NullLogger) => {\n  // Note: Numbers are decoded and re-encoded to ensure they are in the correct format.\n  const pRaw = assertArgumentType(\"p\", RenVMType.ExtEthCompatPayload, onError(() => findField(\"p\", response), defaultPayload));\n  const token = assertAndDecodeAddress(\"token\", RenVMType.ExtTypeEthCompatAddress, findField(\"token\", response));\n  const to = assertAndDecodeAddress(\"to\", RenVMType.ExtTypeEthCompatAddress, findField(\"to\", response));\n  const n = assertAndDecodeBytes(\"n\", RenVMType.B32, findField(\"n\", response));\n  const p = {\n    abi: JSON.parse(decodeString(pRaw.abi)),\n    value: decodeBytes(pRaw.value),\n    fn: decodeString(pRaw.fn)\n  };\n  const phash = assertAndDecodeBytes(\"phash\", RenVMType.B32, findField(\"phash\", response));\n  const ghash = assertAndDecodeBytes(\"ghash\", RenVMType.B32, findField(\"ghash\", response));\n  const nhash = assertAndDecodeBytes(\"nhash\", RenVMType.B32, findField(\"nhash\", response));\n  const amount = assertAndDecodeNumber(\"amount\", RenVMType.U256, findField(\"amount\", response)).toFixed();\n  const utxoRaw = assertArgumentType(\"utxo\", RenVMType.ExtTypeBtcCompatUTXO, findField(\"utxo\", response));\n  const sighash = assertAndDecodeBytes(\"sighash\", RenVMType.B32, findField(\"sighash\", response));\n  const utxo = {\n    txHash: Ox(decodeBytes(utxoRaw.txHash), {\n      prefix: \"\"\n    }),\n    vOut: parseInt(utxoRaw.vOut, 10),\n    scriptPubKey: utxoRaw.scriptPubKey ? Ox(decodeBytes(utxoRaw.scriptPubKey), {\n      prefix: \"\"\n    }) : \"\",\n    amount: decodeNumber(utxoRaw.amount).toFixed()\n  };\n  const out = {\n    sighash,\n    ghash,\n    nhash,\n    phash,\n    amount\n  };\n\n  if (response.tx.out) {\n    const [rArg, sArg, vArg] = [findField(\"r\", response), findField(\"s\", response), findField(\"v\", response)];\n    const r = rArg.type === RenVMType.B ? assertAndDecodeBytes(\"r\", RenVMType.B, rArg) : assertAndDecodeBytes(\"r\", RenVMType.B32, rArg);\n    const s = sArg.type === RenVMType.B ? assertAndDecodeBytes(\"s\", RenVMType.B, sArg) : assertAndDecodeBytes(\"s\", RenVMType.B32, sArg);\n    const v = vArg.type === RenVMType.B ? assertAndDecodeBytes(\"v\", RenVMType.B, vArg)[0] : assertAndDecodeNumber(\"v\", RenVMType.U8, vArg).toNumber();\n    const signature = signatureToBuffer(fixSignature(r, s, v, sighash, phash, amount, to, token, nhash, false, logger));\n    out.signature = signature; // r, s, v\n  }\n\n  return {\n    hash: toBase64(decodeBytes(response.tx.hash)),\n    txStatus: response.txStatus,\n    to: response.tx.to,\n    in: {\n      p,\n      token,\n      to,\n      n,\n      utxo\n    },\n    out\n  };\n};\nexport const unmarshalBurnTx = response => {\n  // TODO: Check that result is burn response.\n  // assert(\n  //     parseV1Selector(response.tx.to).from === Chain.Ethereum,\n  //     `Expected burn details but got back mint details (${response.tx.hash} - ${response.tx.to})`\n  // );\n  const [refArg, toArg, amountArg] = response.tx.in;\n  const ref = assertAndDecodeNumber(\"ref\", RenVMType.U64, refArg).toFixed();\n  const toRaw = assertArgumentType(\"to\", RenVMType.B, toArg);\n  let amount;\n\n  try {\n    amount = assertAndDecodeNumber(\"amount\", RenVMType.U256, amountArg).toFixed();\n  } catch (error) {\n    amount = assertAndDecodeNumber(\"amount\", RenVMType.U64, amountArg).toFixed();\n  }\n\n  const to = toRaw; // response.tx.to === Tokens.ZEC.Eth2Zec ?\n  //     utils.zec.addressFrom(toRaw) :\n  //     response.tx.to === Tokens.BCH.Eth2Bch ?\n  //         utils.bch.addressFrom(toRaw) :\n  //         utils.btc.addressFrom(toRaw);\n\n  return {\n    hash: toBase64(decodeBytes(response.tx.hash)),\n    to: response.tx.to,\n    in: {\n      ref,\n      to,\n      amount\n    },\n    txStatus: response.txStatus\n  };\n};\n\nconst unmarshalAssetFees = fees => {\n  const {\n    lock,\n    release\n  } = fees,\n        tokens = __rest(fees, [\"lock\", \"release\"]); // TODO: Fix type errors.\n\n\n  return Object.assign({\n    lock: decodeNumber(lock),\n    release: decodeNumber(release)\n  }, Object.keys(tokens).reduce((acc, token) => Object.assign(Object.assign({}, acc), {\n    [token]: {\n      mint: decodeNumber(fees[token].mint).toNumber(),\n      burn: decodeNumber(fees[token].burn).toNumber()\n    }\n  }), {}));\n};\n\nexport const unmarshalFees = response => {\n  const fees = {};\n\n  for (const key of Object.keys(response)) {\n    fees[key] = unmarshalAssetFees(response[key]);\n  }\n\n  return fees;\n};","map":{"version":3,"sources":["../../../src/v1/unmarshal.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,SAKI,UALJ,QAQO,wBARP;AASA,SACI,MADJ,EAEI,YAFJ,EAGI,UAHJ,EAII,EAJJ,EAKI,iBALJ,EAMI,QANJ,QAOO,mBAPP;AAQA,OAAO,SAAP,MAAsB,cAAtB;AAOA,SAAyB,SAAzB,QAA0C,SAA1C;;AAEA,MAAM,YAAY,GAAI,KAAD,IAAmB,UAAU,CAAC,KAAD,CAAV,CAAkB,QAAlB,EAAxC;;AACA,MAAM,WAAW,GAAI,KAAD,IAAmB,UAAU,CAAC,KAAD,CAAjD;;AACA,MAAM,YAAY,GAAI,KAAD,IAAmB,IAAI,SAAJ,CAAc,KAAd,CAAxC;AAEA;;;;;;AAMG;;;AACH,MAAM,kBAAkB,GAAG,CACvB,IADuB,EAEvB,IAFuB,EAGvB,GAHuB,KAQb;AACV,EAAA,MAAM,CACF,GAAG,CAAC,IAAJ,KAAa,IADX,EAEF,qBAAqB,IAAI,YAAY,IAAI,YAAY,GAAG,CAAC,IAAI,YAAY,GAAG,CAAC,IAAI,EAF/E,CAAN;AAIA,SAAO,GAAG,CAAC,KAAX;AACH,CAdD;;AAgBA,MAAM,oBAAoB,GAAG,CACzB,IADyB,EAEzB,IAFyB,EAGzB,GAHyB,KAQjB;AACR,MAAI;AACA,WAAO,WAAW,EACd;AACA,IAAA,kBAAkB,CAAU,IAAV,EAAuB,IAAvB,EAAoC,GAApC,CAFJ,CAAlB;AAIH,GALD,CAKE,OAAO,KAAP,EAAc;AACZ,IAAA,KAAK,CAAC,OAAN,GAAgB,8BAA8B,IAAI,eAAe,MAAM,CACnE,GAAG,CAAC,KAD+D,CAEtE,UAAU,OAAO,GAAG,CAAC,KAAK,MAAM,MAAM,CAAC,KAAK,CAAC,OAAP,CAAe,EAFtD;AAGA,UAAM,KAAN;AACH;AACJ,CApBD;;AAsBA,MAAM,qBAAqB,GAAG,CAC1B,IAD0B,EAE1B,IAF0B,EAG1B,GAH0B,KAQf;AACX,MAAI;AACA,WAAO,YAAY,EACf;AACA,IAAA,kBAAkB,CAAU,IAAV,EAAuB,IAAvB,EAAoC,GAApC,CAFH,CAAnB;AAIH,GALD,CAKE,OAAO,KAAP,EAAc;AACZ,IAAA,KAAK,CAAC,OAAN,GAAgB,8BAA8B,IAAI,eAAe,MAAM,CACnE,GAAG,CAAC,KAD+D,CAEtE,UAAU,OAAO,GAAG,CAAC,KAAK,MAAM,MAAM,CAAC,KAAK,CAAC,OAAP,CAAe,EAFtD;AAGA,UAAM,KAAN;AACH;AACJ,CApBD;;AAsBA,MAAM,sBAAsB,GAAG,CAC3B,IAD2B,EAE3B,IAF2B,EAG3B,GAH2B,KAQnB;AACR,MAAI;AACA,WAAO,EAAE,EACL;AACA,IAAA,kBAAkB,CAAU,IAAV,EAAuB,IAAvB,EAAoC,GAApC,CAFb,CAAT;AAIH,GALD,CAKE,OAAO,KAAP,EAAc;AACZ,IAAA,KAAK,CAAC,OAAN,GAAgB,8BAA8B,IAAI,eAAe,MAAM,CACnE,GAAG,CAAC,KAD+D,CAEtE,UAAU,OAAO,GAAG,CAAC,KAAK,MAAM,MAAM,CAAC,KAAK,CAAC,OAAP,CAAe,EAFtD;AAGA,UAAM,KAAN;AACH;AACJ,CApBD;;AAsBA,MAAM,cAAc,GAAyC;AACzD,EAAA,IAAI,EAAE,GADmD;AAEzD,EAAA,IAAI,EAAE,SAAS,CAAC,mBAFyC;AAGzD,EAAA,KAAK,EAAE;AACH,IAAA,GAAG,EAAE,MADF;AAEH,IAAA,KAAK,EAAE,EAFJ;AAGH,IAAA,EAAE,EAAE;AAHD;AAHkD,CAA7D;;AAUA,MAAM,SAAS,GAAG,CACd,KADc,EAEd,QAFc,KAGL;AACT,OAAK,MAAM,QAAX,IAAuB,QAAQ,CAAC,EAAT,CAAY,GAAZ,IAAmB,EAA1C,EAA8C;AAC1C,QAAI,QAAQ,CAAC,IAAT,KAAkB,KAAtB,EAA6B;AACzB,aAAO,QAAP;AACH;AACJ;;AAED,OAAK,MAAM,QAAX,IAAuB,QAAQ,CAAC,EAAT,CAAY,OAAnC,EAA4C;AACxC,QAAI,QAAQ,CAAC,IAAT,KAAkB,KAAtB,EAA6B;AACzB,aAAO,QAAP;AACH;AACJ;;AAED,OAAK,MAAM,QAAX,IAAuB,QAAQ,CAAC,EAAT,CAAY,EAAnC,EAAuC;AACnC,QAAI,QAAQ,CAAC,IAAT,KAAkB,KAAtB,EAA6B;AACzB,aAAO,QAAP;AACH;AACJ;;AAED,QAAM,IAAI,KAAJ,CAAU,wBAAwB,KAAK,0BAAvC,CAAN;AACH,CAvBD;;AAyBA,MAAM,OAAO,GAAG,CAAI,IAAJ,EAAmB,QAAnB,KAAkC;AAC9C,MAAI;AACA,WAAO,IAAI,EAAX;AACH,GAFD,CAEE,OAAO,KAAP,EAAc;AACZ,WAAO,QAAP;AACH;AACJ,CAND;;AAQA,OAAO,MAAM,eAAe,GAAG,CAC3B,QAD2B,EAE3B,MAAA,GAAiB,UAFU,KAGH;AACxB;AAUA,QAAM,IAAI,GAAG,kBAAkB,CAC3B,GAD2B,EAE3B,SAAS,CAAC,mBAFiB,EAG3B,OAAO,CAAC,MAAM,SAAS,CAAQ,GAAR,EAAa,QAAb,CAAhB,EAAwC,cAAxC,CAHoB,CAA/B;AAKA,QAAM,KAAK,GAAG,sBAAsB,CAChC,OADgC,EAEhC,SAAS,CAAC,uBAFsB,EAGhC,SAAS,CAAQ,OAAR,EAAiB,QAAjB,CAHuB,CAApC;AAKA,QAAM,EAAE,GAAG,sBAAsB,CAC7B,IAD6B,EAE7B,SAAS,CAAC,uBAFmB,EAG7B,SAAS,CAAQ,IAAR,EAAc,QAAd,CAHoB,CAAjC;AAKA,QAAM,CAAC,GAAG,oBAAoB,CAC1B,GAD0B,EAE1B,SAAS,CAAC,GAFgB,EAG1B,SAAS,CAAQ,GAAR,EAAa,QAAb,CAHiB,CAA9B;AAMA,QAAM,CAAC,GAAG;AACN,IAAA,GAAG,EAAE,IAAI,CAAC,KAAL,CAAW,YAAY,CAAC,IAAI,CAAC,GAAN,CAAvB,CADC;AAEN,IAAA,KAAK,EAAE,WAAW,CAAC,IAAI,CAAC,KAAN,CAFZ;AAGN,IAAA,EAAE,EAAE,YAAY,CAAC,IAAI,CAAC,EAAN;AAHV,GAAV;AAOA,QAAM,KAAK,GAAG,oBAAoB,CAC9B,OAD8B,EAE9B,SAAS,CAAC,GAFoB,EAG9B,SAAS,CAAa,OAAb,EAAsB,QAAtB,CAHqB,CAAlC;AAKA,QAAM,KAAK,GAAG,oBAAoB,CAC9B,OAD8B,EAE9B,SAAS,CAAC,GAFoB,EAG9B,SAAS,CAAa,OAAb,EAAsB,QAAtB,CAHqB,CAAlC;AAKA,QAAM,KAAK,GAAG,oBAAoB,CAC9B,OAD8B,EAE9B,SAAS,CAAC,GAFoB,EAG9B,SAAS,CAAa,OAAb,EAAsB,QAAtB,CAHqB,CAAlC;AAKA,QAAM,MAAM,GAAG,qBAAqB,CAChC,QADgC,EAEhC,SAAS,CAAC,IAFsB,EAGhC,SAAS,CAAa,QAAb,EAAuB,QAAvB,CAHuB,CAArB,CAIb,OAJa,EAAf;AAKA,QAAM,OAAO,GAAG,kBAAkB,CAC9B,MAD8B,EAE9B,SAAS,CAAC,oBAFoB,EAG9B,SAAS,CAAa,MAAb,EAAqB,QAArB,CAHqB,CAAlC;AAKA,QAAM,OAAO,GAAG,oBAAoB,CAChC,SADgC,EAEhC,SAAS,CAAC,GAFsB,EAGhC,SAAS,CAAa,SAAb,EAAwB,QAAxB,CAHuB,CAApC;AAMA,QAAM,IAAI,GAAG;AACT,IAAA,MAAM,EAAE,EAAE,CAAC,WAAW,CAAC,OAAO,CAAC,MAAT,CAAZ,EAA8B;AAAE,MAAA,MAAM,EAAE;AAAV,KAA9B,CADD;AAET,IAAA,IAAI,EAAE,QAAQ,CAAC,OAAO,CAAC,IAAT,EAAe,EAAf,CAFL;AAGT,IAAA,YAAY,EAAE,OAAO,CAAC,YAAR,GACR,EAAE,CAAC,WAAW,CAAC,OAAO,CAAC,YAAT,CAAZ,EAAoC;AAAE,MAAA,MAAM,EAAE;AAAV,KAApC,CADM,GAER,EALG;AAMT,IAAA,MAAM,EAAE,YAAY,CAAC,OAAO,CAAC,MAAT,CAAZ,CAA6B,OAA7B;AANC,GAAb;AAUA,QAAM,GAAG,GAAkC;AACvC,IAAA,OADuC;AAEvC,IAAA,KAFuC;AAGvC,IAAA,KAHuC;AAIvC,IAAA,KAJuC;AAKvC,IAAA;AALuC,GAA3C;;AAQA,MAAI,QAAQ,CAAC,EAAT,CAAY,GAAhB,EAAqB;AACjB,UAAM,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,IAAqB,CACvB,SAAS,CAAS,GAAT,EAAc,QAAd,CADc,EAEvB,SAAS,CAAS,GAAT,EAAc,QAAd,CAFc,EAGvB,SAAS,CAAS,GAAT,EAAc,QAAd,CAHc,CAA3B;AAKA,UAAM,CAAC,GACH,IAAI,CAAC,IAAL,KAAc,SAAS,CAAC,CAAxB,GACM,oBAAoB,CAAW,GAAX,EAAgB,SAAS,CAAC,CAA1B,EAA6B,IAA7B,CAD1B,GAEM,oBAAoB,CAAW,GAAX,EAAgB,SAAS,CAAC,GAA1B,EAA+B,IAA/B,CAH9B;AAIA,UAAM,CAAC,GACH,IAAI,CAAC,IAAL,KAAc,SAAS,CAAC,CAAxB,GACM,oBAAoB,CAAW,GAAX,EAAgB,SAAS,CAAC,CAA1B,EAA6B,IAA7B,CAD1B,GAEM,oBAAoB,CAAW,GAAX,EAAgB,SAAS,CAAC,GAA1B,EAA+B,IAA/B,CAH9B;AAIA,UAAM,CAAC,GACH,IAAI,CAAC,IAAL,KAAc,SAAS,CAAC,CAAxB,GACM,oBAAoB,CAAW,GAAX,EAAgB,SAAS,CAAC,CAA1B,EAA6B,IAA7B,CAApB,CAAuD,CAAvD,CADN,GAEM,qBAAqB,CACjB,GADiB,EAEjB,SAAS,CAAC,EAFO,EAGjB,IAHiB,CAArB,CAIE,QAJF,EAHV;AASA,UAAM,SAAS,GAAG,iBAAiB,CAC/B,YAAY,CACR,CADQ,EAER,CAFQ,EAGR,CAHQ,EAIR,OAJQ,EAKR,KALQ,EAMR,MANQ,EAOR,EAPQ,EAQR,KARQ,EASR,KATQ,EAUR,KAVQ,EAWR,MAXQ,CADmB,CAAnC;AAgBA,IAAA,GAAG,CAAC,SAAJ,GAAgB,SAAhB,CAvCiB,CAuCU;AAC9B;;AAED,SAAO;AACH,IAAA,IAAI,EAAE,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAT,CAAY,IAAb,CAAZ,CADX;AAEH,IAAA,QAAQ,EAAE,QAAQ,CAAC,QAFhB;AAGH,IAAA,EAAE,EAAE,QAAQ,CAAC,EAAT,CAAY,EAHb;AAIH,IAAA,EAAE,EAAE;AAAE,MAAA,CAAF;AAAK,MAAA,KAAL;AAAY,MAAA,EAAZ;AAAgB,MAAA,CAAhB;AAAmB,MAAA;AAAnB,KAJD;AAKH,IAAA;AALG,GAAP;AAOH,CA5IM;AA8IP,OAAO,MAAM,eAAe,GACxB,QAD2B,IAEA;AAC3B;AACA;AACA;AACA;AACA;AAEA,QAAM,CAAC,MAAD,EAAS,KAAT,EAAgB,SAAhB,IAA6B,QAAQ,CAAC,EAAT,CAAY,EAA/C;AACA,QAAM,GAAG,GAAG,qBAAqB,CAC7B,KAD6B,EAE7B,SAAS,CAAC,GAFmB,EAG7B,MAH6B,CAArB,CAIV,OAJU,EAAZ;AAKA,QAAM,KAAK,GAAG,kBAAkB,CAAe,IAAf,EAAqB,SAAS,CAAC,CAA/B,EAAkC,KAAlC,CAAhC;AACA,MAAI,MAAJ;;AACA,MAAI;AACA,IAAA,MAAM,GAAG,qBAAqB,CAC1B,QAD0B,EAE1B,SAAS,CAAC,IAFgB,EAG1B,SAH0B,CAArB,CAIP,OAJO,EAAT;AAKH,GAND,CAME,OAAO,KAAP,EAAc;AACZ,IAAA,MAAM,GAAG,qBAAqB,CAC1B,QAD0B,EAE1B,SAAS,CAAC,GAFgB,EAG1B,SAH0B,CAArB,CAIP,OAJO,EAAT;AAKH;;AAED,QAAM,EAAE,GAAG,KAAX,CA7B2B,CA8B3B;AACA;AACA;AACA;AACA;;AAEA,SAAO;AACH,IAAA,IAAI,EAAE,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAT,CAAY,IAAb,CAAZ,CADX;AAEH,IAAA,EAAE,EAAE,QAAQ,CAAC,EAAT,CAAY,EAFb;AAGH,IAAA,EAAE,EAAE;AAAE,MAAA,GAAF;AAAO,MAAA,EAAP;AAAW,MAAA;AAAX,KAHD;AAIH,IAAA,QAAQ,EAAE,QAAQ,CAAC;AAJhB,GAAP;AAMH,CA5CM;;AA8CP,MAAM,kBAAkB,GAAI,IAAD,IAA+B;AACtD,QAAM;AAAE,IAAA,IAAF;AAAQ,IAAA;AAAR,MAA+B,IAArC;AAAA,QAA0B,MAAM,GAAA,MAAA,CAAK,IAAL,EAA1B,CAAA,MAAA,EAAA,SAAA,CAA0B,CAAhC,CADsD,CAGtD;;;AACA,SAAO,MAAA,CAAA,MAAA,CAAA;AACH,IAAA,IAAI,EAAE,YAAY,CAAC,IAAD,CADf;AAEH,IAAA,OAAO,EAAE,YAAY,CAAC,OAAD;AAFlB,GAAA,EAGA,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,MAApB,CACC,CAAC,GAAD,EAAM,KAAN,KAAgB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACT,GADS,CAAA,EACN;AACN,KAAC,KAAD,GAAS;AACL,MAAA,IAAI,EAAE,YAAY,CAAC,IAAI,CAAC,KAAD,CAAJ,CAAY,IAAb,CAAZ,CAA+B,QAA/B,EADD;AAEL,MAAA,IAAI,EAAE,YAAY,CAAC,IAAI,CAAC,KAAD,CAAJ,CAAY,IAAb,CAAZ,CAA+B,QAA/B;AAFD;AADH,GADM,CADjB,EAQC,EARD,CAHA,CAAP;AAcH,CAlBD;;AAoBA,OAAO,MAAM,aAAa,GAAI,QAAD,IAA2C;AACpE,QAAM,IAAI,GAAG,EAAb;;AACA,OAAK,MAAM,GAAX,IAAkB,MAAM,CAAC,IAAP,CAAY,QAAZ,CAAlB,EAAyC;AACrC,IAAA,IAAI,CAAC,GAAD,CAAJ,GAAY,kBAAkB,CAAC,QAAQ,CAAC,GAAD,CAAT,CAA9B;AACH;;AACD,SAAO,IAAP;AACH,CANM","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { NullLogger, } from \"@renproject/interfaces\";\nimport { assert, fixSignature, fromBase64, Ox, signatureToBuffer, toBase64, } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport { RenVMType } from \"./value\";\nconst decodeString = (input) => fromBase64(input).toString();\nconst decodeBytes = (input) => fromBase64(input);\nconst decodeNumber = (input) => new BigNumber(input);\n/**\n * Validate an argument returned from RenVM.\n *\n * @param name The expected name.\n * @param type The expected type.\n * @param arg The actual argument returned.\n */\nconst assertArgumentType = (name, type, arg) => {\n    assert(arg.type === type, `Expected argument ${name} of type ${type} but got ${arg.name} of type ${arg.type}`);\n    return arg.value;\n};\nconst assertAndDecodeBytes = (name, type, arg) => {\n    try {\n        return decodeBytes(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        assertArgumentType(name, type, arg));\n    }\n    catch (error) {\n        error.message = `Unable to decode parameter ${name} with value ${String(arg.value)} (type ${typeof arg.value}): ${String(error.message)}`;\n        throw error;\n    }\n};\nconst assertAndDecodeNumber = (name, type, arg) => {\n    try {\n        return decodeNumber(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        assertArgumentType(name, type, arg));\n    }\n    catch (error) {\n        error.message = `Unable to decode parameter ${name} with value ${String(arg.value)} (type ${typeof arg.value}): ${String(error.message)}`;\n        throw error;\n    }\n};\nconst assertAndDecodeAddress = (name, type, arg) => {\n    try {\n        return Ox(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        assertArgumentType(name, type, arg));\n    }\n    catch (error) {\n        error.message = `Unable to decode parameter ${name} with value ${String(arg.value)} (type ${typeof arg.value}): ${String(error.message)}`;\n        throw error;\n    }\n};\nconst defaultPayload = {\n    name: \"p\",\n    type: RenVMType.ExtEthCompatPayload,\n    value: {\n        abi: \"W10=\",\n        value: \"\",\n        fn: \"\",\n    },\n};\nconst findField = (field, response) => {\n    for (const outField of response.tx.out || []) {\n        if (outField.name === field) {\n            return outField;\n        }\n    }\n    for (const outField of response.tx.autogen) {\n        if (outField.name === field) {\n            return outField;\n        }\n    }\n    for (const outField of response.tx.in) {\n        if (outField.name === field) {\n            return outField;\n        }\n    }\n    throw new Error(`Unable to find field ${field} in response from RenVM.`);\n};\nconst onError = (getP, defaultP) => {\n    try {\n        return getP();\n    }\n    catch (error) {\n        return defaultP;\n    }\n};\nexport const unmarshalMintTx = (response, logger = NullLogger) => {\n    // Note: Numbers are decoded and re-encoded to ensure they are in the correct format.\n    const pRaw = assertArgumentType(\"p\", RenVMType.ExtEthCompatPayload, onError(() => findField(\"p\", response), defaultPayload));\n    const token = assertAndDecodeAddress(\"token\", RenVMType.ExtTypeEthCompatAddress, findField(\"token\", response));\n    const to = assertAndDecodeAddress(\"to\", RenVMType.ExtTypeEthCompatAddress, findField(\"to\", response));\n    const n = assertAndDecodeBytes(\"n\", RenVMType.B32, findField(\"n\", response));\n    const p = {\n        abi: JSON.parse(decodeString(pRaw.abi)),\n        value: decodeBytes(pRaw.value),\n        fn: decodeString(pRaw.fn),\n    };\n    const phash = assertAndDecodeBytes(\"phash\", RenVMType.B32, findField(\"phash\", response));\n    const ghash = assertAndDecodeBytes(\"ghash\", RenVMType.B32, findField(\"ghash\", response));\n    const nhash = assertAndDecodeBytes(\"nhash\", RenVMType.B32, findField(\"nhash\", response));\n    const amount = assertAndDecodeNumber(\"amount\", RenVMType.U256, findField(\"amount\", response)).toFixed();\n    const utxoRaw = assertArgumentType(\"utxo\", RenVMType.ExtTypeBtcCompatUTXO, findField(\"utxo\", response));\n    const sighash = assertAndDecodeBytes(\"sighash\", RenVMType.B32, findField(\"sighash\", response));\n    const utxo = {\n        txHash: Ox(decodeBytes(utxoRaw.txHash), { prefix: \"\" }),\n        vOut: parseInt(utxoRaw.vOut, 10),\n        scriptPubKey: utxoRaw.scriptPubKey\n            ? Ox(decodeBytes(utxoRaw.scriptPubKey), { prefix: \"\" })\n            : \"\",\n        amount: decodeNumber(utxoRaw.amount).toFixed(),\n    };\n    const out = {\n        sighash,\n        ghash,\n        nhash,\n        phash,\n        amount,\n    };\n    if (response.tx.out) {\n        const [rArg, sArg, vArg] = [\n            findField(\"r\", response),\n            findField(\"s\", response),\n            findField(\"v\", response),\n        ];\n        const r = rArg.type === RenVMType.B\n            ? assertAndDecodeBytes(\"r\", RenVMType.B, rArg)\n            : assertAndDecodeBytes(\"r\", RenVMType.B32, rArg);\n        const s = sArg.type === RenVMType.B\n            ? assertAndDecodeBytes(\"s\", RenVMType.B, sArg)\n            : assertAndDecodeBytes(\"s\", RenVMType.B32, sArg);\n        const v = vArg.type === RenVMType.B\n            ? assertAndDecodeBytes(\"v\", RenVMType.B, vArg)[0]\n            : assertAndDecodeNumber(\"v\", RenVMType.U8, vArg).toNumber();\n        const signature = signatureToBuffer(fixSignature(r, s, v, sighash, phash, amount, to, token, nhash, false, logger));\n        out.signature = signature; // r, s, v\n    }\n    return {\n        hash: toBase64(decodeBytes(response.tx.hash)),\n        txStatus: response.txStatus,\n        to: response.tx.to,\n        in: { p, token, to, n, utxo },\n        out,\n    };\n};\nexport const unmarshalBurnTx = (response) => {\n    // TODO: Check that result is burn response.\n    // assert(\n    //     parseV1Selector(response.tx.to).from === Chain.Ethereum,\n    //     `Expected burn details but got back mint details (${response.tx.hash} - ${response.tx.to})`\n    // );\n    const [refArg, toArg, amountArg] = response.tx.in;\n    const ref = assertAndDecodeNumber(\"ref\", RenVMType.U64, refArg).toFixed();\n    const toRaw = assertArgumentType(\"to\", RenVMType.B, toArg);\n    let amount;\n    try {\n        amount = assertAndDecodeNumber(\"amount\", RenVMType.U256, amountArg).toFixed();\n    }\n    catch (error) {\n        amount = assertAndDecodeNumber(\"amount\", RenVMType.U64, amountArg).toFixed();\n    }\n    const to = toRaw;\n    // response.tx.to === Tokens.ZEC.Eth2Zec ?\n    //     utils.zec.addressFrom(toRaw) :\n    //     response.tx.to === Tokens.BCH.Eth2Bch ?\n    //         utils.bch.addressFrom(toRaw) :\n    //         utils.btc.addressFrom(toRaw);\n    return {\n        hash: toBase64(decodeBytes(response.tx.hash)),\n        to: response.tx.to,\n        in: { ref, to, amount },\n        txStatus: response.txStatus,\n    };\n};\nconst unmarshalAssetFees = (fees) => {\n    const { lock, release } = fees, tokens = __rest(fees, [\"lock\", \"release\"]);\n    // TODO: Fix type errors.\n    return Object.assign({ lock: decodeNumber(lock), release: decodeNumber(release) }, Object.keys(tokens).reduce((acc, token) => (Object.assign(Object.assign({}, acc), { [token]: {\n            mint: decodeNumber(fees[token].mint).toNumber(),\n            burn: decodeNumber(fees[token].burn).toNumber(),\n        } })), {}));\n};\nexport const unmarshalFees = (response) => {\n    const fees = {};\n    for (const key of Object.keys(response)) {\n        fees[key] = unmarshalAssetFees(response[key]);\n    }\n    return fees;\n};\n//# sourceMappingURL=unmarshal.js.map"]},"metadata":{},"sourceType":"module"}