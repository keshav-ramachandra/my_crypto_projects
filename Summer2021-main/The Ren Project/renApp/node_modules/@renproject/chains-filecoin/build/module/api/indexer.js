var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import Axios from "axios";
// See https://github.com/renproject/account-chain-indexer
const INDEXER_URL = `https://account-chain-indexer.herokuapp.com/graphql`;
export const fetchDeposits = (address, paramsFilterBase64 = "", network, _page = 0) => __awaiter(void 0, void 0, void 0, function* () {
    // const network = address.slice(0, 1) === "t" ? "testnet" : "mainnet";
    // TODO: Add network parameter.
    const query = `{
        messages: FilecoinTransactions(to: "${address}", params: "${paramsFilterBase64}") {
            cid
            params
            to
            nonce
            blocknumber
            amount
        }

        height: NetworkHeight(chain: "Filecoin", network: "${network}")
    }`;
    const response = (yield Axios.post(INDEXER_URL, { query })).data;
    if (response.errors && response.errors.length) {
        throw new Error(`Unable to fetch Filecoin messages: ${response.errors[0].message}`);
    }
    const { messages, height } = response.data;
    return messages
        .map((message) => {
        return {
            cid: message.cid,
            // to: message.to,
            amount: message.amount,
            params: message.params,
            confirmations: height ? height - height + 1 : 0,
            nonce: message.nonce,
        };
    })
        .filter((message) => !paramsFilterBase64 || message.params === paramsFilterBase64);
});
export const fetchMessage = (cid, network) => __awaiter(void 0, void 0, void 0, function* () {
    // TODO: Add network parameter.
    const query = `{
        messages: FilecoinTransactions(cid: "${cid}") {
            cid
            params
            to
            nonce
            blocknumber
            amount
        }

        height: NetworkHeight(chain: "Filecoin", network: "${network}")
    }`;
    const response = (yield Axios.post(INDEXER_URL, { query })).data;
    if (response.errors && response.errors.length) {
        throw new Error(`Unable to fetch Filecoin messages: ${response.errors[0].message}`);
    }
    const { messages, height } = response.data;
    if (messages.length === 0) {
        throw new Error(`Error fetching Filecoin transaction: message not found.`);
    }
    if (messages.length > 1) {
        console.warn(`More than 1 Filecoin transaction found with the same transaction ID.`);
    }
    const message = messages[0];
    return {
        cid: message.cid,
        // to: message.to,
        amount: message.amount,
        params: message.params,
        confirmations: message.blocknumber
            ? height - message.blocknumber + 1
            : 0,
        nonce: message.nonce,
    };
});
//# sourceMappingURL=indexer.js.map