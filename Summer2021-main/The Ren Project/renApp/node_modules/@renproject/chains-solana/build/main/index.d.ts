/// <reference types="node" />
import { BurnDetails, ContractCall, LockAndMintTransaction, Logger, MintChain, RenNetwork, RenNetworkDetails, RenNetworkString, OverwritableBurnAndReleaseParams, BurnPayloadConfig } from "@renproject/interfaces";
import { Connection, PublicKey, Transaction } from "@solana/web3.js";
import BigNumber from "bignumber.js";
import { EventEmitter } from "events";
import { SolNetworkConfig } from "./networks";
import { GatewayRegistryState } from "./layouts";
export declare type SolTransaction = string;
export declare type SolAddress = string;
export interface SolanaProvider {
    connection: Connection;
    wallet: {
        publicKey: PublicKey;
        signTransaction: (transaction: Transaction) => Promise<Transaction>;
    };
}
interface SolOptions {
    logger: Logger;
}
export declare class SolanaClass implements MintChain<SolTransaction, SolAddress, SolNetworkConfig> {
    static chain: "Solana";
    chain: "Solana";
    name: "Solana";
    renNetworkDetails: SolNetworkConfig;
    private _logger;
    burnPayloadConfig: BurnPayloadConfig;
    provider: SolanaProvider;
    constructor(provider: SolanaProvider, renNetwork?: RenNetwork | RenNetworkString | RenNetworkDetails | SolNetworkConfig, options?: SolOptions);
    static utils: {
        resolveChainNetwork: (renNetwork: SolNetworkConfig | RenNetwork | RenNetworkDetails | "mainnet" | "testnet" | "mainnet-v0.3" | "testnet-v0.3" | "devnet-v0.3" | "localnet") => SolNetworkConfig;
        /**
         * A Solana address is a base58-encoded 32-byte ed25519 public key.
         */
        addressIsValid: (address: string) => boolean;
        /**
         * A Solana transaction's ID is a base58-encoded 64-byte signature.
         */
        transactionIsValid: (transaction: string) => boolean;
        addressExplorerLink: (address: SolAddress, network: RenNetwork | RenNetworkString | RenNetworkDetails | SolNetworkConfig) => string;
        transactionExplorerLink: (transaction: SolTransaction, network?: RenNetwork | RenNetworkString | RenNetworkDetails | SolNetworkConfig) => string;
    };
    utils: any;
    /**
     * Should be set by `constructor` or `initialize`.
     */
    renNetwork?: RenNetworkDetails;
    gatewayRegistryData?: GatewayRegistryState;
    _initialized?: Promise<true>;
    /**
     * `initialize` allows RenJS to pass in parameters after the user has
     * initialized the Chain. This allows the user to pass in network
     * parameters such as the network only once.
     *
     * If the Chain's constructor has an optional network parameter and the
     * user has explicitly initialized it, the Chain should ignore the
     * network passed in to `initialize`. This is to allow different network
     * combinations, such as working with testnet Bitcoin and a local Ethereum
     * chain - whereas the default `testnet` configuration would use testnet
     * Bitcoin and Ethereum's Kovan testnet.
     */
    initialize: (network: RenNetwork | RenNetworkString | RenNetworkDetails) => Promise<this>;
    waitForInitialization(): Promise<true>;
    withProvider: (provider: any) => this;
    assetIsNative: (asset: string) => boolean;
    /**
     * `assetIsSupported` should return true if the the asset is native to the
     * chain or if the asset can be minted onto the chain.
     *
     * ```ts
     * ethereum.assetIsSupported = asset => asset === "ETH" || asset === "BTC" || ...;
     * ```
     */
    assetIsSupported: (asset: string) => Promise<boolean>;
    assetDecimals: (asset: string) => Promise<number>;
    transactionID: (transaction: SolTransaction) => string;
    transactionConfidence: (transaction: SolTransaction) => Promise<{
        current: number;
        target: number;
    }>;
    transactionRPCFormat: (transaction: SolTransaction) => {
        txid: Buffer;
        txindex: string;
    };
    transactionRPCTxidFromID: (transactionID: string) => Buffer;
    transactionIDFromRPCFormat: (txid: string | Buffer, txindex: string) => string;
    transactionFromRPCFormat: (txid: string | Buffer, _txindex: string, _reversed?: boolean | undefined) => string;
    /**
     * @deprecated Renamed to `transactionFromRPCFormat`.
     * Will be removed in 3.0.0.
     */
    transactionFromID: (txid: string | Buffer, _txindex: string, _reversed?: boolean | undefined) => string;
    resolveTokenGatewayContract: (asset: string) => string;
    getSPLTokenPubkey(asset: string): Promise<PublicKey>;
    constructRenVMMsg: (p_hash: Buffer, amount: string, token: Buffer, to: string, n_hash: Buffer) => Buffer[];
    /**
     * `submitMint` should take the completed mint transaction from RenVM and
     * submit its signature to the mint chain to finalize the mint.
     */
    submitMint: (asset: string, contractCalls: ContractCall[], mintTx: LockAndMintTransaction, eventEmitter: EventEmitter) => Promise<string>;
    findTransactionByDepositDetails: (asset: string, sHash: Buffer, nHash: Buffer, pHash: Buffer, to: string, amount: string) => Promise<string | undefined>;
    /**
     * Fetch the mint and burn fees for an asset.
     */
    getFees(_asset: string): {
        burn: number;
        mint: number;
    };
    /**
     * Fetch the addresses' balance of the asset's representation on the chain.
     */
    getBalance(asset: string, address: SolAddress): Promise<BigNumber>;
    getMintParams: (asset: string) => Promise<Pick<Pick<Partial<import("@renproject/interfaces").LockAndMintParams<any, import("@renproject/interfaces").DepositCommon<any>, any, any, any>>, "from" | "asset" | "txHash" | "nonce" | "tags" | "contractCalls">, "asset" | "txHash" | "nonce" | "tags" | "contractCalls">>;
    Account({ amount }: {
        amount: string | BigNumber;
    }): this;
    _getParams: ((burnPayload: string) => OverwritableBurnAndReleaseParams) | undefined;
    getBurnParams: (_asset: string, burnPayload?: string | undefined) => Pick<Pick<Partial<import("@renproject/interfaces").BurnAndReleaseParams<any, import("@renproject/interfaces").DepositCommon<any>, any, any, any>>, "from" | "asset" | "txHash" | "nonce" | "tags" | "contractCalls" | "transaction" | "burnNonce">, "asset" | "txHash" | "nonce" | "tags" | "contractCalls" | "transaction" | "burnNonce"> | undefined;
    /**
     * Read a burn reference from an Ethereum transaction - or submit a
     * transaction first if the transaction details have been provided.
     */
    findBurnTransaction: (asset: string, burn: {
        transaction?: SolTransaction;
        burnNonce?: Buffer | string | number;
        contractCalls?: ContractCall[];
    }, eventEmitter: EventEmitter, logger: Logger, _networkDelay?: number | undefined) => Promise<BurnDetails<string>>;
    getAssociatedTokenAccount(asset: string): Promise<false | PublicKey>;
    createAssociatedTokenAccount(asset: string): Promise<string>;
}
export declare type Solana = SolanaClass;
export declare const Solana: import("@renproject/utils").CallableConstructor<typeof SolanaClass>;
export {};
