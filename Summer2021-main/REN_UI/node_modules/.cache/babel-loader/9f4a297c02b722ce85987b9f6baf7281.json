{"ast":null,"code":"import { createSlice, nanoid, createAsyncThunk } from '@reduxjs/toolkit';\nimport controller from '../controller';\nimport web3 from './../web3';\nconst initialState = {\n  balance: 0,\n  status: 'idle',\n  error: '',\n  currentNode: 0,\n  user: ''\n};\n\nfunction getAccounts(callback) {\n  web3.eth.getAccounts((error, result) => {\n    if (error) {\n      console.log(error);\n    } else {\n      callback(result);\n    }\n  });\n}\n\nexport const getUserAsync = createAsyncThunk('node/getUserAsync', async () => {\n  if (window.ethereum) {\n    await window.ethereum.enable();\n  }\n\n  getAccounts(function (result) {\n    console.log(\"user is jj\", result[0]);\n    return result[0];\n  });\n});\nexport const fetchBalanceAsync = createAsyncThunk('node/fetchBalanceAsync', async () => {\n  const response = await controller.methods.getCumulativeNodeDeposit(initialState.currentNode).call();\n  return response;\n});\nexport const stakeRenAsync = createAsyncThunk('node/stakeRenAsync', async () => {\n  const response = await controller.methods.stakeRen(0, 0).call();\n  return response;\n});\nexport const createNodeAsync = createAsyncThunk('node/createNodeAsync', async () => {\n  const response = await controller.methods.createNode().send();\n  return response;\n});\nexport const getNodeAsync = createAsyncThunk('node/getNodeAsync', async () => {\n  const response = await controller.nodeCount.call();\n  return response;\n});\nconst nodeSlice = createSlice({\n  name: 'node',\n  initialState,\n  reducers: {// omit existing reducers here\n  },\n  extraReducers: {\n    [fetchBalanceAsync.pending]: (state, action) => {\n      state.status = 'loading';\n    },\n    [fetchBalanceAsync.fulfilled]: (state, action) => {\n      state.status = 'succeeded'; // Add any fetched posts to the array\n\n      console.log(\"payload is\", action.payload);\n      state.balance = action.payload;\n    },\n    [fetchBalanceAsync.rejected]: (state, action) => {\n      state.status = 'failed';\n      state.error = action.error.message;\n    },\n    [stakeRenAsync.pending]: (state, action) => {\n      state.status = 'depositing';\n    },\n    [stakeRenAsync.fulfilled]: (state, action) => {\n      state.status = 'deposited'; // Add any fetched posts to the array\n\n      console.log(\"deposited\");\n    },\n    [stakeRenAsync.rejected]: (state, action) => {\n      state.status = 'Node is full';\n      state.error = action.error.message;\n    },\n    [createNodeAsync.pending]: (state, action) => {\n      state.status = 'creating';\n    },\n    [createNodeAsync.fulfilled]: (state, action) => {\n      state.status = 'created'; // Add any fetched posts to the array\n\n      console.log(\"node created\");\n    },\n    [createNodeAsync.rejected]: (state, action) => {\n      state.status = 'Node could not be created';\n      state.error = action.error.message;\n    },\n    [getNodeAsync.pending]: (state, action) => {\n      state.status = 'fetching node';\n    },\n    [getNodeAsync.fulfilled]: (state, action) => {\n      state.status = 'fetched'; // Add any fetched posts to the array\n\n      console.log(\"payload is\", action.payload);\n      state.currentNode = parseInt(action.payload) - 1;\n    },\n    [getNodeAsync.rejected]: (state, action) => {\n      state.status = 'Node could not be fetched';\n      state.error = action.error.message;\n    },\n    [getUserAsync.pending]: (state, action) => {\n      state.status = 'fetching user';\n    },\n    [getUserAsync.fulfilled]: (state, action) => {\n      state.status = 'fetched'; // Add any fetched posts to the array\n\n      console.log(\"user is\", action.payload);\n      state.user = action.payload;\n    },\n    [getUserAsync.rejected]: (state, action) => {\n      state.status = 'User could not be fetched';\n      state.error = action.error.message;\n    }\n  }\n}); //export const { fetchBalance } = nodeSlice.actions;\n\nexport default nodeSlice.reducer;","map":{"version":3,"sources":["/home/kesha/Videos/my-app/src/features/nodeUpdater/nodeSlice.js"],"names":["createSlice","nanoid","createAsyncThunk","controller","web3","initialState","balance","status","error","currentNode","user","getAccounts","callback","eth","result","console","log","getUserAsync","window","ethereum","enable","fetchBalanceAsync","response","methods","getCumulativeNodeDeposit","call","stakeRenAsync","stakeRen","createNodeAsync","createNode","send","getNodeAsync","nodeCount","nodeSlice","name","reducers","extraReducers","pending","state","action","fulfilled","payload","rejected","message","parseInt","reducer"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,MAAtB,EAA8BC,gBAA9B,QAAsD,kBAAtD;AACA,OAAOC,UAAP,MAAuB,eAAvB;AACA,OAAOC,IAAP,MAAiB,WAAjB;AAEA,MAAMC,YAAY,GAAG;AACnBC,EAAAA,OAAO,EAAE,CADU;AAEnBC,EAAAA,MAAM,EAAC,MAFY;AAGnBC,EAAAA,KAAK,EAAC,EAHa;AAInBC,EAAAA,WAAW,EAAE,CAJM;AAKnBC,EAAAA,IAAI,EAAC;AALc,CAArB;;AAUA,SAASC,WAAT,CAAqBC,QAArB,EAA+B;AAC3BR,EAAAA,IAAI,CAACS,GAAL,CAASF,WAAT,CAAqB,CAACH,KAAD,EAAOM,MAAP,KAAkB;AACnC,QAAIN,KAAJ,EAAW;AACPO,MAAAA,OAAO,CAACC,GAAR,CAAYR,KAAZ;AACH,KAFD,MAEO;AACHI,MAAAA,QAAQ,CAACE,MAAD,CAAR;AACH;AACJ,GAND;AAOH;;AAKD,OAAO,MAAMG,YAAY,GAAGf,gBAAgB,CAAC,mBAAD,EAAsB,YAAY;AAC5E,MAAGgB,MAAM,CAACC,QAAV,EAAoB;AAClB,UAAMD,MAAM,CAACC,QAAP,CAAgBC,MAAhB,EAAN;AACD;;AACDT,EAAAA,WAAW,CAAC,UAASG,MAAT,EAAiB;AAC3BC,IAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAAyBF,MAAM,CAAC,CAAD,CAA/B;AACC,WAAOA,MAAM,CAAC,CAAD,CAAb;AACF,GAHU,CAAX;AAKD,CAT2C,CAArC;AAYP,OAAO,MAAMO,iBAAiB,GAAGnB,gBAAgB,CAAC,wBAAD,EAA2B,YAAY;AACtF,QAAMoB,QAAQ,GAAG,MAAMnB,UAAU,CAACoB,OAAX,CAAmBC,wBAAnB,CAA4CnB,YAAY,CAACI,WAAzD,EAAsEgB,IAAtE,EAAvB;AACA,SAAOH,QAAP;AACD,CAHgD,CAA1C;AAMP,OAAO,MAAMI,aAAa,GAAGxB,gBAAgB,CAAC,oBAAD,EAAuB,YAAY;AAC9E,QAAMoB,QAAQ,GAAG,MAAMnB,UAAU,CAACoB,OAAX,CAAmBI,QAAnB,CAA4B,CAA5B,EAA8B,CAA9B,EAAiCF,IAAjC,EAAvB;AACA,SAAOH,QAAP;AACD,CAH4C,CAAtC;AAMP,OAAO,MAAMM,eAAe,GAAG1B,gBAAgB,CAAC,sBAAD,EAAyB,YAAY;AAClF,QAAMoB,QAAQ,GAAG,MAAMnB,UAAU,CAACoB,OAAX,CAAmBM,UAAnB,GAAgCC,IAAhC,EAAvB;AAEA,SAAOR,QAAP;AACD,CAJ8C,CAAxC;AAMP,OAAO,MAAMS,YAAY,GAAG7B,gBAAgB,CAAC,mBAAD,EAAsB,YAAY;AAC5E,QAAMoB,QAAQ,GAAG,MAAMnB,UAAU,CAAC6B,SAAX,CAAqBP,IAArB,EAAvB;AACA,SAAOH,QAAP;AACD,CAH2C,CAArC;AAMP,MAAMW,SAAS,GAAGjC,WAAW,CAAC;AAC1BkC,EAAAA,IAAI,EAAE,MADoB;AAE1B7B,EAAAA,YAF0B;AAG1B8B,EAAAA,QAAQ,EAAE,CACR;AADQ,GAHgB;AAM1BC,EAAAA,aAAa,EAAE;AACb,KAACf,iBAAiB,CAACgB,OAAnB,GAA6B,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC9CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,SAAf;AACD,KAHY;AAIb,KAACc,iBAAiB,CAACmB,SAAnB,GAA+B,CAACF,KAAD,EAAQC,MAAR,KAAmB;AAChDD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,WAAf,CADgD,CAEhD;;AACAQ,MAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BuB,MAAM,CAACE,OAAjC;AACAH,MAAAA,KAAK,CAAChC,OAAN,GAAgBiC,MAAM,CAACE,OAAvB;AACD,KATY;AAUb,KAACpB,iBAAiB,CAACqB,QAAnB,GAA8B,CAACJ,KAAD,EAAQC,MAAR,KAAmB;AAC/CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,QAAf;AACA+B,MAAAA,KAAK,CAAC9B,KAAN,GAAc+B,MAAM,CAAC/B,KAAP,CAAamC,OAA3B;AACD,KAbY;AAcZ,KAACjB,aAAa,CAACW,OAAf,GAAyB,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC3CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,YAAf;AACD,KAhBY;AAiBb,KAACmB,aAAa,CAACc,SAAf,GAA2B,CAACF,KAAD,EAAQC,MAAR,KAAmB;AAC5CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,WAAf,CAD4C,CAE5C;;AACAQ,MAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;AACD,KArBY;AAsBb,KAACU,aAAa,CAACgB,QAAf,GAA0B,CAACJ,KAAD,EAAQC,MAAR,KAAmB;AAC3CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,cAAf;AACA+B,MAAAA,KAAK,CAAC9B,KAAN,GAAc+B,MAAM,CAAC/B,KAAP,CAAamC,OAA3B;AACD,KAzBY;AA0BZ,KAACf,eAAe,CAACS,OAAjB,GAA2B,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC7CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,UAAf;AACD,KA5BY;AA6Bb,KAACqB,eAAe,CAACY,SAAjB,GAA6B,CAACF,KAAD,EAAQC,MAAR,KAAmB;AAC9CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,SAAf,CAD8C,CAE9C;;AACAQ,MAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AACD,KAjCY;AAkCb,KAACY,eAAe,CAACc,QAAjB,GAA4B,CAACJ,KAAD,EAAQC,MAAR,KAAmB;AAC7CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,2BAAf;AACA+B,MAAAA,KAAK,CAAC9B,KAAN,GAAc+B,MAAM,CAAC/B,KAAP,CAAamC,OAA3B;AACD,KArCY;AAsCb,KAACZ,YAAY,CAACM,OAAd,GAAwB,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACzCD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,eAAf;AACD,KAxCY;AAyCb,KAACwB,YAAY,CAACS,SAAd,GAA0B,CAACF,KAAD,EAAQC,MAAR,KAAmB;AAC3CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,SAAf,CAD2C,CAE3C;;AACAQ,MAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BuB,MAAM,CAACE,OAAjC;AACAH,MAAAA,KAAK,CAAC7B,WAAN,GAAoBmC,QAAQ,CAACL,MAAM,CAACE,OAAR,CAAR,GAA2B,CAA/C;AACD,KA9CY;AA+Cb,KAACV,YAAY,CAACW,QAAd,GAAyB,CAACJ,KAAD,EAAQC,MAAR,KAAmB;AAC1CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,2BAAf;AACA+B,MAAAA,KAAK,CAAC9B,KAAN,GAAc+B,MAAM,CAAC/B,KAAP,CAAamC,OAA3B;AACD,KAlDY;AAmDZ,KAAC1B,YAAY,CAACoB,OAAd,GAAwB,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC1CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,eAAf;AACD,KArDY;AAsDb,KAACU,YAAY,CAACuB,SAAd,GAA0B,CAACF,KAAD,EAAQC,MAAR,KAAmB;AAC3CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,SAAf,CAD2C,CAE3C;;AACAQ,MAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBuB,MAAM,CAACE,OAA9B;AACAH,MAAAA,KAAK,CAAC5B,IAAN,GAAa6B,MAAM,CAACE,OAApB;AACD,KA3DY;AA4Db,KAACxB,YAAY,CAACyB,QAAd,GAAyB,CAACJ,KAAD,EAAQC,MAAR,KAAmB;AAC1CD,MAAAA,KAAK,CAAC/B,MAAN,GAAe,2BAAf;AACA+B,MAAAA,KAAK,CAAC9B,KAAN,GAAc+B,MAAM,CAAC/B,KAAP,CAAamC,OAA3B;AACD;AA/DY;AANW,CAAD,CAA7B,C,CAyEE;;AAEA,eAAeV,SAAS,CAACY,OAAzB","sourcesContent":["import { createSlice, nanoid, createAsyncThunk } from '@reduxjs/toolkit'\nimport controller from '../controller'\nimport web3 from './../web3'\n\nconst initialState = {\n  balance: 0,\n  status:'idle',\n  error:'',\n  currentNode: 0,\n  user:''\n}\n\n\n\nfunction getAccounts(callback) {\n    web3.eth.getAccounts((error,result) => {\n        if (error) {\n            console.log(error);\n        } else {\n            callback(result);\n        }\n    });\n}\n\n\n\n\nexport const getUserAsync = createAsyncThunk('node/getUserAsync', async () => {\n  if(window.ethereum) {\n    await window.ethereum.enable();\n  }\n  getAccounts(function(result) {\n    console.log(\"user is jj\",result[0]);\n     return result[0];\n  });\n \n})\n\n\nexport const fetchBalanceAsync = createAsyncThunk('node/fetchBalanceAsync', async () => {\n  const response = await controller.methods.getCumulativeNodeDeposit(initialState.currentNode).call();\n  return response;\n})\n\n\nexport const stakeRenAsync = createAsyncThunk('node/stakeRenAsync', async () => {\n  const response = await controller.methods.stakeRen(0,0).call();\n  return response;\n})\n\n\nexport const createNodeAsync = createAsyncThunk('node/createNodeAsync', async () => {\n  const response = await controller.methods.createNode().send();\n\n  return response;\n})\n\nexport const getNodeAsync = createAsyncThunk('node/getNodeAsync', async () => {\n  const response = await controller.nodeCount.call();\n  return response;\n})\n\n\nconst nodeSlice = createSlice({\n    name: 'node',\n    initialState,\n    reducers: {\n      // omit existing reducers here\n    },\n    extraReducers: {\n      [fetchBalanceAsync.pending]: (state, action) => {\n        state.status = 'loading'\n      },\n      [fetchBalanceAsync.fulfilled]: (state, action) => {\n        state.status = 'succeeded';\n        // Add any fetched posts to the array\n        console.log(\"payload is\", action.payload);\n        state.balance = action.payload;\n      },\n      [fetchBalanceAsync.rejected]: (state, action) => {\n        state.status = 'failed';\n        state.error = action.error.message\n      },\n       [stakeRenAsync.pending]: (state, action) => {\n        state.status = 'depositing'\n      },\n      [stakeRenAsync.fulfilled]: (state, action) => {\n        state.status = 'deposited';\n        // Add any fetched posts to the array\n        console.log(\"deposited\");\n      },\n      [stakeRenAsync.rejected]: (state, action) => {\n        state.status = 'Node is full';\n        state.error = action.error.message\n      },\n       [createNodeAsync.pending]: (state, action) => {\n        state.status = 'creating'\n      },\n      [createNodeAsync.fulfilled]: (state, action) => {\n        state.status = 'created';\n        // Add any fetched posts to the array\n        console.log(\"node created\");\n      },\n      [createNodeAsync.rejected]: (state, action) => {\n        state.status = 'Node could not be created';\n        state.error = action.error.message;\n      },\n      [getNodeAsync.pending]: (state, action) => {\n        state.status = 'fetching node'\n      },\n      [getNodeAsync.fulfilled]: (state, action) => {\n        state.status = 'fetched';\n        // Add any fetched posts to the array\n        console.log(\"payload is\", action.payload);\n        state.currentNode = parseInt(action.payload) - 1;\n      },\n      [getNodeAsync.rejected]: (state, action) => {\n        state.status = 'Node could not be fetched'\n        state.error = action.error.message\n      },\n       [getUserAsync.pending]: (state, action) => {\n        state.status = 'fetching user'\n      },\n      [getUserAsync.fulfilled]: (state, action) => {\n        state.status = 'fetched';\n        // Add any fetched posts to the array\n        console.log(\"user is\", action.payload);\n        state.user = action.payload;\n      },\n      [getUserAsync.rejected]: (state, action) => {\n        state.status = 'User could not be fetched';\n        state.error = action.error.message\n      }\n    }\n  })\n\n  //export const { fetchBalance } = nodeSlice.actions;\n\n  export default nodeSlice.reducer"]},"metadata":{},"sourceType":"module"}