{"ast":null,"code":"import { createSlice, nanoid, createAsyncThunk } from '@reduxjs/toolkit';\nimport controller from '../controller';\nimport web3 from './../web3';\nimport store from './../../app/store';\nexport const getUserAsync = createAsyncThunk('node/getUserAsync', async () => {\n  const acts = await web3.eth.getAccounts();\n  return acts[0];\n});\nexport const getBalanceAsync = createAsyncThunk('node/getBalanceAsync', async _nodeId => {\n  const response = await controller.methods.getCumulativeNodeDeposit(_nodeId).call();\n  return response;\n});\nexport const stakeRenAsync = createAsyncThunk('node/stakeRenAsync', async (_amount, _nodeId, _sender) => {\n  const response = await controller.methods.stakeRen(_amount, _nodeId).send({\n    from: _sender\n  });\n  return response;\n});\nexport const createNodeAsync = createAsyncThunk('node/createNodeAsync', async () => {\n  const response = await controller.methods.createNode().send();\n  return response;\n});\nexport const getNodeAsync = createAsyncThunk('node/getNodeAsync', async () => {\n  const response = await controller.methods.nodeCount().call();\n  return parseInt(response) - 1;\n});\nexport const getDepositStatusAsync = createAsyncThunk('node/getDepositStatusAsync', async () => {\n  const currentNodeBalance = getBalanceAsync(getNodeAsync());\n\n  if (parseInt(currentNodeBalance) == 50000) {\n    return 'full';\n  } else {\n    return 'accepting';\n  }\n});\nexport const updateNodeStats = createAsyncThunk('node/updateNodeStats', async () => {\n  const response = await controller.methods.nodeCount().call();\n  const nodeId = parseInt(response) - 1;\n  const nodeBalance = await controller.methods.getCumulativeNodeDeposit(nodeId).call();\n  let status;\n\n  if (parseInt(nodeBalance) == 50000) {\n    status = 'full';\n  } else {\n    status = 'accepting';\n  }\n\n  return {\n    nodeId: nodeId,\n    nodeBalance: nodeBalance,\n    status: status\n  };\n});\nexport const isOwner = createAsyncThunk('node/isOwner', async _user => {\n  const response = await controller.methods.owner().call();\n  const acts = await web3.eth.getAccounts();\n\n  if (response == acts[0]) {\n    return 'yes';\n  } else {\n    return 'no';\n  }\n});\nconst nodeSlice = createSlice({\n  name: 'node',\n  initialState: {\n    balance: -1,\n    status: 'idle',\n    error: '',\n    currentNode: -1,\n    user: '',\n    owner: false,\n    depositStatus: 'full'\n  },\n  reducers: {// omit existing reducers here\n  },\n  extraReducers: builder => {\n    // Add reducers for additional action types here, and handle loading state as needed\n    builder.addCase(getUserAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.status = 'succeeded';\n      state.user = action.payload;\n    }).addCase(getBalanceAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.status = 'succeeded';\n      state.balance = action.payload;\n    }).addCase(getNodeAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.status = 'succeeded';\n      state.currentNode = action.payload;\n    }).addCase(getDepositStatusAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.status = 'succeeded';\n      state.depositStatus = action.payload;\n    }).addCase(updateNodeStats.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.depositStatus = action.payload.status;\n      state.balance = action.payload.nodeBalance;\n      state.currentNode = action.payload.nodeId;\n      state.status = 'func';\n    }).addCase(isOwner.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.owner = action.payload;\n    }).addCase(createNodeAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      if (Boolean(action.payload) == true) {\n        state.currentNode = parseInt(state.currentNode) + 1;\n        state.balance = 0;\n        state.depositStatus = 'accepting';\n      } else {\n        state.error = 'err';\n      }\n    });\n  }\n});\nexport default nodeSlice.reducer;","map":{"version":3,"sources":["/home/kesha/Videos/my-app/src/features/nodeUpdater/nodeSlice.js"],"names":["createSlice","nanoid","createAsyncThunk","controller","web3","store","getUserAsync","acts","eth","getAccounts","getBalanceAsync","_nodeId","response","methods","getCumulativeNodeDeposit","call","stakeRenAsync","_amount","_sender","stakeRen","send","from","createNodeAsync","createNode","getNodeAsync","nodeCount","parseInt","getDepositStatusAsync","currentNodeBalance","updateNodeStats","nodeId","nodeBalance","status","isOwner","_user","owner","nodeSlice","name","initialState","balance","error","currentNode","user","depositStatus","reducers","extraReducers","builder","addCase","fulfilled","state","action","payload","Boolean","reducer"],"mappings":"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","sourcesContent":["import { createSlice, nanoid, createAsyncThunk } from '@reduxjs/toolkit'\nimport controller from '../controller'\nimport web3 from './../web3'\nimport store from './../../app/store'\n\n\n\n\nexport const getUserAsync = createAsyncThunk('node/getUserAsync', async () => {\n  const acts = await web3.eth.getAccounts(); \n  return acts[0];\n})\n\n\nexport const getBalanceAsync = createAsyncThunk('node/getBalanceAsync', async (_nodeId) => {\n  const response = await controller.methods.getCumulativeNodeDeposit(_nodeId).call();\n  return response;\n})\n\n\nexport const stakeRenAsync = createAsyncThunk('node/stakeRenAsync', async (_amount, _nodeId, _sender) => {\n  const response = await controller.methods.stakeRen(_amount,_nodeId).send({from: _sender});\n  return response;\n})\n\n\nexport const createNodeAsync = createAsyncThunk('node/createNodeAsync', async () => {\n  const response = await controller.methods.createNode().send();\n  return response;\n})\n\nexport const getNodeAsync = createAsyncThunk('node/getNodeAsync', async () => {\n  const response = await controller.methods.nodeCount().call();\n  return parseInt(response)-1;\n})\n\nexport const getDepositStatusAsync = createAsyncThunk('node/getDepositStatusAsync',async() => {\n  const currentNodeBalance = getBalanceAsync(getNodeAsync());\n  if(parseInt(currentNodeBalance) == 50000){\n    return 'full';\n  }\n  else{\n    return 'accepting';\n  }\n})\n\nexport const updateNodeStats = createAsyncThunk('node/updateNodeStats', async () => {\n  const response = await controller.methods.nodeCount().call();\n  const nodeId = parseInt(response) - 1;\n  const nodeBalance = await controller.methods.getCumulativeNodeDeposit(nodeId).call();\n  let status\n  if(parseInt(nodeBalance) == 50000){\n    status = 'full';\n  }\n  else{\n    status = 'accepting';\n  }\n\n  return {nodeId: nodeId, nodeBalance: nodeBalance, status: status}\n})\n\n\nexport const isOwner = createAsyncThunk('node/isOwner', async (_user) => {\n  const response = await controller.methods.owner().call();\n  const acts = await web3.eth.getAccounts(); \n\n  if(response == acts[0]){\n    return 'yes';\n  }\n  else{\n    return 'no';\n  }\n  \n})\n\n\n\nconst nodeSlice = createSlice({\n    name: 'node',\n    initialState: {\n      balance: -1,\n      status:'idle',\n      error:'',\n      currentNode: -1,\n      user:'',\n      owner:false,\n      depositStatus:'full'\n    },\n    reducers: {\n      // omit existing reducers here\n    },\n    extraReducers: (builder) => {\n      // Add reducers for additional action types here, and handle loading state as needed\n      builder.addCase(getUserAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.status = 'succeeded'\n        state.user = action.payload\n\n      })\n      .addCase(getBalanceAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.status = 'succeeded'\n        state.balance = action.payload\n      })\n      .addCase(getNodeAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.status = 'succeeded'\n        state.currentNode = action.payload\n      })\n      .addCase(getDepositStatusAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.status = 'succeeded'\n        state.depositStatus = action.payload\n      })\n      .addCase(updateNodeStats.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.depositStatus = action.payload.status\n        state.balance = action.payload.nodeBalance\n        state.currentNode = action.payload.nodeId\n        state.status ='func'\n      })\n      .addCase(isOwner.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.owner = action.payload\n      })\n      .addCase(createNodeAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        if(Boolean(action.payload) == true){\n          state.currentNode = parseInt(state.currentNode) + 1\n          state.balance = 0\n          state.depositStatus = 'accepting'\n\n        }\n        else{\n          state.error = 'err'\n        }\n\n      })\n    }\n})\n\n\n  export default nodeSlice.reducer"]},"metadata":{},"sourceType":"module"}